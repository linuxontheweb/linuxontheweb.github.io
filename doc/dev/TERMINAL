Bash ABNF grammar:/*«*/

<ALPHA> ::= a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|
             A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z

<DIGIT> ::= 0|1|2|3|4|5|6|7|8|9

<NUMBER> ::= <DIGIT>
           | <NUMBER> <DIGIT>

<WORD> ::= <ALPHA>
         | <WORD> <ALPHA>
         | <WORD> '_'

<WORD-LIST> ::= <WORD>
             |  <WORD-LIST> <WORD>

<ASSIGNMENT-WORD> ::= <WORD> '=' <WORD>


<REDIRECTION> ::=  '>' <WORD>
                |  '<' <WORD>
                |  <NUMBER> '>' <WORD>
                |  <NUMBER> '<' <WORD>
                |  '>>' <WORD>
                |  <NUMBER> '>>' <WORD>
                |  '<<' <WORD>
                |  <NUMBER> '<<' <WORD>
                |  '<&' <NUMBER>
                |  <NUMBER> '<&' <NUMBER>
                |  '>&' <NUMBER>
                |  <NUMBER> '>&' <NUMBER>
                |  '<&' <WORD>
                |  <NUMBER> '<&' <WORD>
                |  '>&' <WORD>
                |  <NUMBER> '>&' <WORD>
                |  '<<-' <WORD>
                |  <NUMBER> '<<-' <WORD>
                |  '>&' '-'
                |  <NUMBER> '>&' '-'
                |  '<&' '-'
                |  <NUMBER> '<&' '-'
                |  '&>' <WORD>
                |  <NUMBER> '<>' <WORD>
                |  '<>' <WORD>
                |  '>|' <WORD>
                |  <NUMBER> '>|' <WORD>

<SIMPLE-COMMAND-ELEMENT> ::= <WORD>
                          |  <ASSIGNMENT-WORD>
                          |  <REDIRECTION>

<REDIRECTION-LIST> ::= <REDIRECTION>
                    |  <REDIRECTION-LIST> <REDIRECTION>

<SIMPLE-COMMAND> ::=  <SIMPLE-COMMAND-ELEMENT>
                   |  <SIMPLE-COMMAND> <SIMPLE-COMMAND-ELEMENT>

<COMMAND> ::=  <SIMPLE-COMMAND>
            |  <SHELL-COMMAND>
            |  <SHELL-COMMAND> <REDIRECTION-LIST>

<SHELL-COMMAND> ::=  <FOR-COMMAND>
                  |  <CASE-COMMAND>
                  |  while <COMPOUND-LIST> do <COMPOUND-LIST> done
                  |  until <COMPOUND-LIST> do <COMPOUND-LIST> done
                  |  <SELECT-COMMAND>
                  |  <IF-COMMAND>
                  |  <SUBSHELL>
                  |  <GROUP-COMMAND>
                  |  <FUNCTION-DEF>

<FOR-COMMAND> ::=  for <WORD> <NEWLINE-LIST> do <COMPOUND-LIST> done
            |  for <WORD> <NEWLINE-LIST> '{' <COMPOUND-LIST> '}'
            |  for <WORD> ';' <NEWLINE-LIST> do <COMPOUND-LIST> done
            |  for <WORD> ';' <NEWLINE-LIST> '{' <COMPOUND-LIST> '}'
            |  for <WORD> <NEWLINE-LIST> in <WORD-LIST> <LIST-TERMINATOR>
                   <NEWLINE-LIST> do <COMPOUND-LIST> done
            |  for <WORD> <NEWLINE-LIST> in <WORD-LIST> <LIST-TERMINATOR>
                   <NEWLINE-LIST> '{' <COMPOUND-LIST> '}'

<SELECT-COMMAND> ::=  select <WORD> <NEWLINE-LIST> do <LIST> done
                   |  select <WORD> <NEWLINE-LIST> '{' <LIST> '}'
                   |  select <WORD> ';' <NEWLINE-LIST> do <LIST> done
                   |  select <WORD> ';' <NEWLINE-LIST> '{' LIST '}'
                   |  select <WORD> <NEWLINE-LIST> in <WORD-LIST>
                           <LIST-TERMINATOR> <NEWLINE-LIST> do <LIST> done
                   |  select <WORD> <NEWLINE-LIST> in <WORD-LIST>
                           <LIST-TERMINATOR> <NEWLINE-LIST> '{' <LIST> '}'

<CASE-COMMAND> ::=  case <WORD> <NEWLINE-LIST> in <NEWLINE-LIST> esac
                 |  case <WORD> <NEWLINE-LIST> in <CASE-CLAUSE-SEQUENCE>
                         <NEWLINE-LIST> esac
                 |  case <WORD> <NEWLINE-LIST> in <CASE-CLAUSE> esac

<FUNCTION-DEF> ::=  <WORD> '(' ')' <NEWLINE-LIST> <GROUP-COMMAND>
                 |  function <WORD> '(' ')' <NEWLINE-LIST> <GROUP-COMMAND>
                 |  function <WORD> <NEWLINE-LIST> <GROUP-COMMAND>

<SUBSHELL> ::=  '(' <COMPOUND-LIST> ')'

<IF-COMMAND> ::= if <COMPOUND-LIST> then <COMPOUND-LIST> fi
          | if <COMPOUND-LIST> then <COMPOUND-LIST> else <COMPOUND-LIST> fi
          | if <COMPOUND-LIST> then <COMPOUND-LIST> <ELIF-CLAUSE> fi

<GROUP-COMMAND> ::=  '{' <LIST> '}'

<ELIF-CLAUSE> ::= elif <COMPOUND-LIST> then <COMPOUND-LIST>
           | elif <COMPOUND-LIST> then <COMPOUND-LIST> else <COMPOUND-LIST>
           | elif <COMPOUND-LIST> then <COMPOUND-LIST> <ELIF-CLAUSE>

<CASE-CLAUSE> ::=  <PATTERN-LIST>
                |  <CASE-CLAUSE-SEQUENCE> <PATTERN-LIST>

<PATTERN-LIST> ::=  <NEWLINE-LIST> <PATTERN> ')' <COMPOUND-LIST>
                 |  <NEWLINE-LIST> <PATTERN> ')' <NEWLINE-LIST>
                 |  <NEWLINE-LIST> '(' <PATTERN> ')' <COMPOUND-LIST>
                 |  <NEWLINE-LIST> '(' <PATTERN> ')' <NEWLINE-LIST>

<CASE-CLAUSE-SEQUENCE> ::=  <PATTERN-LIST> ';;'
                         |  <CASE-CLAUSE-SEQUENCE> <PATTERN-LIST> ';;'

<PATTERN> ::=  <WORD>
            |  <PATTERN> '|' <WORD>


<LIST> ::=   <NEWLINE-LIST> <LIST0>

<COMPOUND-LIST> ::=  <LIST>
                  |  <NEWLINE-LIST> <LIST1>

<LIST0> ::=   <LIST1> '\n' <NEWLINE-LIST>
           |  <LIST1> '&' <NEWLINE-LIST>
           |  <LIST1> ';' <NEWLINE-LIST>

<LIST1> ::=   <LIST1> '&&' <NEWLINE-LIST> <LIST1>
           |  <LIST1> '||' <NEWLINE-LIST> <LIST1>
           |  <LIST1> '&' <NEWLINE-LIST> <LIST1>
           |  <LIST1> ';' <NEWLINE-LIST> <LIST1>
           |  <LIST1> '\n' <NEWLINE-LIST> <LIST1>
           |  <PIPELINE-COMMAND>

<LIST-TERMINATOR> ::= '\n'
                   |  ';'

<NEWLINE-LIST> ::=
                  |  <NEWLINE-LIST> '\n'

<SIMPLE-LIST> ::=  <SIMPLE-LIST1>
                |  <SIMPLE-LIST1> '&'
                |  <SIMPLE-LIST1> ';'

<SIMPLE-LIST1> ::=  <SIMPLE-LIST1> '&&' <NEWLINE-LIST> <SIMPLE-LIST1>
                 |  <SIMPLE-LIST1> '||' <NEWLINE-LIST> <SIMPLE-LIST1>
                 |  <SIMPLE-LIST1> '&' <SIMPLE-LIST1>
                 |  <SIMPLE-LIST1> ';' <SIMPLE-LIST1>
                 |  <PIPELINE-COMMAND>

<PIPELINE-COMMAND> ::= <PIPELINE>
                    |  '!' <PIPELINE>
                    |  <TIMESPEC> <PIPELINE>
                    |  <TIMESPEC> '!' <PIPELINE>
                    |  '!' <TIMESPEC> <PIPELINE>

<PIPELINE> ::=
          <PIPELINE> '|' <NEWLINE-LIST> <PIPELINE>
       |  <COMMAND>

<TIME-OPT> ::= '-p'

<TIMESPEC> ::=  time
             |  time <TIME-OPT>

.XE "BNF (Backus-Naur Form)"
.XE "bash" "syntax, BNF form of"
/*»*/

/*10/14/24: Color output/*«

Properly colorizing terminal output is OFFICIALLY a vexation.  To get the 'ls'
command to properly colorize its output (@WKIUTYUIP), I am using an add_rows
variable that is tracked by shell.execute starting @MJUEYSKDH.  Also,
shell.execute is called with an addRows option (@DJUYEKLMI), which is only for
backquote execution. I'm not quite sure anymore what is going on here, and it
all seems quite hackish. Perhaps we should just get rid of all add_rows/addRows
things, and let everything just get colored wonkishly in case of...(backquote
execution)???.  Also, addPrompts was inserted in lib mail.js because of using
term.getch in coms/mail.js, which gets sent to Term.response (@LKMDNHYTRG).  I
started adding color yesterday to the 'err' response, and to the new 'ok'
response. It's all starting to bite me on the a** once again.

»*/
/*10/13/24: Updated command calling conventions and created 'stdok' responses«

Updated the command calling convention (@SKIOPRHJT) from:
	com(args, {opts, term, stdin, etc...})
to:
	com(args, opts, {term, stdin, etc...})

The callee is expected to use this notation:

const mycommand = async(args, opts, _)=>{
	const {term, stdin} = _;
};

Now how about having a 'stdok' stream, rather than using 'stdout' for "good" reponses?
Then, we can different colors for stdok (green) and stderr (red) on the terminal.
stdout is the only response that might get redirected into a file. These others are
simply informational for the interactive user, and do not make sense as true "output".

»*/
/*10/11/24: Just getting back into the whole command module loading/reloading thing.«
Up to now, it has been quite a complex thing juggling different variables like
ALL_LIBS, globals.shell_libs, NS.libs, and NS.coms.

Now, ALL_LIBS is the NS.libs object. This is an object like:
NS.libs={
	lib1: [com11, com12,...],
	lib2: [com21, com22, ...]
}

...where these are lists of command names (string). These commands will *not* be imported
in case they are already defined within the active shell commands.

Upon successfully importing a command library, each library's exported command functions
and options (both are objects) are put onto NS.coms, like:
NS.coms={
	lib1: {coms: lib1funcs, opts: lib1opts}
}

ADD_COMS is an array that includes all command libraries to be imported upon terminal
initialization.

DEL_COMS is used by developers to remove all of the commands from the active
commands (but not if a particular command WASN'T ACTUALLY IMPORTED by the
library, e.g. see @CJIUKLEH). Their command options are likewise removed from
the active command options.



In terms of status updates, how about just NOT putting the terminal in fullscreen,
and using the bottom status bar???


Now... back to email (see me in mail.js...)!!!

»*/
/*10/10/24: Want a hotkey that toggles the ondevreload method, rather than using the«
hardcoded variable (USE_ONDEVRELOAD). Done @VMUIRPOIUYT.

Want a dedicated 1-line status bar at the bottom of the screen in "normal" CLI mode
to allow a place for status messages of long(-ish) term commands processes, that might,
i.e. be downloading a large file or connecting to some service. This is good for commands
(like ffmpeg) that are frequently updating their progress. In standard Linux systems,
the stderr stream is normally used for this kind of updating, but these are not actually
*errors*, so it doesn't really make any sense to do this.


»*/
/*10/9/24: Updated the entire command importing machinery, and added a ondevreload method«
(depending on the truth of the global USE_ONDEVRELOAD variable), which, if it
exists, is called by the desktop's win_reload method (instead of reloading the
actual application window). Using the ALL_LIBS method allows the shell to
"know" that it must do an implicit import of a given command library
(@QKIUTOPLK), because all of the commands are initialized as the (string) names
of the library (@MYKLJDHFK) rather than with the function bodies (they are
initialized as "true builtins" @FWPORUITJ).
»*/
/*10/5/24: Setting environment variables«

Normally this is done through .bashrc files, using export. But I don't want to mess with
the complexity of machine-reading text files. Right now, the ENV variable is set here, which
forces us to manually set all environment vars on the command line. I want ENV
to be a global variable (which I just added into config.js as globals.TERM_ENV).

Now to set persistent vars to ENV, just save them to ~/.env, e.g.:
VAR1=Something
BLAH=What in the hell

»*/

//Notes (Old)«

/*Making data files (Sept/Oct 2024)«
const com_mkdat = async(args, o)=>{
	const {term, opts, stdin} = o;
	let f = args.shift();
	if (!f) return;
	let arr = await f.toParNodeAndName(term);
	if (!arr) return {err: `Not found: ${f}`};
	let par = arr[0];
	let name = arr[1];
	let fullpath = arr[2];
	let kid = await fullpath.toNode();
//Updating
	if (kid) {
if (!kid.data) return {err: "Not a data node!"}
if (!await kid.setValue({type: "harko99998", FROYNKMISCH: 4321.8765})) return {err: "Could not set value"};
log(kid);
log(kid.data);
return;
	}
//Creating data node
	kid = await fsapi.writeDataFile(fullpath, {value: 1, type: "number"});
};
»*/
/*Notes (September 2024)«
9/6/2024:
Made a global variable, "appclass".

Got rid of all things dealing with "ssh" (which is just a stupid amount of complexity
for the real world benefit that is received).

9/5/2024:

@XOPIUYTK
Looking at the editor/pager specific functions like init_edit_mode and init_pager_mode,
as well as modequit, in order to see how this can be improved and generalized to allow
for more novel applications. Want a generic workflow for entering and leaving different
application screens. The newly invoked application needs to get a handle on the 
terminal's current lines array. Then, upon quitting, it needs to give this back to
the terminal. We need the ability to do abitrarily deep recursions of applications
calling applications as submodes, calling applications as submodes...

Now after revamping everything:
It looks like the way we are switching the terminal's onescape handler back and forth
is the only thing that (almost certainly) won't allow use to do arbitrary recursion,
and we are going to need to need to attach it to the various screen_state objects.

And now it looks good for doing our crazy recursion idea.

Took out @SKLIOPMN, because this is a trivial function that unnecessarily complicates
the logic with application specific purposes.

Updated on 9/4/2024:

@SURMPLRK: The algorithm has been improved because the max_cols was being
initialized to stupidly high values, given normal terminal widths, causing
fmt_ls to be recursively called waaaay too many times.  

Also @JSOJPRI, which now has a while(true) loop, that *looks like* it *should*
always break...
»*/
/*Broken (now fixed)://«
1) Make a file with the 'touch' command
2) Use the '_blobs' command to verify there is no saved blob
3) Put something in that file with vim (this bug doesn't happen with shell redirects)
4) Verify that it has a saved blob with the '_blobs' command
5) Refresh the page
6) Verify that is no longer has a saved blob with the '_blobs' command
//»*/
//Issues«
/*@JEPOIKLMJYH: I don't understand why this was giving errors on backspaces
after pressing the up key in order to scroll back in history, but now it isn't!!
*/
//»
/*"Importing" command libraries via com_import is [NO LONGER] a deprecated solution.«
Instead, use the ALL_LIBS object, which stores the names of all of the 
commands, under an array that is keyed by the name of the given command
library in coms/, but just without the ending '.js'. This is a very
robust, quick&dirty solution to a problem that is made more complex with
something like an "import" command.
»*/
/*Websockets are *NOT* used in a kind of ssh mechanism.«

DUMB/COMPLEX IDEA BELOW!!!!
The 'ssh' command allows for 1 'server' terminal and 1 'client' terminal to
connect to the Node.js backend via websockets. The server terminal should have
all relevant environment variables set before executing the 'ssh --server' command, 
which locks the terminal.

"ssh immediate mode" means that the client sends everything after the prompt
to the ssh server. This is set via 'ssh -i'. While in immediate mode, it
can be terminated via Ctrl+c. Otherwise, any arguments to the ssh command
are interpreted as a command to be passed along to the server. This means
that all of the normal piping and redirections should work.

»*/

//»

//DevShell object«

const dev_commands = {//«

echo: function(args, opts, _) {//«
this.run=async()=>{
	for (let arg of args){
		_.out(arg);
		await sleep(1500);
	}
	_.out(EOF);
	this.ok();
};

},//»
pipe: function(args, opts, _){//«

let num = args.shift();
if (num) num = parseInt(num);
else num=1;

this.pipein=(val)=>{
log(val, num);
	if (isStr(val)) val = val.repeat(num);
//log(val);
	_.out(val);
	if (isEOF(val)) this.ok();
};

}//»

};//»

const dev_options = {};

const DevCommand = function(com_fn, args, opts, _){//«
	let com = new com_fn(args, opts, _);
	this.init = com.init;
	this.run = com.run;
	com.args=args;
	com.opts=opts;
	com._=_;
	if (_.pipein){
		this.pipein = com.pipein;
	}
	this.end = new Promise((Y,N)=>{
		com.end = Y;
		com.ok=()=>{Y(E_SUC);};
		com.no=()=>{Y(E_ERR);};
	});
};//»
const DevScript = function(com_lines, script_name, args, _){//«
	let prom_cb;
	this.end = new Promise(async(Y,N)=>{prom_cb = Y;});
	this.run=async()=>{
	};
};//»
const DevNoCommand = function(){//«

};//»
const DevErrCommand = function(err, _){//«

this.run=()=>{
	_.err(err);
};
this.end=()=>{
	return {code: E_ERR};
};

};//»

const DevShell = function(term){

//Var«

const shell = this;

/*Very dumbhack to implement cancellations of hanging commands, e.g. that might do fetching,«
so that no output from a cancelled command is sent to the terminal, although
whatever the command might be doing to keep it busy is still happening, so it
is up to the shell user to be aware of what is going on behind the scenes:

In shell.execute("command --line -is here"), the first local variable that is
set is started_time (@WIMNNUYDKL).

There is a global cancelled_time that is set when we do a Ctrl+c when the shell is busy.

Immediately after every 'await' in shell.execute(), we do the following check:

if (started_time < cancelled_time) return;

»*/
this.cancelled_time = 0;

//»

const get_script_text = async(comword, cur_dir)=>{//«
	const e=s=>{
		return {err: `${comword}: ${s}`};
	};
	let node = await fsapi.pathToNode(normPath(comword, cur_dir));
	if (!node) return e(`not found`);
	let app = node.appName;
	if (app===FOLDER_APP) return e("is a directory");
	if (app!==TEXT_EDITOR_APP) return e("not a text file");
	if (!comword.match(/\.sh$/i)){
		return e(`only executing files with '.sh' extension`);
	}
	let text = await node.text;
	if (!text) return e("no text returned");
	return {lines: text.split("\n")};
};//»

const execute_file = async (comword, script_args, cur_dir, env)=>{//«

	const e=s=>{
		return {err: `${comword}: ${s}`};
	};
	let node = await fsapi.pathToNode(normPath(comword, cur_dir));
	if (!node) return e(`not found`);
	let app = node.appName;
	if (app===FOLDER_APP) return e("is a directory");
	if (app!==TEXT_EDITOR_APP) return e("not a text file");
	if (!comword.match(/\.sh$/i)){
		return e(`only executing files with '.sh' extension`);
	}
	let text = await node.text;
	if (!text) return e("no text returned");
	let rv;
	let lines = text.split("\n");
	let out = [];
	let last_code;
	for (let ln of lines){
		let com = ln.trim();
		if (!com) continue;
		let {code, isExit} = await this.execute(com, {script_out: out, env, script_args, script_name: comword});
		last_code = code;
		if (isExit) break;
	}
//	return out;
	return {code: last_code, out};
};//»
this.execute=async(command_str, opts={})=>{//«

const can=()=>{//«
//Cancel test function
	return started_time < this.cancelled_time;
};//»

//Init/Var«
//WIMNNUYDKL

let started_time = (new Date).getTime();

let {script_out, script_args, script_name, env}=opts;

const sherr=(arg)=>{//«
	term.response(`sh: ${arg}`, {isErr: true});
//	if (!script_name) term.response_end();
	return {code: E_ERR};
};//»
let rv;

//Where does the output go?
let redir;

//This is only used for pipeline commands that are after the first command
// cat somefile.txt | these | might | use | the | stdin | array
let stdin;

//Refuse and enter command that seems too long for our taste
if (command_str.length > MAX_LINE_LEN) return sherr(`'${command_str.slice(0,10)} ...': line length > MAX_LINE_LEN(${MAX_LINE_LEN})`, script_out);

command_str = command_str.replace(/^ +/,"");
//»

//Parser«

//Escaping/Quoting«
//Only for creating newlines in single quotes: $'1\n2' and escaping spaces outside of quotes
let arr = shell_escapes([command_str]);

//Makes quote objects from single, double and backtick quotes. Fails if not terminated
arr = shell_quote_strings(arr);
if (isStr(arr)) return sherr(arr);
//»
//Tokenization«

//Comments are stripped
//This creates word objects and '$' objects.
//It also creates '>' and '>>' redirections.
//All unsupported tokens (redirects like '<' and control like '&') cause failure

let toks = shell_tokify(arr);
if (isStr(toks)) return sherr(toks);
//»
//Collect commands with their arguments«
let com = [];
let coms = [];
for (let tok of toks){
	if (tok.c_op){
		coms.push({com});
		com = [];
		coms.push(tok);
	}
	else{
		com.push(tok);
	}
}
if (com.length) coms.push({com});
//»
//Collect pipelines with their subsequent logic operators (if any)«
let pipes = [];
let pipe = [];
for (let tok of coms){
	if (tok.c_op && tok.c_op != "|"){
		if (tok.c_op==="&&"||tok.c_op==="||") {
			pipes.push({pipe, type: tok.c_op});
		}
		else {
			pipes.push({pipe}, tok);
		}
		pipe = [];
	}
	else if (!tok.c_op){
		pipe.push(tok);
	}
}
if (pipe.length) pipes.push({pipe});
//»
//Collect ';' separated lists of pipelines+logic operators (if any)«
let statements=[];
let statement=[];
for (let tok of pipes){
	let cop = tok.c_op;
	if (cop) {
		if (cop==="&"||cop===";"){
			statements.push({statement, type: cop});
			statement = [];
		}
		else{
			return sherr(`Unknown control operator: ${cop}`);
		}
	}
	else{
		statement.push(tok);
	}
}
if (statement.length) statements.push({statement});
//»

/*BAD LOGIC«
//NEUTYIOP
let all3 = [];
let andlist = [];
for (let tok of all2){
	if (tok.c_op && tok.c_op != "&&"){
		all3.push({andlist});
		andlist = [];
		all3.push(tok);
	}
	else if (!tok.c_op){
		andlist.push(tok);
	}
}
if (andlist.length) all3.push({andlist});

//WMJFOPUT
let statements = [];
let orlist = [];
for (let tok of all3){
	if (tok.c_op && tok.c_op != "||"){
		statements.push({orlist});
		orlist = [];
	}
	else if (!tok.c_op){
		orlist.push(tok);
	}
}
if (orlist.length) statements.push({orlist});
»*/

//»

let lastcomcode;
STATEMENT_LOOP: for (let state of statements){//«A 'statement' is a list of boolean-separated pipelines.

let loglist = state.statement;
if (!loglist){
	return sherr(`Logic list not found!`);
}
LOGLIST_LOOP: for (let i=0; i < loglist.length; i++){//«
	let pipe = loglist[i];
	let pipelist = pipe.pipe;
	if (!pipelist){
		return sherr(`Pipeline list not found!`);
	}
	let pipetype = pipe.type;

	let pipeline = [];
	let pipein;

	for (let j=0; j < pipelist.length; j++) {//«
		let inpipe = j < pipelist.length-1;
const out_cb=(lns, opts={})=>{//«

if (can()) return;

if (inpipe){
let next_com = pipeline[j+1];
if (next_com.pipein) next_com.pipein(lns);
return;
}

if (isStr(lns)) lns=[lns];
else if (isEOF(lns)){}
else if (!isArr(lns)){
log(lns);
throw new Error("Invalid value in out_cb");
}

//if (save_lns) return save_lns.push(...lns);

//MDKLIOUTYH
//else{
term.response(lns, opts);
term.scroll_into_view();
term.refresh();
//}
};//»
const err_cb=(lns)=>{//«
if (can()) return;
if (isStr(lns)) lns=[lns];
else if (!isArr(lns)){
log(lns);
throw new Error("Invalid value in err_cb");
}
term.response(lns, {isErr: true});
term.scroll_into_view();
term.refresh();

};//»
const suc_cb=(lns)=>{//«
if (can()) return;
if (isStr(lns)) lns=[lns];
else if (!isArr(lns)){
log(lns);
throw new Error("Invalid value in suc_cb");
}
term.response(lns, {isSuc: true});
term.scroll_into_view();
term.refresh();
};//»
const wrn_cb=(lns)=>{//«
if (can()) return;
if (isStr(lns)) lns=[lns];
else if (!isArr(lns)){
log(lns);
throw new Error("Invalid value in wrn_cb");
}
term.response(lns, {isWrn: true});
term.scroll_into_view();
term.refresh();
};//»
const inf_cb=(lns)=>{//«
if (can()) return;
if (isStr(lns)) lns=[lns];
else if (!isArr(lns)){
log(lns);
throw new Error("Invalid value in inf_cb");
}
term.response(lns, {isInf: true});
term.scroll_into_view();
term.refresh();
};//»

		let arr = pipelist[j].com;
		let args=[];

//Everything here
//Expansions/Redirections«

//1) Environment variable substitution
//2) File globbing '*', '?' and character ranges [a-zA-Z0-9]
//3) Curly brace expansion:
//
//$ echo file{0..3}.txt
//file0.txt file1.txt file2.txt file3.txt
		rv = await all_expansions(arr, term, {script_name, script_args});
		if (can()) return;
		if (rv){
			term.response(rv, {isErr: true});
		}

//- Turn quote objects into word objects
//- Single quotes that start with '$' look for internal escapes (currently only newline)
//- Backquotes are executed and replaced with the output
		for (let i=0; i < arr.length; i++){//«
			let tok = arr[i];
			let typ = tok.t;
			let val = tok[typ];
			if (typ==="quote") { 
				let typ = tok.quote_t;
				let ds = tok['$'];
				let outstr='';
				for (let ch of val){
					if (isObj(ch)&&ch.t=="esc"){
						if (ch.esc=="n"&&typ=="'"&&ds) outstr+="\n";
						else outstr+=ch.esc;
					}
					else outstr+=ch;
				}
				val = outstr;
				if (typ=="\x60") {
					let out=[];
//DJUYEKLMI
					await this.execute(val, {script_out: out, env});
					if (can()) return;
					if (isStr(out)) val = out;
					else if (isArr(out)&&out.length) val = out.join(" ");
					else val = "";
				}
//				arr[i]={t:"word", word: val, from_quote: true};
				arr[i]={t:"word", word: val};
			}
		}//»

//All sequences of non-whitespace separated quotes and words are concatenated:
//~$ echo "q 1"A"q 2""q 3"B   "q 4"C"q       5"D"q 6"
//q 1Aq 2q 3B q 4Cq       5Dq 6
		for (let i=0; i < arr.length-1; i++){//«
			let tok0 = arr[i];
			let tok1 = arr[i+1];
//XCFIUYO
//			let have_quote = tok0.from_quote || tok1.from_quote;
//			if (tok0.word && tok1.word && have_quote){
			if (tok0.word && tok1.word){
//				arr[i] = {t: "word", word: `${tok0.word}${tok1.word}`, from_quote: true}
				arr[i] = {t: "word", word: `${tok0.word}${tok1.word}`};
				arr.splice(i+1, 1);
				i--;
			}
		}//»

//Concatenate all sequences of escaped spaces and words
// ~$ touch this\ is\ cool.txt
		for (let i=0; i < arr.length-1; i++){//«
			let tok0 = arr[i];
			let tok1 = arr[i+1];
			if (tok0.esc === " " || tok1.esc === " "){
				arr[i] = {t: "word", word: `${tok0.word||" "}${tok1.word||" "}`, esc: tok1.esc}
				arr.splice(i+1, 1);
				i--;
			}
		}//»

//- Create redirection objects
//- Objects are converted into strings ({t:"word", word: "blah"} -> "blah")
//- Replace tilde with home path
		for (let i=0; i < arr.length; i++){//«
			let tok = arr[i];
			let typ = tok.t;
			let val = tok[typ];
			if (tok===" "){
				continue;
			}
			if (typ==="r_op"){
				let rop = tok.r_op;
				if (!(rop==">"||rop==">>")) {
					return sherr(`unsupported operator: '${tok.r_op}'`);
				}
				let tok2 = arr[i+1];
				if (!tok2) return sherr("syntax error near unexpected token `newline'");
				if (tok2.t == "quote") tok2={t: "word", word: tok2.quote.join("")}
				if (tok2==" ") {
					i++;
					tok2 = arr[i+1];
				}
				if (!(tok2 && tok2.t==="word")) return sherr(`invalid or missing redirection operand`);
				arr.splice(i+1, 1);
				val = null;
				redir = [tok.r_op, tok2.word];
			}
			if (val) {
				if (val.match(/^~/)){
					if (val==="~") val = globals.HOME_PATH;
					else if (val.match(/^~\x2f/)) val = globals.HOME_PATH+val.slice(1);
				}
				args.push(val);
			}
		}//»

		arr = args;

//Set environment variables (exports to terminal's environment if there is nothing left)
		rv = add_to_env(arr, env, {term});
		if (rv.length) term.response(rv, {isErr: true});
		if (arr[0]==" ") arr.shift();
//»

//Get the command. Immediately return to prompt if it is empty and we are not in a script.
		let comword = arr.shift();
		if (!comword) {
			pipeline.push(new DevNoCommand());
			continue;
		}
//Replace with an alias if we can«
		let alias = ALIASES[comword];
		if (alias){
//This should allow aliases that expand with options...
			let ar = alias.split(/\x20+/);
			alias = ar.shift();
			if (ar.length){
				arr.unshift(...ar);
			}
		}//»

		let usecomword = alias||comword;
/*
		if (usecomword=="exit"){//«
			let numstr = arr.shift();
			let code;
			if (numstr){
				if (!numstr.match(/^-?[0-9]+$/)) sherr("exit: numeric argument required");
				else code = parseInt(numstr);
			}
			else if (arr.length) sherr("exit: too many arguments");
			if (script_name) return {code, isExit: true};
			term.response("sh: not exiting the toplevel shell", {isWrn: true});
			break STATEMENT_LOOP;
		}//»
*/
		let com = dev_commands[usecomword];
/*
		if (isStr(com)){//QKIUTOPLK«
//If we have a string rather than a function, do the command library importing routine.
//The string is always the name of the library (rather than the command)
//This happens when: 
//1) libraries are defined in PRELOAD_LIBS, and 
//2) this is the first invocation of a command from one of those libraries.
			try{
				await import_coms(com);//com is the library name
				if (can()) return;
			}catch(e){
				if (can()) return;
cerr(e);
				sherr(`command library: '${com}' could not be loaded`);
				return;
			}
			let gotcom = active_commands[usecomword];
			if (!(gotcom instanceof Function)){
				sherr(`'${usecomword}' is invalid or missing in command library: '${com}'`);
				return;
			}
			com = gotcom;
		}//»
*/

		if (!com) {//Command not found!«
//If the user attempts to use, e.g. 'if', let them know that this isn't that kind of shell

			if (CONTROL_WORDS.includes(comword)){
//				sherr(`control structures are not implemented`);
				pipeline.push(new DevErrCommand(`control structures are not implemented`, {err: err_cb}));
//				lastcomcode = E_ERR;
				continue;
			}

//It doesn't look like a file.
//EOPIUYTLM
			if (!comword.match(/\x2f/)) {
				pipeline.push(new DevErrCommand(`${comword}: command not found`, {err: err_cb}));
//				sherr(`${comword}: command not found`);
				continue;
			}

//XGJUIKM
//Try to execute a "shell script" from file
			let {lines, err} = await get_script_text(comword, term.cur_dir);
			if (err){
				pipeline.push(new DevErrCommand(err, {err: err_cb}));
//				sherr(err);
				continue;
			}
			pipeline.push(new DevScript(lines, comword, arr, {
				redir,
				script_out,
				stdin,
				inpipe,
				term,
				env,
				command_str
			}));
/*«
			let {out, code, err} = await execute_file(comword, arr, term.cur_dir, env);
			if (can()) return;
if (err){
sherr(err);
lastcomcode = E_ERR;
continue;
}
			if (Number.isFinite(code)) lastcomcode = code;

//Redir/Pipe/Script out«
			if (redir&&redir.length){
				let {err} = await write_to_redir(term, out.join("\n"), redir, env);
				if (can()) return;
				if (err) {
					term.response(err);
				}
				if (inpipe) stdin = [];
			}
			else if (inpipe) {
//Collect the stdin (used as optional input for the next command) for pipelines
				stdin = out;
			}
			else {
				if (script_out){
					 if (out && out.length) script_out.push(...out);
				}
				else{
					term.response(out);
				}
			}
//»
»*/
		}//»
		else {//«
//Look for the command's options
			let opts;
			let gotopts = dev_options[usecomword];

//Parse the options and fail if there is an error message
			rv = get_options(arr, usecomword, gotopts);
			if (rv[1]&&rv[1][0]) {
				term.response(rv[1][0]);
				continue;
			}
			opts = rv[0];

			pipeline.push(new DevCommand(com, arr, opts, {//«
				redir,
				script_out,
				pipein: j>0,
//				stdin,
//				inpipe,
				term,
				env,
				opts,
				command_str,
				out: out_cb,
				err: err_cb,
				suc: suc_cb,
				wrn: wrn_cb,
				inf: inf_cb,
			}));//»
		}//»

	}//»

	for (let com of pipeline){
		if (com.init) await com.init();
	}
	for (let com of pipeline){
		if (com.run) com.run();
	}
	for (let com of pipeline){
		if (com.end) await com.end;
	}

/*«
//Command response callbacks«

//Everything that gets sent to redirects and pipes must be collected
//By default, only the 'out' stream will be collected.
let save_lns;
if (inpipe || script_out || (redir && redir.length)){
save_lns = [];
}


//»

//SKIOPRHJT
//Run command

		let code = await com(arr, opts, {//«
			redir,
			script_out,
			stdin,
			inpipe,
			term,
			env,
			opts,
			command_str,
			out: out_cb,
			err: err_cb,
			suc: suc_cb,
			wrn: wrn_cb,
			inf: inf_cb,
		});//»

		if (can()) return;

if (!Number.isFinite(code)) {
log(code);
throw new Error(`Invalid return value from: '${usecomword}'`);
}


		lastcomcode = code;

		if (redir&&redir.length){
			let {err} = await write_to_redir(term, save_lns.join("\n"), redir, env);
			if (can()) return;
			if (err) {
				term.response(err);
			}
			save_lns = [];
		}

		if (inpipe) {
			stdin = save_lns;
		}
		else if (script_out) script_out.push(...save_lns);

»*/


//LEUIKJHX
/*
	if (lastcomcode===E_SUC){//SUCCESS«
		if (pipetype=="||"){
			for (let j=i+1; j < loglist.length; j++){
				if (loglist[j].type=="&&"){
					i=j;
					continue LOGLIST_LOOP;
				}
			}
			break LOGLIST_LOOP;
		}
//		else:
//			1 pipetype=="&&" and we automatically go to the next one or:
//			2 there is no pipetype because we are the last pipeline of this loglist, and the logic of the thing doesn't matter
	}
	else{//FAILURE
		if (pipetype=="&&"){
			for (let j=i+1; j < loglist.length; j++){
				if (loglist[j].type=="||"){
					i=j;
					continue LOGLIST_LOOP;
				}
			}
			break LOGLIST_LOOP;
		}
//		else:
//			1 pipetype=="||" and we automatically go to the next one or:
//			2 there is no pipetype because we are the last pipeline of this loglist, and the logic of the thing doesn't matter
	}//»
*/

}//»

}//»

//In a script, refresh rather than returning to the prompt
if (script_out) {
	term.refresh();
	return {code: lastcomcode};
}

//Command line input returns to prompt
term.response_end();

}//»

};

//»
/*«DevShell2*/
const DevShell2 = (()=>{

class BaseCommand {//«
	constructor(shell, term, env, args, next, redir){
		this.shell = shell;
		this.term = term;
		this.env = env;
		this.args = args;
		this.next = next;//The next command in a pipeline (if any). Scripts can't be a 
						//'next', since there currently is no scripting mechanism for 
						//reading an input stream.
						//But if this command is in a script, and is at the end of
						//a pipeline, when the script command is itself inside a pipeline,
						//then the 'next' arg here needs to be the next command
						//of *that* pipeline.
		this.redir = redir;
		this.awaitEnd = new Promise((Y,N)=>{
			this.end=(arg)=>{
				this.killed = true;
				Y(arg);
			};
		});
	}
	getPipe(){}
	run(){}
	kill(){
		this.killed = true;
	}
	ok(){
		this.end({code: E_SUC});
	}
	no(){
		this.end({code: E_ERR});
	}
	out(mess){//Only the output stream gets sent to redir or through pipes
		if (this.killed) return;
		if (this.redir){
			//Write to redirect file
			return;
		}
		if (this.next){
			if (this.next.pipeIn) this.next.pipeIn(mess);
			return;
		}
		this.term.response(mess);
	}
	err(mess){
		if (this.killed) return;
		this.term.response(mess,{isErr: true});
	}
	wrn(mess){
		if (this.killed) return;
		this.term.response(mess,{isWrn: true});
	}
	suc(mess){
		if (this.killed) return;
		this.term.response(mess,{isSuc: true});
	}
	inf(mess){
		if (this.killed) return;
		this.term.response(mess,{isInf: true});
	}

}//»
class com_Whatever extends BaseCommand {//«

	getOpts(){
		return {
			s:{
				a:1,
				b:2,
				c:3
			},
			l:{
				anoarg: 1,
				bmaybearg: 2,
				cneedarg:3
			}
		}
	}

	setPipe(){
		if (this.args.length) return;
		this.inPipe = true;
		this.pipeIn = (val) => {
			if (this.killed) return;
			//...process val...
			val = this.doThis(val);
			//...and send stuff out
			this.out(val);
			if (isEOF(val)){
				this.ok();
			}
		};
	}

	doThis(val){
	}
	doThat(val){
	}

	run(){
		if (this.inPipe) return;
		let arg1 = this.args.shift();
		//...process arg1... 
		if (badarg){//...maybe barf...
			this.err("Ohhhhh noooooo!!!!");
			this.no();
			return;
		}
		//...or send stuff out
		this.out("Heee hee heee heee!!!");
		this.ok();
	}

}//»
class ScriptCommand extends BaseCommand {//«
	setScriptName(name){
		this.scriptName = name;
	}
	async run(){
		let scr = this.script;
		if (!scr){
			this.err("No script");
			this.no();
			return;
		}
		let pipeIn;
		if (this.next && this.next.pipeIn) pipeIn = this.next.pipeIn;
		let last_code;
		for (let ln of scr){
			let {haveExit, code} = await this.shell.execute(ln, {
				scriptName: this.scriptName,
				scriptArgs: this.args,
				scriptPipeOut: pipeIn,
				env: this.env
			});
			last_code = code;
			if (haveExit) break;
		}
		this.end({code: last_code});
	}
}//»
class BadCommand extends BaseCommand {//«
	run(){
		this.err(this.mess);
		this.no();
	}
}//»
class NullCommand extends BaseCommand {//«
	run(){
		this.no();
	}
}//»

const parse = command_str => {//«

//Escaping/Quoting«
//Only for creating newlines in single quotes: $'1\n2' and escaping spaces outside of quotes
let arr = shell_escapes([command_str]);

//Makes quote objects from single, double and backtick quotes. Fails if not terminated
arr = shell_quote_strings(arr);
if (isStr(arr)) return arr;
//»
//Tokenization«

//Comments are stripped
//This creates word objects and '$' objects.
//It also creates '>' and '>>' redirections.
//All unsupported tokens (redirects like '<' and control like '&') cause failure

let toks = shell_tokify(arr);
if (isStr(toks)) return toks;

//»
//Collect commands with their arguments«
let com = [];
let coms = [];
for (let tok of toks){
	if (tok.c_op){
		if (!com.length) return `unexpected empty command (found: '${tok.c_op}')`;
		coms.push({com});
		com = [];
		coms.push(tok);
	}
	else{
		if (!com.length && tok===" "){}//Do not allow a command to begin with whitespace
		else com.push(tok);
	}
}
if (com.length) coms.push({com});
//»
//Collect pipelines with their subsequent logic operators (if any)«
let pipes = [];
let pipe = [];
for (let i=0; i < coms.length; i++){
	let tok = coms[i];
	if (tok.c_op && tok.c_op != "|"){//Anything "higher order" than '|' ('&&', ';', etc) goes here
		if (tok.c_op==="&&"||tok.c_op==="||") {
			if (!coms[i+1]) return "malformed logic list";
			pipes.push({pipe, type: tok.c_op});
		}
		else {
			pipes.push({pipe}, tok);
		}
		pipe = [];
	}
	else if (!tok.c_op){//Commands and redirects
		pipe.push(tok);
	}
	else if (pipe.length && coms[i+1]){//noop: This token "must" be a '|'
	}
	else {
		return "malformed pipeline";
	}

}
if (pipe.length) pipes.push({pipe});
//»
//Collect ';' separated lists of pipelines+logic operators (if any)«
let statements=[];
let statement=[];
for (let tok of pipes){
	let cop = tok.c_op;
	if (cop) {
		if (cop==="&"||cop===";"){
			statements.push({statement, type: cop});
			statement = [];
		}
		else{
			return `unknown control operator: ${cop}`;
		}
	}
	else{
		statement.push(tok);
	}
}
if (statement.length) statements.push({statement});
return statements;

//»

};//»
const flatten_expand_quotes=async arr=>{//«
	for (let i=0; i < arr.length; i++){
		let tok = arr[i];
		let typ = tok.t;
		let val = tok[typ];
		if (typ==="quote") { 
			let typ = tok.quote_t;
			let ds = tok['$'];
			let outstr='';
			for (let ch of val){
				if (isObj(ch)&&ch.t=="esc"){
					if (ch.esc=="n"&&typ=="'"&&ds) outstr+="\n";
					else outstr+=ch.esc;
				}
				else outstr+=ch;
			}
			val = outstr;
			if (typ=="\x60") {
				val="BACK_QUOTE_EXPANSION_HERE";
/*
				let out=[];
				await this.execute(val, {commandSubOut: out, env});
				if (isStr(out)) val = out;
				else if (isArr(out)&&out.length) val = out.join(" ");
				else val = "";
*/
			}
			arr[i]={t:"word", word: val};
		}
	}
}//»
const extract_redirects = arr => {//«
	let redir;
	let com = [];
	for (let i=0; i < arr.length; i++){
		let tok = arr[i];
		let typ = tok.t;
		let val = tok[typ];
		if (typ==="r_op"){
			let rop = tok.r_op;
			if (!(rop==">"||rop==">>")) {
				return {err: `unsupported operator: '${tok.r_op}'`};
			}
			let tok2 = arr[i+1];
//log("TOK2", tok2);
			if (!tok2) return {err: "syntax error near unexpected token `newline'"};
/*Shouldn't have any quotes or spaces«
			if (tok2.t == "quote") tok2={t: "word", word: tok2.quote.join("")}
			if (tok2==" ") {
				i++;
				tok2 = arr[i+1];
			}
»*/
			if (!(tok2 && tok2.t==="word")) return {err: `invalid or missing redirection operand`};
			arr.splice(i+1, 1);
			val = null;
			redir = [tok.r_op, tok2.word];
		}
		if (val) com.push(val);
	}
	return {com, redir};
}//»

return function(term){

this.cancelled_time = 0;

this.execute = async(command_str, opts={})=>{

const cancelled=()=>{//«
//Cancel test function
	return started_time < this.cancelled_time;
};//»

let started_time = (new Date).getTime();

//scriptPipeOut: when the command is in a script, at the end of a pipeline, but
//				 the script is itself in a pipeline. This is the next command-in-the-pipeline's 
//				 'pipeIn' function.
//commandSubOut: for command/backquote substitutions. Everything in the output 
//				 stream that would get printed to the terminal gets pushed into this array
const { scriptName, scriptArgs, scriptPipeOut, commandSubOut, env } = opts;

const sherr=mess=>{
	term.response(`sh: ${mess}`, {isErr: true});
	if (!scriptName) term.response_end();
};

let statements = parse(command_str);
if (isStr(statements)) {
	sherr(statements);
	return;
}

STATEMENT_LOOP: for (let state of statements){//«A 'statement' is a list of boolean-separated pipelines.

let loglist = state.statement;
LOGLIST_LOOP: for (let i=0; i < loglist.length; i++){//«
	let pipe = loglist[i];
	let pipelist = pipe.pipe;
	let pipetype = pipe.type;
	let pipeline = [];
//Better go "forwards" so any error messages will be in the left-to-right pipeline sequence
	for (let j=0; j < pipelist.length ; j++){//«
//	for (let j=pipelist.length-1; j >=0 ; j--){
		let err, com, redir;
		let arr = pipelist[j].com;
//dollar sign ($<digit>, $<word>), file glob (*?), and curly brace (e.g. {1..9})
//curly brace expansions only works on single "word" tokens, which DO NOT include quote strings
//But according to the POSIX spec, quotes should be treated as PARTS of word tokens rather than 
//separate tokens!
//In other words, there should (according to POSIX) be *no difference* in output between:
//    $ echo "a"{1..5}"b"
//...and...
//    $ echo a{1..5}b
//    => a1b a2b a3b a4b a5b
		err = await env_glob_brace_expansions(arr, term, {script_name: scriptName, script_args: scriptArgs});
		if (cancelled()) return;
//cwarn("HI");
//jlog(arr);
//Non-fatal (?) expansion error
		if (err) term.response(err, {isErr: true});
//Fake backquote expansion: `whatever --the hell` => "BACK_QUOTE_EXPANSION_HERE"
		await flatten_expand_quotes(arr);
		if (cancelled()) return;
//Concatenate non-whitespace-separated words into a single word
		for (let i=0; i < arr.length-1; i++){//«
			let tok0 = arr[i];
			let tok1 = arr[i+1];
			if (tok0.word && tok1.word){
				arr[i] = {t: "word", word: `${tok0.word}${tok1.word}`};
				arr.splice(i+1, 1);
				i--;
			}
		}//»
//Concatenate successive backslash-escaped spaces and words
		for (let i=0; i < arr.length-1; i++){//«
			let tok0 = arr[i];
			let tok1 = arr[i+1];
			if (tok0.esc === " " || tok1.esc === " "){
				arr[i] = {t: "word", word: `${tok0.word||" "}${tok1.word||" "}`, esc: tok1.esc}
				arr.splice(i+1, 1);
				i--;
			}
		}//»
//Remove spaces between all tokens

		for (let i=0; i < arr.length; i++){//«
			if (arr[i]==" "){
				arr.splice(i, 1);
				i--;
			}
		}//»

		({err, com, redir} = extract_redirects(arr));
		if (err){
			sherr(err);
			return;
		}
		err = add_to_env(com, env, {term});
		if (err.length) term.response(err, {isErr: true});
jlog(com);
		let comword = com.shift();
//Replace with an alias if we can«
		let alias = ALIASES[comword];
		if (alias){
//This should allow aliases that expand with options...
			let arr = alias.split(/\x20+/);
			comword = arr.shift();
			if (arr.length){
				com.unshift(...arr);
			}
		}//»

//log("COMWORD", comword);
//if comword === "exit": break STATEMENT_LOOP
//jlog(com);
//See if comword:

// 0) Is literally nothing (whitespace in the logical "machinery")
//	  - The shell command language doesn't allow completely empty commands (there must
//		at least be variables being assigned/exported)
//	  => use NullCommand (implicitly "falsey")

// 1) is a key in the "active_commands" object
//	  - is the value a string? => Need to load the command library given by the string 
//										into "active_commands", and reevaluate the value
//	  - is the value a subclass of BaseCommand? => use the "com_Whatever extends BaseCommand"!
//	  - after new'ing it, attempt to parse the options from getOpts() (or whatever), and if 
//		there's a failure => use BadCommand (with the option-parsing error message) instead.

// 2) has a path separater in it (it must be a shell script)
//	- locate the script (using the current directory if necessary) => use ScriptCommand

// 3) exists somewhere in the environmental PATH variable 
//  - for now, it must be a shell script, since we are only loading JS commands as modules 
//	  inside of the server-side /coms folder
//  - use ScriptCommand

// 4) Doesn't exist: use BadCommand

	}//»

}//»


}//»

//jlog(statements);
//log(command_str);
term.response_end();

};

};
})();
/*»*/

/*11/14/24:« Want to put the different quote types inside of the words as their own
array objects. How about word objects:

class EscChar {//«
	#ch;
	#qtyp;
	constructor(ch){
		this.ch = ch;
	}
	toString(keepSlash){
		if (this.qtyp==="$'"){
			//...
		}
		else if (this.qtyp) {
			if (this.qtyp==='"' && (this.ch==='"'||this.ch==='$')) return this.ch;
			return "\\"+this.ch;
		}
		return this.ch;
	}
}//»
class BQuote {//«
	#arr;
	constructor(){
		this.arr=[];
	}
	addVal(ch){
//bare 'ch' or escaped('`')
	}
	toString(){}
	get length(){}
}//»
class DQuote{//«
	#arr;
	constructor(){
		this.arr=[];
	}
	addVal(ch){
//bare 'ch' or escaped('$' or '"') or expansion result
	}
	toString(){}
	get length(){}
}//»
class SQuote{//«
	#arr;
	constructor(){
		this.arr=[];
	}
	addVal(ch){
//bare 'ch' (can't be a "'")
	}
	toString(){}
	get length(){}
}//»
class DSQuote{//«
	#arr;
	constructor(){
		this.arr=[];
	}
	addVal(ch){
//bare 'ch' or escaped 'ch'
	}
	toString(){}
	get length(){}
}//»

class Word {//«
	#arr;
	constructor(){
		this.arr=[];
	}
	addVal(ch){
//bare 'ch' or escaped 'ch' or quote object or expansion result
	}
	toString(){}
	get length(){}
}//»

»*/
/*11/12/24: dev_mode 'DEBUG' flag, esp. certain logging statements that might«
take up a lot of room in the console, like jlog(some_large_object). We've
inserted a d_CAS keysym in order to toggle this.
»*/
/*11/9/24: class Command« 


»*/
/*« The shell is going to set args, opts, _, stdin, and end (the call back to 
call when it is done, which has the return code) on 'this'.

const com_blah = function(args, opts, _){
	this.init=()=>{
		//Set up io, via pipes

	};
	this.run=()=>{

	};
};

const Command = function(com_fn, args, opts, _, stdin){
	this.end = new Promise((Y,N)=>{
		let com = new com_fn(args, opts, _, stdin);
		this.init = com.init;
		this.run = com.run;
		com.end = Y;
		com.ok=()=>{Y(E_SUC);};
		com.no=()=>{Y(E_ERR);};
		com.args=args;
		com.opts=opts;
		com._=_;
	});
};

const get_command=async(com_fn, args, opts, _ stdin)=>{
	let com = new Command(com_fn, args, opts, _, stdin);
	if (com.init && (com.init instanceof Function)) {
		await com.init();
	}
	return com;
};

let command = new Command(com_blah, args, opts, _, stdin);

...

await command.end();

»*/
/*11/5/24: We are NOT supporting any kind of arguments/options for the "shell scripts"«
detected @XGJUIKM. Parsing options are actually the job of the scripts themselves, 
via the 'getopt' command. The example scripts for 'getopt' are kept in ChromeOS
at /usr/local/share/doc/util-linux/.

The positional arguments are kept in $1->$9 ($0 is the name of the script). Now
we are properly detecting these @FOPLIHGB. A shift command would allow us to
support more positional args than just the 9 in $1->$9 ($0 can't be "shifted"
off from the zeroth position).

Also: spaces are inserted in between substituted params:

echo $USER$USER // me me

FIXED @XCFIUYO by getting rid of the 'have_quote' requirement (that only concatenated
successive quotes).

»*/
/*11/5/24: I know there is a flaw in my handling of "logic lists" (FIXED?):«
this && that || the && other 
...but I can't recreate it now. I am first collecting up sequences of
'&&' separated pipelines @NEUTYIOP, and then sequences of these
'||' separated 'andlists' @WMJFOPUT.

First, @SHJUTIOP, we loop through the 'andlists' of each 'orlist', and break
out of the first successful 'andlist' at @KDRETATY. We break out of the first
unsuccessful pipeline in each 'andlist' @TOPIKLMN. I know this is *NOT* the
correct way of implementing shell logic but for some strange reason, I can't
demonstrate the simple way that it differs.

I HAVE THE RECREATION OF THE BUG:
In bash:
$ true || false && echo hi
...outputs "hi", while mine skips over the entire 'andlist' of "false && echo hi", and
so the echo command is never reached.

What we need to do is use the return value of each pipeline.
In the case of success, skip over the next or-pipelines.
In the case of failure, skip over the next and-pipelines.


@LEUIKJHX: Hopefully this is the fix!


---------------------------------------------------------

Now with pattern matching:
Just updated the dotfile logic @SMKOIOPU so that we just match dotfiles in the case
of a leading dot:
	echo .*
...but leave out the dotfiles otherwise:
	echo *

»*/
/*« 10/26/24: Create a dev_shell object, so that we can toggle between it and the 
normal shell (Ctrl+Alt+s). It currently just has an execute method that just 
logs the command string calls response_end(). So now we can implement alternative
parsing methods, while still keeping all of the terminal's REPL (history and line
editing, etc.) capabilities perfectly in tact.
»*/
/*10/18/24: There may be issues with parsing @IORTYUEWJ: There we are just looking for«
the shortest match (like for pipes). So when we do:
	$ true|||false
...we get...
	I'm true
...rather than...
	syntax error near unexpected token `|'
So we *MUST* check for the next token to ensure it is a valid "word-type" token
rather than a metacharacter
»*/
//Notes«
/*Incorrect way to create success/error/warning colors @WOPIUTHSDKL.
Instead, we need to do it @DJKUIOJED*/
/*TODO:Update rest of the command libraries with the new response and return mechanism«

const com_what=(args, opts, _)=>{

const {term, out, err, suc} = _;
...
err("Error message in red here");
return E_ERR;
...
suc("Success message in green here");
return E_SUC;
...
//Standard output for the terminal (or pipes/redirects)
out(some_lines, {colors: opt_colors});
return E_SUC;

};

»*/
/*10/16/24: I've been getting into edge cases of expected shell behaviour, such as
whether to treat a non-existent command as a simple command failure or to exit the
current command line (which is what I was doing). Here, "barf" doesn't exist as a command:

$ barf ||  echo This will never be seen

Now (@EOPIUYTLM), we are sending an error response and setting lastcomcode to E_ERR.

*/
/*10/15/24: Getting command output streams to "just work".«

-There are 3 streams: out, err, suc
-Only the out stream will be sent through pipes and redirects (there should be a shell option)
to merge/flatten all streams into the out stream.
-The out stream can be arbitrarily colorized
-The err stream will be colored red
-The suc stream will be colored green

These are the names of the callbacks that are given in the "_" (3rd) argument to the
called commands (@SKIOPRHJT).

Commands should only return an error code @CKLOPUTIK.

Now need to update all commands so that they call the output functions (out, err, suc)
and return *either* E_SUC or E_ERR.

Want to give hints to the respective response callbacks (like @MDKLIOUTYH) whether
the terminal should do scroll_into_view and refresh. If we are in a tight loop, such
as in com_ls, we might want to save on the cpu cycles, when it comes to very long
(possibly recursive) listings.

»*/
//»

/*«DevShell*/
//SOTFKL
const DevShell = (()=>{

/*«Command Classes*/
class BaseCommand {//«
	constructor(shell, term, env, args, next, redir){
		this.shell = shell;
		this.term = term;
		this.env = env;
		this.args = args;
		this.next = next;//The next command in a pipeline (if any). Scripts can't be a 
						//'next', since there currently is no scripting mechanism for 
						//reading an input stream.
						//But if this command is in a script, and is at the end of
						//a pipeline, when the script command is itself inside a pipeline,
						//then the 'next' arg here needs to be the next command
						//of *that* pipeline.
		this.redir = redir;
		this.awaitEnd = new Promise((Y,N)=>{
			this.end=(arg)=>{
				this.killed = true;
				Y(arg);
			};
		});
	}
	getPipe(){}
	run(){}
	kill(){
		this.killed = true;
	}
	ok(){
		this.end({code: E_SUC});
	}
	no(){
		this.end({code: E_ERR});
	}
	out(mess){//Only the output stream gets sent to redir or through pipes
		if (this.killed) return;
		if (this.redir){
			//Write to redirect file
			return;
		}
		if (this.next){
			if (this.next.pipeIn) this.next.pipeIn(mess);
			return;
		}
		this.term.response(mess);
	}
	err(mess){
		if (this.killed) return;
		this.term.response(mess,{isErr: true});
	}
	wrn(mess){
		if (this.killed) return;
		this.term.response(mess,{isWrn: true});
	}
	suc(mess){
		if (this.killed) return;
		this.term.response(mess,{isSuc: true});
	}
	inf(mess){
		if (this.killed) return;
		this.term.response(mess,{isInf: true});
	}

}//»
class com_Whatever extends BaseCommand {//«

	getOpts(){
		return {
			s:{
				a:1,
				b:2,
				c:3
			},
			l:{
				anoarg: 1,
				bmaybearg: 2,
				cneedarg:3
			}
		}
	}

	setPipe(){
		if (this.args.length) return;
		this.inPipe = true;
		this.pipeIn = (val) => {
			if (this.killed) return;
			//...process val...
			val = this.doThis(val);
			//...and send stuff out
			this.out(val);
			if (isEOF(val)){
				this.ok();
			}
		};
	}

	doThis(val){
	}
	doThat(val){
	}

	run(){
		if (this.inPipe) return;
		let arg1 = this.args.shift();
		//...process arg1... 
		if (badarg){//...maybe barf...
			this.err("Ohhhhh noooooo!!!!");
			this.no();
			return;
		}
		//...or send stuff out
		this.out("Heee hee heee heee!!!");
		this.ok();
	}

}//»
class ScriptCommand extends BaseCommand {//«
	setScriptName(name){
		this.scriptName = name;
	}
	async run(){
		let scr = this.script;
		if (!scr){
			this.err("No script");
			this.no();
			return;
		}
		let pipeIn;
		if (this.next && this.next.pipeIn) pipeIn = this.next.pipeIn;
		let last_code;
		for (let ln of scr){
			let {haveExit, code} = await this.shell.execute(ln, {
				scriptName: this.scriptName,
				scriptArgs: this.args,
				scriptPipeOut: pipeIn,
				env: this.env
			});
			last_code = code;
			if (haveExit) break;
		}
		this.end({code: last_code});
	}
}//»
class BadCommand extends BaseCommand {//«
	run(){
		this.err(this.mess);
		this.no();
	}
}//»
class NullCommand extends BaseCommand {//«
	run(){
		this.no();
	}
}//»
/*»*/

/*«Var*/
const EOF_Type = 1;
const OPERATOR_CHARS=[//«
"|",
"&",
";",
"<",
">",
"(",
")",
];//»
const UNSUPPORTED_OPERATOR_CHARS=["(",")"];
const OPERATOR_TOKS=[//«
'&&',
'||',
';;',
';&',
'>&',
'>>',
'>|',
'<&',
'<<',
'<>',
'<<-',
'<<<',
];//»
const UNSUPPORTED_OPERATOR_TOKS=[/*«*/
	'&',
	'<',
	';;',
	';&',
	'>&',
	'>|',
	'<&',
	'<<',
	'<>',
	'<<-',
	'<<<'
];/*»*/
const OCTAL_CHARS=[ "0","1","2","3","4","5","6","7" ];

const INVSUB="invalid/unsupported substitution";
const START_NAME_CHARS = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "_"];
const DIGIT_CHARS_1_to_9=["1","2","3","4","5","6","7","8","9"];
const ANY_DIGIT_CHARS=["0", "1","2","3","4","5","6","7","8","9"];
const ANY_NAME_CHARS = [...START_NAME_CHARS, ...ANY_DIGIT_CHARS];
const SPECIAL_SYMBOLS=[/*«*/
	"@",
	"*",
	"#",
	"?",
	"-",
	"$",
	"!",
	"0"
];/*»*/
/*»*/
//Util«

const escapes = arr => {//«

let in_single = false;
for (let j = 0; j < arr.length; j++) {
	let tok = arr[j];
	if (tok === "\\") {
		if (!in_single && arr[j+1]) {
			let obj = new String(arr[j+1]);
			obj.escaped = true;
			obj.toString=function(){
				return "\\"+this.valueOf();
			};
			arr[j] = obj;
			arr.splice(j + 1, 1);
		}
	}
	else if(tok==="'") {
		if (in_single) in_single = false;
		else if (j>0 && arr[j-1] !== "$") in_single = true;
	}
}
return arr;

};//»

const ds_single_quote_escapes = tok=>{//«
let wrd = tok.word;
if (!wrd){
cwarn("WHAT THE HELL IS HERE????");
log(tok);
return tok;
}
let arr = wrd;
let out = [];
let in_ds_single = false;

for (let i=0; i < arr.length; i++){
let ch = arr[i];
let next = arr[i+1];
if (!in_ds_single&&ch==="$"&&next==="'"){
	in_ds_single=true;
//	out.push("$'");
	out.push("$","'");
	i++;
}
else if (in_ds_single){
//log("INDSSINGLE");
	if (ch.escaped){
//log("CH.ESCAPED", ch);
	let c;
//switch(ch){/*«*/

//\" yields a <quotation-mark> (double-quote) character, but note that
//<quotation-mark> can be included unescaped.
if  (ch=='"') {c='"';}
//\' yields an <apostrophe> (single-quote) character.
//else if (ch=="'") { c="'";}

//\\ yields a <backslash> character.
else if (ch=='\\') { c='\\';}

//\a yields an <alert> character.
else if (ch=='a') { c='\x07';}

//\b yields a <backspace> character.
else if (ch=='b') { c='\x08';}

//\e yields an <ESC> character.
else if (ch=='e') { c='\x1b';}

//\f yields a <form-feed> character.
else if (ch=='f') { c='\x0c';}

//\n yields a <newline> character.
else if (ch=='n') { c='\n';}

//\r yields a <carriage-return> character.
else if (ch=='r') { c='\x0d';}

//\t yields a <tab> character.
else if (ch=='t') { c='\t';}

//\v yields a <vertical-tab> character.
else if (ch=='v') { c='\x0b';}

else if (ch=='x'){/*«*/
//\xXX yields the byte whose value is the hexadecimal value XX (one or more hexadecimal digits). If more than two hexadecimal digits follow \x, the results are unspecified.
	if (next&&next.match(/[0-9a-fA-F]/)){
	let next2 = arr[i+2];
		if (next2 &&next2.match(/[0-9a-fA-F]/)){
			c = eval( '"\\x' + next + next2 + '"' );
			i+=2;
		}
		else{
			c = eval( '"\\x0' + next + '"' );
			i++;
		}
	}
}/*»*/

//\ddd yields the byte whose value is the octal value ddd (one to three octal digits).
else if(ch=="0"|| ch=="1"|| ch=="2"|| ch=="3"|| ch=="4"|| ch=="5"|| ch=="6"|| ch=="7"){/*«*/
	let s = ch;
//Array.includes tests for strict equality, so escaped chars will not match...
	if (next&&OCTAL_CHARS.includes(next)){
		s+=next;
		let next2 = arr[i+2];
		if (next2&&OCTAL_CHARS.includes(next2)){
			s+=next2;
			i+=2;
		}
		else i++;
		c = eval( '"\\x' + (parseInt(s, 8).toString(16).padStart(2, "0")) + '"' );
	}
}/*»*/

//The behavior of an unescaped <backslash> immediately followed by any other
//character, including <newline>, is unspecified.

//\cX yields the control character listed in the Value column of Values for
//cpio c_mode Field in the OPERANDS section of the stty utility when X is one
//of the characters listed in the ^c column of the same table, except that \c\\
//yields the <FS> control character since the <backslash> character has to be
//escaped.

//}/*»*/
	if (c) out.push(c);
	else out.push(ch);
	}
	else if (ch==="'"){
		in_ds_single = false;
		out.push("'");
	}
	else{
		out.push(ch);
	}
}
else {
//	if (ch.escaped) out.push("\\"+ch);
//	else out.push(ch);
	out.push(ch);
}
}

return {t:"word",word: out};
};//»
const curly_expansion = (arr, from_pos) => {//«
//log("FROM", from_pos);
let ind1 = arr.indexOf("{", from_pos);
let ind2 = arr.lastIndexOf("}");

if (ind1 >= 0 && ind2 > ind1) {//«
//We know these aren't escaped, but they *might* be inside of quotes
let qtyp=null;
let curly_arr;
let start_i;
let final_i;
let have_comma = false;
let have_dot = false;
let have_quote = false;
let have_escape = false;
let comma_arr;
let num_open_curlies = 0;
for (let i=from_pos; i < arr.length; i++){//«

let ch = arr[i];
if (!qtyp){//«
	if (["'",'"','`'].includes(ch)) {
		qtyp = ch;
		have_quote = true;
	}
	else if (ch==="{" && (i===0 || arr[i-1] !== "$")){
		num_open_curlies++;
		if (num_open_curlies === 1 && !curly_arr) {
			start_i = i;
			curly_arr = [];
			continue;
		}
	}
	else if (ch==="}"){
		num_open_curlies--;
		if (num_open_curlies === 0 && curly_arr){
			final_i =  i;
			break;
		}
	}
}//»
else if (qtyp===ch) qtyp=null;

if (curly_arr) {//«
	if (!qtyp){
		if (ch===",") {
			have_comma = true;
			if (num_open_curlies===1){
				if (!comma_arr) comma_arr = [];
				comma_arr.push([...curly_arr]);
				curly_arr = [];
				continue;
			}
		}
		else {
			if (!have_dot) have_dot = ch === ".";
			if (!have_escape) have_escape = ch.escaped;
		}
	}
	curly_arr.push(ch);
}//»

}//»

if (comma_arr){
	comma_arr.push([...curly_arr]);
}

if (!final_i){//«
	if (Number.isFinite(start_i)){
		if (start_i+2 < arr.length){
			return curly_expansion(arr, start_i+1);
		}
		else{
//cwarn("GIVING UP!");
		}
	}
	else{
//log("NOT OPENED");
	}
	return arr;
}//»
else{//«

let pre = arr.slice(0, start_i);
let post = arr.slice(final_i+1);
if (comma_arr){//«
	let words=[];
	for (let comarr of comma_arr){
		words.push(pre.slice().concat(comarr.slice()).concat(post.slice()));
	}
	return words;
}//»
else if (have_dot&&!have_quote&&!have_escape){//«
//The dot pattern is a very strict, very literal pattern
let cstr = curly_arr.join("");
let marr;
let from, to, inc, is_alpha;

let min_wid=0;
if (marr = cstr.match(/^([-+]?\d+)\.\.([-+]?\d+)(\.\.([-+]?\d+))?$/)){//«
//cwarn("NUMS",marr[1], marr[2], marr[4]);

//We're supposed to look for '0' padding on the from/to
	let min_from_wid=0;
	let from_str = marr[1].replace(/^[-+]?/,"");
	if (from_str.match(/^(0+)/)) min_from_wid = from_str.length;

	let min_to_wid=0;
	let to_str = marr[2].replace(/^[-+]?/,"");
	if (to_str.match(/^(0+)/)) min_to_wid = to_str.length;

	if (min_from_wid > min_to_wid) min_wid = min_from_wid;
	else min_wid = min_to_wid;

	from = parseInt(marr[1]);
	to = parseInt(marr[2]);
	inc = marr[4]?parseInt(marr[4]):1;
}
else if (marr = cstr.match(/^([a-z])\.\.([a-z])(\.\.([-+]?\d+))?$/i)){
//cwarn("ALPHA",marr[1], marr[2], marr[4]);
	is_alpha = true;
	from = marr[1].charCodeAt();
	to = marr[2].charCodeAt();
	inc = marr[4]?parseInt(marr[4]):1;
}
else{
	return arr;
}//»

inc = Math.abs(inc);

let vals=[];
let iter=0;
//log(from, to);
if (from > to){
	for (let i=from; i >= to; i-=inc){
	iter++;
	if (iter > 10000) throw new Error("INFINITE LOOP AFTER 10000 iters????");
		if (is_alpha) vals.push(String.fromCharCode(i));
		else vals.push(((i+"").padStart(min_wid, "0")));
	}
}
else {
	for (let i=from; i <= to; i+=inc){
	iter++;
	if (iter > 10000) throw new Error("INFINITE LOOP AFTER 10000 iters????");
		if (is_alpha) vals.push(String.fromCharCode(i));
		else vals.push(((i+"").padStart(min_wid, "0")));
	}
}

let words = [];
for (let val of vals){
	words.push(pre.slice().concat([val]).concat(post.slice()));
}
return words;

}//»
else{
//log("NOTHING");
return arr;
}
}//»

}//»
else{//«
	if (ind1<0 && ind2 < 0) {
//log("NO CURLIES");
	}
	else if (ind1 >= 0 && ind2 >= 0){
//log("BOTH CURLIES DETECTED IN WRONG POSITOIN");
	}
	else if (ind1 >= 0) {
//log("OPEN CURLY ONLY");
	}
	else if (ind2 >= 0){
//log("CLOSE CURLY ONLY");
	}
	return arr;
}//»

}//»
const tilde_expansion = tok => {//«
//log("TILDE", tok);
//Just expand everything after NAME=
//NAME=...
//let pref = tok
let wrdarr = tok.word;
let wrdstr = tok.word.join("");
//cwarn(`CHECK: <${wrdstr}>`);
let marr;
if (marr = wrdstr.match(/^([_a-zA-Z][_a-zA-Z0-9]*=)/)){
//If this is a valid shell variable assignment, expand lone '~' or all '~/' after 
//the first '=' and every ':' with $HOME
let from = marr[1].length;
let start = tok.word.slice(0, from);
let arr = tok.word.slice(from);
//cwarn("EXPAND LONE '~' or initial '~/' and every one after a ':'");
//log(arr);
if (!arr.length) return tok;
if (arr.length===1&&arr[0]==="~"){
	return {t: "word",word: [...start, ...globals.HOME_PATH]};
}
let out=[];
for (let i=0; i < arr.length; i++){/*«*/
	if (i===0&&arr[0]==="~"&&arr[1]=="/"){
		out.push(...globals.HOME_PATH, arr[1]);
		i++;
	}
	else if (arr[i]===":" && arr[i+1]==="~"){
		if (!arr[i+2]){
			out.push(":", ...globals.HOME_PATH);
			return {t: "word",word: [...start,...out]};
		}
		else if (arr[i+2]=="/"){
			out.push(":", ...globals.HOME_PATH,"/");
			i+=2;
		}
		else{
			out.push(arr[i], arr[i+1]);
			i++;
		}
	}
	else {
		out.push(arr[i]);
	}
}/*»*/
return {t: "word",word: [...start,...out]};
}
else if (wrdstr==="~") {
//Expand '~' or the leading '~/'
//cwarn("EXPAND LONE '~'");
//log(tok.word);
tok.word=[...globals.HOME_PATH];
}
else if (wrdstr.match(/^~\x2f/)){
tok.word=[...globals.HOME_PATH, ...wrdarr.slice(1)];
//cwarn("EXPAND initial '~/'");
}
return tok;
};/*»*/
const parameter_expansion = tok => {//«
//We will also need env, script_name, and script_args passed in here
/*«

A "parameter" is a NAME or a SYMBOL, as described below.

We are looking for one of:

$LONGESTNAME, $ONEDIGIT, ${NAME}, ${ONEORMOREDIGITS}, $[@*#?-$!0] or ${[@*#?-$!0]}:
@: positional parameters starting from 1, and something about field splitting
*: Same as above, with something else about field splitting
#: Number of positional parameters (minus the 0th)
?: Most recent exit code
-: Current options flag
$: pid of the shell
!: pid of most recent '&' statement
0: name of shell or shell script

All DIGIT's (other than 0) are the current (1-based) positional parameters

These expands in anything other than single quotes

We can also easily support '${#NAME}', since this just gives the length of the
string of the variable, NAME.

I'm not sure how to handle:
$ DQUOTE='"'
$ echo "$DQUOTE"

Maybe escape all quote substitutions (in double quotes or out), and all redir chars?

»*/
/*

Should we not put everything inside $'...', and then escape ALL
single quotes that are in the replacement value??? Otherwise, there can't be
escaped single quotes inside of pure single quotes: '\'' (doesn't work!)

So, if we do:
PARAM_WITH_SINGLE_QUOTES="...'//..."

echo BLAH${PARAM_WITH_SINGLE_QUOTES}BLAH
=> BLAH$'...\'//...'BLAH

*/
let word = tok.word;
let qtyp;
for (let i=0; i < word.length; i++){

let ch = word[i];
if (!qtyp){
	if (["'",'"','`'].includes(ch)) {
		qtyp = ch;
		continue;
	}
	else{
//Unquoted stuff
	}
}
else if (qtyp===ch) {
	qtyp=null;
	continue;
}
else if (qtyp!=='"') continue;

//We are unquoted or in double quotes

if (ch==="$"){/*«*/

const do_name_sub=(name)=>{//«
cwarn("NAME", name, start_i, end_i);

let env={
choint:"1",
UB:"Far   in   the   harrrr!!!"
};
let diff = end_i - start_i;
let val = env[name]||"";
word.splice(start_i, end_i-start_i+1, ...val);

/*
for (let i=0; i < val.length; i++){
	if (val[i]==="'"){
		let s = new String("'");
		s.escaped = true;
		s.toString=function(){
			return "\\"+this.valueOf();
		};
		val[i]=s;
	}
}
//word.splice(start_i, end_i-start_i+1, "$", "'", ...val,"'");

word.splice(start_i, end_i-start_i+4, "$", "'", ...val,"'");
i = end_i + (name.length - (val.length+3));

*/

i = end_i + (name.length - val.length);

};/*»*/
const do_arg_sub=(num)=>{//«
cwarn("ARG", num, start_i, end_i);
};/*»*/
const do_sym_sub=(sym)=>{//«
cwarn("SYM", sym, start_i, end_i);
};/*»*/
const BADSUB=(arg, next)=>{return `bad substitution: stopped at '\${${arg}${next?next:"<END>"}'`;}

	let next = word[i+1];
	if (!next) continue;
	let start_i = i;
	let end_i;
	if (next==="{") {/*«*/
		i++;
//If no next one or the next one is a "}", barf INVSUB
//If the next one is a special symbol, there must be a "}" immediately following it
//If the next one is a digit, there must be 0 or more digits (maybe "0") followed by the "}"
//Otherwise, the next one must be a START_NAME_CHARS, followed by 0 or more 
//    ANY_NAME_CHARS, with a terminating "}".
		next = word[i+1];
		if (!next) return "bad substitution: '${<END>'";
		else if (next==="}") return "bad substitution: '${}'";

if (SPECIAL_SYMBOLS.includes(next)){/*«*/
	let sym = next;
	i++;
	next = word[i+1];
//	if (next !== "}") return INVSUB;
//	if (next !== "}") return `bad substitution: have '\${${sym}${next?next:"<END>"}'`;
	if (next !== "}") return BADSUB(sym, next);
	end_i = i+1;
	do_sym_sub(sym);
//cwarn("Substitute symbol", sym);
//Substitute symbol, 'sym'
}/*»*/
else if (DIGIT_CHARS_1_to_9.includes(next)){/*«*/
	let numstr=next;
	i++;
	next = word[i+1];
	while(true){
		if (next==="}"){
		//Do a parseInt on numstr, and if in a script, replace with: script_arg[num-1]
//cwarn("Substitute script_arg #", argnum);
//			end_i = i;
			end_i = i+1;
			do_arg_sub(parseInt(numstr)-1);
			break;
		}
		if (!ANY_DIGIT_CHARS.includes(next)){
//			return `bad substitution: have '\${${numstr}${next?next:"<END>"}'`;
			return BADSUB(numstr, next);
//			return INVSUB;
		}
		numstr+=next;
		i++;
		next = word[i+1];
	}
}/*»*/
else if (START_NAME_CHARS.includes(next)){/*«*/

let namestr=next;
i++;
next = word[i+1];
while(true){
	if (next==="}"){
//Replace with the substitution of 'namestr'
//cwarn("Substitute param name", namestr);
//		end_i = i;
		end_i = i+1;
		do_name_sub(namestr);
		break;
	}
	if (!ANY_NAME_CHARS.includes(next)){
//		return `bad substitution: have '\${${namestr}${next?next:"<END>"}'`;
		return BADSUB(namestr, next);
//		return INVSUB;
	}
	namestr+=next;
	i++;
	next = word[i+1];
}

}/*»*/
else return INVSUB;

	}/*»*/
	else{/*«*/
//If the next one is a special symbol (including "0"), we can do the substitution now«
//Else if the next is one of DIGIT_CHARS "1"->"9", we can do the substitution noe
//Else if the next isn't a START_NAME_CHARS, we continue and keep this a 
//  literal '$'
//Else we look at every succeeding char, and do the sub on the first non-ANY_NAME_CHARS.

//		i++;
//		next = word[i+1];»

if (SPECIAL_SYMBOLS.includes(next)){
	end_i = i+1;
	do_sym_sub(next);
}
else if (DIGIT_CHARS_1_to_9.includes(next)){
	end_i = i+1;
	do_arg_sub(parseInt(next)-1);
}
else if (!START_NAME_CHARS.includes(next)){
	continue;
}
else{/*«*/

let namestr=next;
i++;
next = word[i+1];
while(true){
	if (!ANY_NAME_CHARS.includes(next)){
cwarn("Substitute param name", namestr);
end_i=i;
do_name_sub(namestr);
		break;
	}
	namestr+=next;
	i++;
	next = word[i+1];
}

}/*»*/

	}/*»*/

}/*»*/

}

return tok;
};/*»*/

//»

//ErrorHandler«

const ErrorHandler = class {

	constructor() {//«
		this.errors = [];
		this.tolerant = false;
	}//»
	recordError(error) {//«
		this.errors.push(error);
	};//»
	tolerate(error) {//«
		if (this.tolerant) {
			this.recordError(error);
		}
		else {
			throw error;
		}
	};//»
	constructError(msg, column) {//«
		var error = new Error(msg);
		try {
			throw error;
		}
		catch (base) {

			if (Object.create && Object.defineProperty) {
				error = Object.create(base);
				Object.defineProperty(error, 'column', { value: column });
			}
		}
		return error;
	};//»
	createError(index, line, col, description) {//«
		var msg = description + ` (line ${line})`;
		var error = this.constructError(msg, col);
		error.index = index;
		error.lineNumber = line;
		error.description = description;
		return error;
	};//»
	throwError(index, line, col, description) {//«
		throw this.createError(index, line, col, description);
	};//»
	tolerateError(index, line, col, description) {//«
		var error = this.createError(index, line, col, description);
		if (this.tolerant) {
			this.recordError(error);
		}
		else {
			throw error;
		}
	};//»

};//»
//Scanner«

//These 2 functions are "holdover" logic from esprima, which seems too "loose" for 
//typical shell scripting purposes
const isWhiteSpace = (cp) => {//«
	return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
		(cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
};//»
const isLineTerminator = (cp) => {//«
	return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
};//»

const Scanner = class {

constructor(code, handler) {//«
	this.source = code;
	this.errorHandler = handler;
	this.length = code.length;
	this.index = 0;
	this.lineNumber = (code.length > 0) ? 1 : 0;
	this.lineStart = 0;
}//»

eof() {//«
	return this.index >= this.length;
};//»

throwUnexpectedToken(message) {//«
	if (message === void 0) { message = Messages.UnexpectedTokenIllegal; }
	return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
};//»

skipSingleLineComment() {//«
	while (!this.eof()) {
//		let ch = this.source.charCodeAt(this.index);
		let code = this.source[this.index].charCodeAt();
		if (isLineTerminator(code)) {
			return;
		}
		this.index++;
	}
};//»
scanComments() {//«
	while (!this.eof()) {
		let code = this.source[this.index].charCodeAt();
		if (isWhiteSpace(code)) {
			++this.index;
		}
		else if (isLineTerminator(code)) {
			break;
		}
		else if (code===0x23){//'#' in 0th line position or preceeded by a space or tab«
			if (this.index - this.lineStart === 0 || this.source[this.index-1] === " " || this.source[this.index-1] === "\t"){
				this.index++;
				this.skipSingleLineComment();
			}
			else {
				break;
			}
		}//»
		else {
			break;
		}
	}
};//»

scanOperator(){/*«*/

	let src = this.source;
	let start = this.index;
	let str = src[start];
	switch(str){
	case '(':/*«*/
	case ')':
		++this.index;
		break;/*»*/
	case '&':/*«*/
		++this.index;
		if (src[this.index]==="&"){
			this.index++;
			str="&&";
		}
		break;/*»*/
	case '|':/*«*/
		++this.index;
		if (src[this.index]==="|"){
			this.index++;
			str="||";
		}
		break;/*»*/
	case '>'://«
		++this.index;
		if ([">","&","|"].includes(src[this.index])){
			str+=src[this.index];
			++this.index;
		}
		break;/*»*/
	case '<':/*«*/
		++this.index;
	//'<<',
	//'<>',
	//'<<-',
	//'<<<',
		if (src[this.index]===">"){
			str = "<>";
			++this.index;
		}
		else if (src[this.index]==="<"){
			++this.index;
			if (src[this.index]==="<"){
				++this.index;
				str = "<<<";
			}
			else if (src[this.index]==="-"){
				++this.index;
				str = "<<-";
			}
			else{
				str="<<";
			}
		}
		break;/*»*/
	case ';':
		++this.index;
		break;
	}
	if (this.index === start) {
		this.throwUnexpectedToken(`Unexpected token ${str}`);
	}
	if (UNSUPPORTED_OPERATOR_TOKS.includes(str)) this.throwUnexpectedToken(`Unsupported token ${str}`);

	if (str.match(/[<>]/)) return {t:"r_op", r_op:str};
	return {t:"c_op", c_op:str};

}/*»*/
scanQuote(which, prev){/*«*/
	this.index++;
	let start = this.index;
	let src = this.source;
	let iter=0;
	let out = [which];
	let len = this.length;
	let cur = start;
	let is_ds_single = (which == "'") && prev == "$" && !prev.escaped;
	let ch = src[cur];
	while(ch && ch != which || (ch.escaped && ch != "'") || (ch.escaped && is_ds_single)){
		if (ch=="\n") {
			if (ALLOW_NEWLINES_IN_QUOTES) this.lineNumber++;
			else return null;
		}
		cur++;
		if (cur>=len) return null;
		out.push(ch);
		if (which==='"'&&ch==="$"&&src[cur]==="(") return "unsupported substitution pattern: '$('";
		ch = src[cur];
	}
	if (cur>=len) return null;
	this.index = cur;
	return out;
}/*»*/
scanWord(){/*«*/
	let start = this.index;
	let src = this.source;
//	let str='';
	let rv;
	let start_line_number = this.lineNumber;
	let start_line_start = this.lineStart;
	let word = [];
	while (!this.eof()) {
		let ch = src[this.index];
//		if (["'",'"','`'].includes(ch)){
		if (ch==="'"||ch==='"'||ch==='`'){
			if (this.index > 0) rv = this.scanQuote(ch, src[this.index-1]);
			else rv = this.scanQuote(ch);
			if (rv===null) this.throwUnexpectedToken(`Unterminated quote ${ch}`);
			else if (isStr(rv)) this.throwUnexpectedToken(rv);
			word.push(...rv);
		}
		else if (ch==="\\"){//Error condition (either known or unknown)
			let next = src[this.index+1];
			if (!next || next === "\n") this.throwUnexpectedToken("Unsupported line continuation");
//We should not get here because all other "naked" backslashes should either be 
//inside a quote or escaping something.
this.throwUnexpectedToken("Should not get here!?! (found a literal '\\' that never got used to escape the following character)");

		}
//		if (["\n","\r"," ","\t"].includes(ch)) break;
//		if (["\n"," ","\t"].includes(ch)) break;

		if (ch==="\n"||ch===" "||ch==="\t") break;
		if (OPERATOR_CHARS.includes(ch)) {
			if (UNSUPPORTED_OPERATOR_CHARS.includes(ch)) this.throwUnexpectedToken(`Unsupported token: ${ch}`);
			break;
		}
		this.index++;
//		if (ch.escaped) str+="\\"+ch;
//		else str+=ch;
		word.push(ch);
	}

	return {t:"word", word};
}/*»*/
scanNewlines(){/*«*/

	let start = this.index;
	let src = this.source;
	let str="";
	let iter=0;
	let start_line_number = this.lineNumber;
	let start_line_start = this.index;;
	while (src[start+iter]==="\n"){
		str+="\n";
		iter++;
	}
	this.index+=iter;
	this.lineStart = start_line_start+iter;
	this.lineNumber+=iter;
	return {t:"nl", nl:str};

}/*»*/

lex(){/*«*/

if (this.eof()) {//«
	return {
		type: EOF_Type,
		value: '',
		lineNumber: this.lineNumber,
		lineStart: this.lineStart,
		start: this.index,
		end: this.index
	};
}//»

let ch = this.source[this.index];
if (ch==="\n") return this.scanNewlines();
if (OPERATOR_CHARS.includes(ch)) {
	if (UNSUPPORTED_OPERATOR_CHARS.includes(ch)) this.throwUnexpectedToken(`Unsupported token: ${ch}`);
	return this.scanOperator();
}
return this.scanWord();

}/*»*/

};

//»
//Parser«

const Parser = class {

constructor(code, options={}) {//«
	this.errorHandler = new ErrorHandler();
	this.scanner = new Scanner(code, this.errorHandler);
	this.lookahead = {//«
		type: EOF_Type,
		value: '',
		lineNumber: this.scanner.lineNumber,
		lineStart: 0,
		start: 0,
		end: 0
	};//»
	this.hasLineTerminator = false;
	this.tokens = [];
	this.nextToken();
}//»

nextToken() {//«
	let token = this.lookahead;
	this.scanner.scanComments();
	let next = this.scanner.lex();
	this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
	this.lookahead = next;
	return token;
};//»

parse() {//«
	let chars = [];
	while (this.lookahead.type !== EOF_Type) {
		chars.push(this.lookahead);
		this.nextToken();
	}
	return chars;
};//»

};
//»

const parse = command_str => {//«


let escaped = escapes(command_str.split(""));

let parser = new Parser(escaped);
let toks;
try {
toks = parser.parse();
}
catch(e){
cerr(e);
return e.message;
}

//Collect commands with their arguments«
let com = [];
let coms = [];
for (let tok of toks){
	if (tok.c_op){
		if (!com.length) return `unexpected empty command (found: '${tok.c_op}')`;
		coms.push({com});
		com = [];
		coms.push(tok);
	}
	else{
		if (!com.length && tok===" "){}//Do not allow a command to begin with whitespace
//		else com.push(ds_single_quote_escapes(tok));
		else com.push(tok);
	}
}
if (com.length) coms.push({com});
//»
//Collect pipelines with their subsequent logic operators (if any)«
let pipes = [];
let pipe = [];
for (let i=0; i < coms.length; i++){
	let tok = coms[i];
	if (tok.c_op && tok.c_op != "|"){//Anything "higher order" than '|' ('&&', ';', etc) goes here
		if (tok.c_op==="&&"||tok.c_op==="||") {
			if (!coms[i+1]) return "malformed logic list";
			pipes.push({pipe, type: tok.c_op});
		}
		else {
			pipes.push({pipe}, tok);
		}
		pipe = [];
	}
	else if (!tok.c_op){//Commands and redirects
		pipe.push(tok);
	}
	else if (pipe.length && coms[i+1]){//noop: This token "must" be a '|'
	}
	else {
		return "malformed pipeline";
	}

}
if (pipe.length) pipes.push({pipe});
//»
//Collect ';' separated lists of pipelines+logic operators (if any)«
let statements=[];
let statement=[];
for (let tok of pipes){
	let cop = tok.c_op;
	if (cop) {
		if (cop==="&"||cop===";"){
			statements.push({statement, type: cop});
			statement = [];
		}
		else{
			return `unknown control operator: ${cop}`;
		}
	}
	else{
		statement.push(tok);
	}
}
if (statement.length) statements.push({statement});

//»

return statements;

};//»

return function(term){

this.cancelled_time = 0;

this.execute = async(command_str, opts={})=>{

const cancelled=()=>{//«
//Cancel test function
	return started_time < this.cancelled_time;
};//»

let started_time = (new Date).getTime();

//scriptPipeOut: when the command is in a script, at the end of a pipeline, but
//				 the script is itself in a pipeline. This is the next command-in-the-pipeline's 
//				 'pipeIn' function.
//commandSubOut: for command/backquote substitutions. Everything in the output 
//				 stream that would get printed to the terminal gets pushed into this array
const { scriptName, scriptArgs, scriptPipeOut, commandSubOut, env } = opts;

const sherr=mess=>{
	term.response(`sh: ${mess}`, {isErr: true});
	if (!scriptName) term.response_end();
};

let statements = parse(command_str);
if (isStr(statements)) {
	sherr(statements);
	return;
}

for (let state of statements){
let loglist = state.statement;

LOGLIST_LOOP: for (let i=0; i < loglist.length; i++){//«

let pipe = loglist[i];
let pipelist = pipe.pipe;
let pipetype = pipe.type;
let pipeline = [];

for (let j=0; j < pipelist.length ; j++){//«
let err, com, redir;
let arr = pipelist[j].com;

//For each word within a command, the shell processes <backslash>-escape«
//sequences inside dollar-single-quotes (See 2.2.4 Dollar-Single-Quotes)
for (let k=0; k < arr.length; k++){
	let tok = arr[k];
	if (tok.t==="word"){
		arr[k] = ds_single_quote_escapes(tok);
	}
}
//»

//and then performs various word expansions (see 2.6 Word Expansions ). «
/*2.6 Word Expansions«

This section describes the various expansions that are performed on words. Not
all expansions are performed on every word, as explained in the following
sections and elsewhere in this chapter. The expansions that are performed for a
given word shall be performed in the following order:

1) Tilde expansion (see 2.6.1 Tilde Expansion ), parameter expansion (see 2.6.2
Parameter Expansion ), command substitution (see 2.6.3 Command Substitution ),
and arithmetic expansion (see 2.6.4 Arithmetic Expansion ) shall be performed,
beginning to end. See item 5 in 2.3 Token Recognition .

2) Field splitting (see 2.6.5 Field Splitting ) shall be performed on the portions
of the fields generated by step 1.

3) Pathname expansion (see 2.6.6 Pathname Expansion ) shall be performed, unless
set -f is in effect.

4) Quote removal (see 2.6.7 Quote Removal ), if performed, shall always be
performed last.

Tilde expansions, parameter expansions, command substitutions, arithmetic
expansions, and quote removals that occur within a single word shall expand to
a single field, except as described below. The shell shall create multiple
fields or no fields from a single word only as a result of field splitting,
pathname expansion, or the following cases:

1) Parameter expansion of the special parameters '@' and '*', as described in
2.5.2 Special Parameters , can create multiple fields or no fields from a
single word.

2) When the expansion occurs in a context where field splitting will be performed,
a word that contains all of the following somewhere within it, before any
expansions are applied, in the order specified:

	a) an unquoted <left-curly-bracket> ('{') that is not immediately preceded by an
	unquoted <dollar-sign> ('$')

	b) one or more unquoted <comma> (',') characters or a sequence that consists of
	two adjacent <period> ('.') characters surrounded by other characters (which
	can also be <period> characters)

	c) an unquoted <right-curly-bracket> ('}')

may be subject to an additional implementation-defined form of expansion that
can create multiple fields from a single word. This expansion, if supported,
shall be applied before all the other word expansions are applied. The other
expansions shall then be applied to each field that results from this
expansion.

When the expansions in this section are performed other than in the context of
preparing a command for execution, they shall be carried out in the current
shell execution environment.

When expanding words for a command about to be executed, and the word will be
the command name or an argument to the command, the expansions shall be carried
out in the current shell execution environment. (The environment for the
command to be executed is unknown until the command word is known.)

When expanding the words in a command about to be executed that are used with
variable assignments or redirections, it is unspecified whether the expansions
are carried out in the current execution environment or in the environment of
the command about to be executed.

The '$' character is used to introduce parameter expansion, command
substitution, or arithmetic evaluation. If a '$' that is neither within
single-quotes nor escaped by a <backslash> is immediately followed by a
character that is not a <space>, not a <tab>, not a <newline>, and is not one
of the following:

- A numeric character
- The name of one of the special parameters (see 2.5.2 Special Parameters )
- A valid first character of a variable name
- A <left-curly-bracket> ('{')
- A <left-parenthesis>
- A single-quote

the result is unspecified. If a '$' that is neither within single-quotes nor
escaped by a <backslash> is immediately followed by a <space>, <tab>, or a
<newline>, or is not followed by any character, the '$' shall be treated as a
literal character.

»*/
/*«When we find a: 
1) '{' ? "," ? '}' (ignore embedded curlies or give a syntax error)
2) '{' \d .. \d '}'
3) '{' \[a-z] .. \[a-z] '}'
3) '{' \[A-Z] .. \[A-Z] '}'

Skip over quotes to look for unescaped '{' followed by the closest unescaped '}'
Collect everything inside.
If there is a strict '..' pattern, use it
Else if there is an internal unquoted (unescaped) comma, use it
Else, let it pass through

»*/

for (let k=0; k < arr.length; k++){//«

let tok = arr[k];
if (tok.t==="word") {
	let rv = curly_expansion(tok.word, 0);
	if (rv !== tok.word){
		let newtoks = [];
		for (let wrd of rv){
			newtoks.push({t:"word",word: wrd});
		}
		arr.splice(k, 1, ...newtoks);
		k--;//Need to revisit the original position, in case there are more expansions there
	}
}

}//»
for (let k=0; k < arr.length; k++){//«

let tok = arr[k];
if (tok.t==="word") {
	arr[k] = tilde_expansion(tok);
}

}//»
for (let k=0; k < arr.length; k++){//«

let tok = arr[k];
if (tok.t==="word") {
	let rv = parameter_expansion(tok);
	if (isStr(rv)) return sherr(rv);
	arr[k] = rv;
}

}//»


/*»*/

}//»

}//»

}
//log(statements);
if (DEBUG){
jlog(statements);
}
//log(command_str);


term.response_end();

};

};
})();
/*»*/

/*Let's make a command that gets a binary file and replaces one sequence (1+) of bytes«
with another sequence (1+). Let's call it "brep".

While doing this, I just needed to allow for Uint8Array's in the terminal's logic,
such as @KIUREUN. I'm not quite sure if the logic where there is concatenation
going on really works or even makes much "real world" sense. Also, in the places
where I make calls to write_to_redir, I had to check to see if the value was an
Uint8Array (otherwise, it is treated as a bunch of text lines to be joined). Maybe
I should do that checking stuff in the actual write_to_redir function call.

***NOW THIS MAKES SENSE***, WHEN I CONSIDER THE FACT THAT OUT_CB CAN BE CALLED
ARBITRARY NUMBERS OF TIMES (RATHER THAN THE "OLD" WAY OF MAKING THE OUTPUT BE
SIMPLY RETURNED AFTER THE COMMAND FINISHED). SO IF FOR SOME REASON YOU ARE
REPEATEDLY CALLING THE "OUT" CB WITH BINARY DATA, THEN DOING THIS CONCATENATION
MAKES SENSE. PERHAPS WE NEED A "BIN_OUT" METHOD, OR RATHER WE SHOULD (SOMEHOW)
"DECLARE" OUR COMMAND (PIPELINE???) TO BE BINARY, SO THAT SENDING *ANY* TEXTUAL
DATA WILL CAUSE AN ERROR.

»*/
/*11/14/24: I am mainly getting into the concept of the larger/"meta" structure«
of this file, given my interest in restarting shell development over and over and
over and over... . My main interest is to continue refactoring into more and more
understandable (i.e. objective, rather than algorithmic) constructs.
»*/

/*12/11/24 Now we are sitting with an ast in a new ShellProgram class's execute«
method (@KDRTIOP). Maybe we should just take a breather at this point (perhaps just till
the end of the day). It is now 11 am.

Other than doing the compound commands, there is really nothing different we
need to do, expect for stuff like making the word expansion process more
class-based (object-oriented).

I'm seriously thinking about creating an application that receives the ShellProgram
object, and offers all of the debugging/stepping options that you might want in order 
to understand the shell's dynamics.

»*/

/*To keep the integrity of this thing, I want _Parser.end() @SLKIURUJ to«
return(this.tokNum===this.numToks);
... rather than
return(this.tokNum>=this.numToks);

So we need to make sure that this.numToks is always set to: tokens.length.
So, whenever we do stuff like pushNewline, we need to update that variable,
like @LCMJHFUEM.

@DYUTYDHFK: Need to make 'isCommandStart' a property of individual tokens
»*/

/*12/5/24: An example of the weird case of Arrays vs Strings«
1) @WPRLKUT, we are calling make_sh_error_com(comword, `command not found`, com_env),
2) in that function @SPOIRUTM, we use to do:
	com.errorMessage = `sh: ${name}: ${mess}`;
...but at the out_cb (@WLKUIYDP), we do testing for isStr, without checking for
embedded newlines, so now we do:
	com.errorMessage = `sh: ${name}: ${mess}`.split("\n");
...in order to get the correct output in the terminal for the case when comword
has embedded newlines
»*/
/*12/4/24: At this late date, we still needed to add the line @DPORUTIH !!!«
»*/
/*12/2/24: Lexing and Parsing the Shell Command Language«
1) The lexer just spits out these tokens:
 - Words
 - Operators
 - Newline lists

The tricky part is a Word:

A sequence of non-whitespace separated:
 - Chars (plus Escaped Chars)
 - Substitutions ( $(...), $((...)) or ${...} )
 - Strings ( "...", $'...', '...' or `...` )
  ) Strings must be recorded faithfully as an array of Chars or Escaped Chars
  ) "...": 
   > can include embedded Substitutions and `...`
  ) `...`:
   > can include embedded Substitutions and Strings (expect itself)
   > all scans for embedded entities must end when an unescaped '`' is detected

To "be in the top-level" means that you are not inside of a String
 - at the appropriate point, top-level Strings can be turned into sequences of 
   Chars, Substitutions and Strings
 - there can be an 'unflatten' or 'objectify' class method to do this

»*/
/*11/30/24: Heredocs: Instead of passing a string into execute, perhaps we should«
pass in a object with a "scan for eof marker", in order to allow heredocs to be
collected.

We are passing in heredocScanner's in from the terminal's shell.execute call, and
the call in class ScriptCom.

We are not currently doing anything past tilde expansion for the redir words (including
herestrings),
and we are not currently expanding anything in the heredocs. So, the herestrings
themselves only get tilde expanded.
»*/
//11/27/24: We are silently skipping file glob patterns with slashes in them//«
//@EJUTIOPB, so only globs in the current directory will work.
//$ echo */* *
// -> */* [...all files in the current directory]

/*Also, we are using Old_curly_expansion, which does NOT do comma expansions, but
the new curly_expansion @QXDPOLIT DOES do them (but that one uses the newer 
parsing algorithm in the DevShell in /doc/dev/TERMINAL @SOTFKL).
*/

//»
/*11/26/24: No calls to com.out in the 'init' phase please!«
Migrate to the new 'class extends Com{...}' notation or get the error message @VKJEOKJ.
com.init is mainly for doing all the the async stuff that your command needs to work
(like loading modules), and also for checking the sanity of the particular combination
of arguments and options that are given to you. Outputting error messages (or other kinds
of messages like warning or info) is always okay because these always go to the terminal.
So we want to be sure that everyone in the pipeline is totally "ready to rumble" before 
any calls to com.out(...) are made.
»*/
/*11/25/24: New 'Com class{...}' and 'Com_whatever extends Com{...}'«

class Com {
	constructor(args, opts, _){
		this.args=args;
		this.opts=opts;
		for (k in _) {
			this[k]=_[k];
		}
	}
}

const Com_blah = class extends Com {

async init(){
//Parse the options
}
async run(){
}
pipeIn(val){
}

}

»*/

//«DevShell
const DevShell = (()=>{

//«Var

//Maybe quote these (depending on context)
// *  ?  [  ]  ^  -  !  #  ~  =  %  {  ,  }

//»

class Oper{//«
	#chars;
	constructor(){
		this.#chars="";
	}
	add(ch){
		let str = this.#chars + ch;
		if (OPERATOR_TOKS.includes(str)){
			this.#chars = str;
			return true;
		}
		return false;
	}
	get chars(){
		return this.#chars;
	}
	get isRedir(){
		return this.#chars[0]===">"|| this.#chars[0]==="<";
	}

}//»

class Word{//«
	#arr;
	constructor(){
		this.#arr=[];
	}
	add(val){
		this.#arr.push(val);
	}
}//»

//Return an array of Word's and Oper's
//There might be a start_i and a stopping condition (an end quote or paren)

//If 'typ' is undefined, we are in "free space"
//Otherwise, it is one of:
/*
- ' (no escaping)
- $'
- "
- $(
- ` (DO NOT flat scan for the final '`'. Set off a tokenizer with a halt_on_bq flag)
- ${
*/
const tokenize = (arr, start_i, typ) => {//«

let tok = null;//The current token
let out = [];//The array of tokens

for (let i=start_i; i < arr.length; i++) {

let ch=arr[i];
let ch1=arr[i+1];

/*«If the end of input is recognized, the current token (if any) shall be
delimited.
»*/

/*«If the previous character was used as part of an operator and the current
character is not quoted and can be used with the previous characters to form an
operator, it shall be used as part of that (operator) token.
»*/

if (tok instanceof Oper && tok.add(ch)){
	continue;
}

/*«If the previous character was used as part of an operator and the current
character cannot be used with the previous characters to form an operator, the
operator containing the previous character shall be delimited.
»*/

if (tok instanceof Oper){
	out.push(tok);
	tok = null;
}

/*«If the current character is an unquoted <backslash>, single-quote, or
double-quote or is the first character of an unquoted <dollar-sign>
single-quote sequence, it shall affect quoting for subsequent characters up to
the end of the quoted text. The rules for quoting are as described in 2.2
Quoting . During token recognition no substitutions shall be actually
performed, and the result token shall contain exactly the characters that
appear in the input unmodified, including any embedded or enclosing quotes or
substitution operators, between the start and the end of the quoted text. The
token shall not be delimited by the end of the quoted field.
»*/
if (ch==="\\") {
/*

By "escaping", we are just jumping over this character, and the either adding the next one to
the current word or starting a new word.

in free space:
  -Escape if an operator, quote or ds+[ ' ( { START_NAME_CHARS SPECIAL_SYMBOLS DECIMAL_CHARS_1_to_9 ]
  -Otherwise, skip this char
type==='"':
  -Escape if a '"'
*/

}
else if (ch==="'") {
//Scan for next "'" (no escapes)
}
else if (ch ==='"') {
// tokenize(arr, i+1, '"')
//	 - No "$'" will be done
}
else if(ch==="$" && ch1==="'"){
//Flat scan for next "'" (with escapes)

}
/*«If the current character is an unquoted '$' or '`', the shell shall identify
the start of any candidates for parameter expansion ( 2.6.2 Parameter Expansion
), command substitution ( 2.6.3 Command Substitution ), or arithmetic expansion
( 2.6.4 Arithmetic Expansion ) from their introductory unquoted character
sequences: '$' or "${", "$(" or '`', and "$((", respectively. The shell shall
read sufficient input to determine the end of the unit to be expanded (as
explained in the cited sections). While processing the characters, if instances
of expansions or quoting are found nested within the substitution, the shell
shall recursively process them in the manner specified for the construct that
is found. For "$(" and '`' only, if instances of io_here tokens are found
nested within the substitution, they shall be parsed according to the rules of
2.7.4 Here-Document ; if the terminating ')' or '`' of the substitution occurs
before the NEWLINE token marking the start of the here-document, the behavior
is unspecified. The characters found from the beginning of the substitution to
its end, allowing for any recursion necessary to recognize embedded constructs,
shall be included unmodified in the result token, including any embedded or
enclosing substitution operators or quotes. The token shall not be delimited by
the end of the substitution.
»*/
else if (ch==="$" && ch1==="(") {
// tokenize(arr, i+2, '$(')

}
else if (ch==="$" && ch1==="{") {
/*
Scan forward for a valid parameter (or #parameter), and the following possible chars
before doing: tokenize(arr, some_i, "${")

:- := :? :+ - = ? + % %% # ##

*/

}
else if (ch==="$" && START_NAME_CHARS.includes(ch[i+1])) {
//Param sub: scan forward until non-ANY_NAME_CHARS
}
else if (ch==="$" && SPECIAL_SYMBOLS.includes(ch[i+1])) {
//Symbol sub: Just grab this next char
}
else if (ch==="$" && DECIMAL_CHARS_1_to_9.includes(ch[i+1])) {
//Arg sub: Just grab this next char
}
else if (ch==="`") {
//Flat scan forward for the first unescaped "`"
}
/*«If the current character is not quoted and can be used as the first character
of a new operator, the current token (if any) shall be delimited. The current
character shall be used as the beginning of the next (operator) token.
»*/
else if (START_OPERATOR_CHARS.includes(ch)){
	if (tok) {
		out.push(tok);
	}
	tok = new Oper();
	if (!tok.add(ch)){
throw new Error(`Could not start the operator tok with: '${ch}' !?!?!?`);
	}
}
/*«If the current character is an unquoted <blank>, any token containing the
previous character is delimited and the current character shall be discarded.
»*/
else if (ch===" " || ch==="\t"){
	if (tok){
		out.push(tok);
		tok = null;
	}
	continue;
}
/*«If the previous character was part of a word, the current character shall be
appended to that word.
»*/
else if (tok instanceof Word){
	tok.add(ch);
}

/*«If the current character is a '#', it and all subsequent characters up to, but
excluding, the next <newline> shall be discarded as a comment. The <newline>
that ends the line is not considered part of the comment.
»*/
else if (ch==="#"){
//THis *would be* the start of a new word (since that is the default, else condition)
	while (arr[i+1] && arr[i+1]!=="\n") i++;
}

//The current character is used as the start of a new word.
	else{
		tok = new Word();
		tok.add(ch);
	}
}

return out;

};//»

return function(term){

//this.cancelled_time = 0;

this.cancelled = false;

this.execute = async(command_str, opts={})=>{

let started_time = (new Date).getTime();

const { interactive } = opts;

const sherr = mess => {//«
	term.response(`sh: ${mess}`, {isErr: true});
	if (!scriptName) term.response_end();
};//»

let tokens = tokenize(command_str.split(""), 0);
if (isStr(tokens)) {
	sherr(tokens);
	return;
}

if (DEBUG){
jlog(tokens);
}
//log(command_str);

term.response_end();

};

this.cancel=()=>{
	this.cancelled = true;
	let pipe = this.pipeline;
	if (!pipe) return;
	for (let com of pipe) com.cancel();
};

};
})();
/*»*/
//Expansions/Redirections«

//1) Environment variable substitution
//2) File globbing '*', '?' and character ranges [a-zA-Z0-9]
//3) Curly brace expansion:
//
//$ echo file{0..3}.txt
//file0.txt file1.txt file2.txt file3.txt
		rv = await all_expansions(arr, term, {script_name, script_args});
		if (this.cancelled) return;
		if (rv){
			term.response(rv, {isErr: true});
		}
//		let inpipe = pipelist.length;
//BBBBBBBBB
//- Turn quote objects into word objects
//- Single quotes that start with '$' look for internal escapes (currently only newline)
//- Backquotes are executed and replaced with the output
		for (let i=0; i < arr.length; i++){//«
			let tok = arr[i];
			let typ = tok.t;
			let val = tok[typ];
			if (typ==="quote") { 
				let typ = tok.quote_t;
				let ds = tok['$'];
				let outstr='';
				for (let ch of val){
					if (isObj(ch)&&ch.t=="esc"){
						if (ch.esc=="n"&&typ=="'"&&ds) outstr+="\n";
						else outstr+=ch.esc;
					}
					else outstr+=ch;
				}
				val = outstr;
				if (typ=="\x60") {
					let out=[];
//DJUYEKLMI
					await this.execute(val, {subLines: out});
					if (this.cancelled) return;
//jlog(out);
					if (!out.length) out = [""];
					let did_splice = false;
					for (let wrd of out){
						if (!did_splice) {
							arr.splice(i, 1, " ");
							did_splice = true;
						}
						arr.splice(i, 0, {t: "word", word: wrd}, " ");
						i+=2;
					}
				}
				else arr[i]={t:"word", word: val};
			}
		}//»

//All sequences of non-whitespace separated quotes and words are concatenated:
//~$ echo "q 1"A"q 2""q 3"B   "q 4"C"q       5"D"q 6"
//q 1Aq 2q 3B q 4Cq       5Dq 6
		for (let i=0; i < arr.length-1; i++){//«
			let tok0 = arr[i];
			let tok1 = arr[i+1];
			let tok0word = tok0.word||tok0.esc;
			let tok1word = tok1.word||tok1.esc;
			if (tok0word && tok1word){
//				arr[i] = {t: "word", word: `${tok0.word}${tok1.word}`, from_quote: true}
				arr[i] = {t: "word", word: `${tok0word}${tok1word}`};
				arr.splice(i+1, 1);
				i--;
			}
		}//»

//Concatenate all sequences of escaped spaces and words
// ~$ touch this\ is\ cool.txt
		for (let i=0; i < arr.length-1; i++){//«
			let tok0 = arr[i];
			let tok1 = arr[i+1];
			if (tok0.esc === " " || tok1.esc === " "){
				arr[i] = {t: "word", word: `${tok0.word||" "}${tok1.word||" "}`, esc: tok1.esc}
				arr.splice(i+1, 1);
				i--;
			}
		}//»

//- Create redirection objects
//- Objects are converted into strings ({t:"word", word: "blah"} -> "blah")

		for (let i=0; i < arr.length; i++){//«
			let tok = arr[i];
			let typ = tok.t;
			let val = tok[typ];
			if (tok===" "){
				continue;
			}
			if (typ==="r_op"){
				let rop = tok.r_op;
				if (!(rop==">"||rop==">>")) {
					return terr(`sh: unsupported operator: '${tok.r_op}'`);
				}
				let tok2 = arr[i+1];
				if (!tok2) return terr("sh: syntax error near unexpected token `newline'");
				if (tok2.t == "quote") tok2={t: "word", word: tok2.quote.join("")}
				if (tok2==" ") {
					i++;
					tok2 = arr[i+1];
				}
				if (!(tok2 && tok2.t==="word")) return terr(`sh: invalid or missing redirection operand`);
				arr.splice(i+1, 1);
				val = null;
				redir = [tok.r_op, tok2.word];
			}
			if (val) {
				args.push(val);
			}
		}//»

		arr = args;

//Set environment variables (exports to terminal's environment if there is nothing left)
		rv = add_to_env(arr, env, {term});
		if (rv.length) term.response(rv, {isErr: true});
		if (arr[0]==" ") arr.shift();

//»
/*«
const com_help = async(args, opts, _)=>{//«
	let help = globals.shell_help;
	const {err, out}=_;
	if (!help){
		try{
			help = (await import("shell_help")).help_text;
		}catch(e){
			err("Could not load the help module");
			return E_ERR;
		}
		globals.shell_help = help;
	}
	let out = [];
	let nargs = args.length;
	if (!args.length) args = ["help"];
	while (args.length){
		if (out.length) out.push("");
		let which = args.shift();
		if (nargs > 1) out.push(`${which}:`);
		let txt = help[which];
		if (!txt) out.push("not found");
		else out.push(...txt.split("\n"));
	}
	return {out, pretty: true};
};//»
const com_termlines=(args,opts, _)=>{//«
	const {term, stdin, out, err} = _;
	let idstr = args.shift();
	if (!idstr) {
		err("No winid given");
		return E_ERR;
	}
	let id = idstr.ppi();
	if (isNaN(id)) {
		err("Invalid id: want a positive integer");
		return E_ERR;
	}
	let win = document.getElementById(`win_${id}`);
	if (!win) {
		err("No window with that id");
		return E_ERR;
	}
	if (win._winObj.appName!=="Terminal") {
		err("Not a terminal");
		return E_ERR;
	}
	out( win._winObj.app.lines);
	return E_SUC;
};//»
const com_hi = async(args, o)=>{//«
	const {term, opts} = o;
	if (term.ssh_server) return {out: "Ready to serve"};
	return {err: "Not connected"}
};//»
const com_ssh = async(args, o)=>{//«
//let server_response_cb;
const server_response=()=>{
	return new Promise((Y,N)=>{
		ws.server_response_cb = Y;
	});
};
const open_socket = () => {//«
return new Promise((Y,N)=>{
const WS_URL = 'wss://192.168.1.100:4443/';
cwarn(`Using WS_URL: ${WS_URL}`)
s = new WebSocket(WS_URL);
//s = new WebSocket('wss://192.168.0.98:4443/');

s.onclose=()=>{//«
cwarn("Socket closed!");
	if (is_client) {
		delete ws.client;
		delete term.ssh_client;
		delete term.ssh_immediate_mode;
	}
	else {
		delete ws.server;
		delete term.ssh_server;
		delete term.locked;
	}
	term.response("Socket closed");
	term.response_end();
};//»
s.onopen=(e)=>{//«
	if (is_client) {
		ws.client = s;
		term.ssh_client = s;
		if (opts.i) {
			term.ssh_immediate_mode = true;
			s.send("pwd");
		}
	}
	else {
		ws.server = s;
		term.ssh_server = s;
		term.locked = true;
	}
	Y();
};//»
s.onmessage=async(e)=>{//«
	let txt = await e.data.text();
	if (is_server){
		let out = [];
		let o = JSON.parse(txt);
		if (o.com) {
			let out = [];
			let err = [];
//			await term.shell.execute(o.com, {script_out: out});
			await term.shell.execute(o.com, {ssh_out: out, ssh_err: err});
			s.send(JSON.stringify({cwd: term.cur_dir, out: out.join("\n"), err: err.join("\n")}));
		}
		else if (o.tab){
			term.handle_tab(o.pos, o.com_arr);
		}
		else{
cwarn("Found non 'com' in server.onmessage...");
log(o);
		}
	}
	else{

		let o = JSON.parse(txt);
		if (o.cwd) {
			term.ssh_cwd = o.cwd;
			let use_cb;
			if (ws.server_response_cb) use_cb = ws.server_response_cb;
			else use_cb = term.response;
			if (o.err) use_cb(o.err.split("\n"));
			if (o.out) use_cb(o.out.split("\n"));
			if (ws.server_response_cb) delete ws.server_response_cb;
			else term.response_end();
		}
		else if (o.chars){
			let chars = o.chars;
			for (let c of chars) term.handle_letter_press(c);
		}
		else if (o.names){
			term.response_com_names(o.names);
		}
		else{
cwarn("What in client.onmessage...");
log(o);
		}
	
	}
};//»

});
};//»
const {term, opts} = o;

let s;
let is_client = opts.client||opts.c;
let is_server = opts.server||opts.s;
let do_close = opts.x;
let mess;
if (!globals.ws) globals.ws = {};
let ws = globals.ws;
if (!ws) return {err: "Not connected"}
if (!is_client && opts.i){
	if (!ws.client) return {err: "Not a client"}
	term.ssh_immediate_mode = true;
	return {out: "Immediate mode on"};
}
if (do_close) {//«
	if (ws.client) {
		ws.client.close();
		delete ws.client;
		return {out: "Client closed"};
	}
	if (ws.server) {
		ws.server.close();
		delete ws.server;
		return {out: "Server closed"};
	}
	return {err: "Nothing to close!"};
}//»
if (args.length){
	if (ws.client) {
		ws.client.send(args.join(" "));
		return {out: await server_response()};
	}
	return {err: "Nowhere to send to!"};
}
if (!(is_client||is_server)) return {err: "Need -s or -c specified"}
if (is_client) {//«
	if (ws.client) return {err: "Already a client"}
	if (ws.server) return {err: "Cannot connect as a client (already a server)"}
	mess="Client";
}
else {
	if (ws.server) return {err: "Already a server"}
	if (ws.client) return {err: "Cannot connect as a server (already a client)"}
	mess="Server";
}//»
await open_socket();
s.send(mess);
if (is_client) {
	if (opts.i){
		await sleep(100);
		s.send(JSON.stringify({com: "pwd"}));
		await server_response();
	}
	return {out: `The ssh client is up${opts.i?" (immediate mode)":""}`}
}
term.response(["The ssh server is up","(terminal locked)"]);
term.scroll_into_view();
term.refresh({noCursor: true});
await hang();

};//»
const com_meta = async(args, o)=>{//«
	let {term}=o;
	let {cwd} = term;
	let file = args.shift();
	if (!file) return {err: "No file"}
	let node = await file.toNode({cwd});
	if (!node) return {err: `${file}: not found`}
	let s = await node.text;
	if (!s) return {err: "No file text"}
	let rv;
	try {
		rv = eval(`(async()=>{${s}})()`);
	}
	catch(e){
cerr(e);
		return {err: e.message};
	}
	return rv;
};//»
const com_pokerruns = async(args, o)=>{//«
	let poker = globals.poker;
	if (!(poker&&poker.hole_cards)) return;
	let hands = poker.hole_cards;
	let text = JSON.stringify(hands);
	let node = await ("/home/me/.data/poker/all-in_trials.json".toNode());
	if (node){
		let rv = await node.setValue(text);
		if (rv && rv.size){
			return {out: `Saved: ${rv.size}`}
		}
	}
	return {out: text};
}//»
const com_pokerhands = async(args, o)=>{//«
	let poker = globals.poker;
	if (!(poker&&poker.hole_cards)) return;
	let hands = poker.hole_cards;
	let keys = Object.keys(hands);
	let arr = [];
	for (let k of keys){
		let o = {};
		o.hand = k;
		o.val = hands[k];
		arr.push(o);
	}
	let all = [];
	let sorted = arr.sort((_a,_b)=>{
		let a = _a.val;
		let b = _b.val;
		let aper = (a.w+a.t) / (a.w+a.l+a.t);
		let bper = (b.w+b.t) / (b.w+b.l+b.t);
		_a.per = aper;
		_b.per = bper;
		if (aper > bper) return -1;
		if (aper < bper) return 1;
		return 0;
	});
	let len = sorted.length;
	let out = {};
	arr = [];
	sorted.forEach((o, idx)=>{
		let per = ((len-idx)/len).toFixed(3);
		out[o.hand] = {rank: per, per: o.per.toFixed(3)};
		arr.push(`${idx}) ${o.hand} ${o.per.toFixed(3)}`);
	});
//log(arr);
	return {out: JSON.stringify(out)};
};//»
*//*»*/

/*@GYWJNFGHXP: Just started on a "solution" to the issue referenced on the Bug below.«

For now, we are doing replacements for open paren, open square brace and plus sign.
What about period, asterisk and question mark?


We now allow for the tab completion like:

$ cat 'Some (weird) f<TAB>

to become:

$ cat 'Some (weird) filename.txt'

But this also actually works when we are at the beginning:

$ 'Some (weird) f<TAB>

becomes:

$ 'Some (weird) filename.txt'

...this is *really* only supposed to search in the command pathway.

»*/
/*Bug found on Feb. 14, 2023://«

There seems to be an issue with commands that wrap around that have long
arguments (like filenames) with embedded spaces that are escaped. Say
the terminal is only like 40 chars wide:

$ ls /home/me/videos/This\ is\ a\ video\
with\ embedded\ spaces.mp4

There was actually a line break inserted here in the command history, probably
related to doing a tab completion that had to wrap around.

I want to implement tab completions that are inside of quotes (like bash does).
Given a file named "file with spaces.txt", doing:

$ cat 'file w<TAB>

...should complete to:

$ cat 'file with spaces.txt'

There needs to be some basic parsing done to ensure that this does not work,
i.e. there should be an odd number of non-escaped quotes.

$ cat ' 'file w<TAB>

//»*/
//Expansions (Doc)«

//and then performs various word expansions (see 2.6 Word Expansions ). 
/*2.6 Word Expansions

This section describes the various expansions that are performed on words. Not
all expansions are performed on every word, as explained in the following
sections and elsewhere in this chapter. The expansions that are performed for a
given word shall be performed in the following order:

1) Tilde expansion (see 2.6.1 Tilde Expansion ), parameter expansion (see 2.6.2
Parameter Expansion ), command substitution (see 2.6.3 Command Substitution ),
and arithmetic expansion (see 2.6.4 Arithmetic Expansion ) shall be performed,
beginning to end. See item 5 in 2.3 Token Recognition .

2) Field splitting (see 2.6.5 Field Splitting ) shall be performed on the portions
of the fields generated by step 1.

3) Pathname expansion (see 2.6.6 Pathname Expansion ) shall be performed, unless
set -f is in effect.

4) Quote removal (see 2.6.7 Quote Removal ), if performed, shall always be
performed last.

Tilde expansions, parameter expansions, command substitutions, arithmetic
expansions, and quote removals that occur within a single word shall expand to
a single field, except as described below. The shell shall create multiple
fields or no fields from a single word only as a result of field splitting,
pathname expansion, or the following cases:

1) Parameter expansion of the special parameters '@' and '*', as described in
2.5.2 Special Parameters , can create multiple fields or no fields from a
single word.

2) When the expansion occurs in a context where field splitting will be performed,
a word that contains all of the following somewhere within it, before any
expansions are applied, in the order specified:

	a) an unquoted <left-curly-bracket> ('{') that is not immediately preceded by an
	unquoted <dollar-sign> ('$')

	b) one or more unquoted <comma> (',') characters or a sequence that consists of
	two adjacent <period> ('.') characters surrounded by other characters (which
	can also be <period> characters)

	c) an unquoted <right-curly-bracket> ('}')

may be subject to an additional implementation-defined form of expansion that
can create multiple fields from a single word. This expansion, if supported,
shall be applied before all the other word expansions are applied. The other
expansions shall then be applied to each field that results from this
expansion.

When the expansions in this section are performed other than in the context of
preparing a command for execution, they shall be carried out in the current
shell execution environment.

When expanding words for a command about to be executed, and the word will be
the command name or an argument to the command, the expansions shall be carried
out in the current shell execution environment. (The environment for the
command to be executed is unknown until the command word is known.)

When expanding the words in a command about to be executed that are used with
variable assignments or redirections, it is unspecified whether the expansions
are carried out in the current execution environment or in the environment of
the command about to be executed.

The '$' character is used to introduce parameter expansion, command
substitution, or arithmetic evaluation. If a '$' that is neither within
single-quotes nor escaped by a <backslash> is immediately followed by a
character that is not a <space>, not a <tab>, not a <newline>, and is not one
of the following:

- A numeric character
- The name of one of the special parameters (see 2.5.2 Special Parameters )
- A valid first character of a variable name
- A <left-curly-bracket> ('{')
- A <left-parenthesis>
- A single-quote

the result is unspecified. If a '$' that is neither within single-quotes nor
escaped by a <backslash> is immediately followed by a <space>, <tab>, or a
<newline>, or is not followed by any character, the '$' shall be treated as a
literal character.

*/
/*When we find a: 
1) '{' ? "," ? '}' (ignore embedded curlies or give a syntax error)
2) '{' \d .. \d '}'
3) '{' \[a-z] .. \[a-z] '}'
3) '{' \[A-Z] .. \[A-Z] '}'

Skip over quotes to look for unescaped '{' followed by the closest unescaped '}'
Collect everything inside.
If there is a strict '..' pattern, use it
Else if there is an internal unquoted (unescaped) comma, use it
Else, let it pass through

*//*»*/
//Expansions (Doc)«


//For each word within a command, the shell processes <backslash>-escape
//sequences inside dollar-single-quotes (See 2.2.4 Dollar-Single-Quotes)

//and then performs various word expansions (see 2.6 Word Expansions ). 
/*2.6 Word Expansions

This section describes the various expansions that are performed on words. Not
all expansions are performed on every word, as explained in the following
sections and elsewhere in this chapter. The expansions that are performed for a
given word shall be performed in the following order:

1) Tilde expansion (see 2.6.1 Tilde Expansion ), parameter expansion (see 2.6.2
Parameter Expansion ), command substitution (see 2.6.3 Command Substitution ),
and arithmetic expansion (see 2.6.4 Arithmetic Expansion ) shall be performed,
beginning to end. See item 5 in 2.3 Token Recognition .

2) Field splitting (see 2.6.5 Field Splitting ) shall be performed on the portions
of the fields generated by step 1.

3) Pathname expansion (see 2.6.6 Pathname Expansion ) shall be performed, unless
set -f is in effect.

4) Quote removal (see 2.6.7 Quote Removal ), if performed, shall always be
performed last.

Tilde expansions, parameter expansions, command substitutions, arithmetic
expansions, and quote removals that occur within a single word shall expand to
a single field, except as described below. The shell shall create multiple
fields or no fields from a single word only as a result of field splitting,
pathname expansion, or the following cases:

1) Parameter expansion of the special parameters '@' and '*', as described in
2.5.2 Special Parameters , can create multiple fields or no fields from a
single word.

2) When the expansion occurs in a context where field splitting will be performed,
a word that contains all of the following somewhere within it, before any
expansions are applied, in the order specified:

	a) an unquoted <left-curly-bracket> ('{') that is not immediately preceded by an
	unquoted <dollar-sign> ('$')

	b) one or more unquoted <comma> (',') characters or a sequence that consists of
	two adjacent <period> ('.') characters surrounded by other characters (which
	can also be <period> characters)

	c) an unquoted <right-curly-bracket> ('}')

may be subject to an additional implementation-defined form of expansion that
can create multiple fields from a single word. This expansion, if supported,
shall be applied before all the other word expansions are applied. The other
expansions shall then be applied to each field that results from this
expansion.

When the expansions in this section are performed other than in the context of
preparing a command for execution, they shall be carried out in the current
shell execution environment.

When expanding words for a command about to be executed, and the word will be
the command name or an argument to the command, the expansions shall be carried
out in the current shell execution environment. (The environment for the
command to be executed is unknown until the command word is known.)

When expanding the words in a command about to be executed that are used with
variable assignments or redirections, it is unspecified whether the expansions
are carried out in the current execution environment or in the environment of
the command about to be executed.

The '$' character is used to introduce parameter expansion, command
substitution, or arithmetic evaluation. If a '$' that is neither within
single-quotes nor escaped by a <backslash> is immediately followed by a
character that is not a <space>, not a <tab>, not a <newline>, and is not one
of the following:

- A numeric character
- The name of one of the special parameters (see 2.5.2 Special Parameters )
- A valid first character of a variable name
- A <left-curly-bracket> ('{')
- A <left-parenthesis>
- A single-quote

the result is unspecified. If a '$' that is neither within single-quotes nor
escaped by a <backslash> is immediately followed by a <space>, <tab>, or a
<newline>, or is not followed by any character, the '$' shall be treated as a
literal character.

*/
/*When we find a: 
1) '{' ? "," ? '}' (ignore embedded curlies or give a syntax error)
2) '{' \d .. \d '}'
3) '{' \[a-z] .. \[a-z] '}'
3) '{' \[A-Z] .. \[A-Z] '}'

Skip over quotes to look for unescaped '{' followed by the closest unescaped '}'
Collect everything inside.
If there is a strict '..' pattern, use it
Else if there is an internal unquoted (unescaped) comma, use it
Else, let it pass through

*/
//»
parameterExpansion(env, script_name="sh", script_args=[]){//«
//PMJDHSWL
//const parameter_expansion = (tok, env, script_name="sh", script_args=[]) => {
//We will also need env, script_name, and script_args passed in here
//«

//A "parameter" is a NAME or a SYMBOL, as described below.
//
//We are looking for one of:
//
//$LONGESTNAME, $ONEDIGIT, ${NAME}, ${ONEORMOREDIGITS}, $[@*#?-$!0] or ${[@*#?-$!0]}:
//@: positional parameters starting from 1, and something about field splitting
//*: Same as above, with something else about field splitting
//#: Number of positional parameters (minus the 0th)
//?: Most recent exit code
//-: Current options flag
//$: pid of the shell
//!: pid of most recent '&' statement
//0: name of shell or shell script
//
//All DIGIT's (other than 0) are the current (1-based) positional parameters
//
//These expands in anything other than single quotes
//
//We can also easily support '${#NAME}', since this just gives the length of the
//string of the variable, NAME.
//
//I'm not sure how to handle:
//$ DQUOTE='"'
//$ echo "$DQUOTE"
//
//Maybe escape all quote substitutions (in double quotes or out), and all redir chars?

//»
//«

//Should we not put everything inside $'...', and then escape ALL
//single quotes that are in the replacement value??? Otherwise, there can't be
//escaped single quotes inside of pure single quotes: '\'' (doesn't work!)
//
//So, if we do:
//PARAM_WITH_SINGLE_QUOTES="...'//..."
//
//echo BLAH${PARAM_WITH_SINGLE_QUOTES}BLAH
//=> BLAH$'...\'//...'BLAH

//»
const tok = this;
const word = tok.val;
//cwarn("HI", this);
let qtyp;
OUTER_LOOP: for (let i=0; i < word.length; i++){

let ch = word[i];
if (!qtyp){
	if (["'",'"','`'].includes(ch)) {
		qtyp = ch;
		continue;
	}
	else{
//Unquoted stuff
	}
}
else if (qtyp===ch) {
	qtyp=null;
	continue;
}
else if (qtyp!=='"') continue;

//We are unquoted or in double quotes

if (ch==="$"){//«

//LSJFANSF
const do_name_sub=(name)=>{//«
let diff = end_i - start_i;
let val = env[name]||"";
cwarn(name);
log(val);
let arr=[];
for (let ch of val){
	let s = new String(ch);
	s.wasExpanded = true;
	arr.push(s);
}
word.splice(start_i, end_i-start_i+1, ...arr);
//log(word);
i = end_i - diff;

};//»
const do_arg_sub=(num)=>{//«
let diff = end_i - start_i;
let val = script_args[num]||"";
word.splice(start_i, end_i-start_i+1, ...val);
i = end_i - diff;
};//»
const do_sym_sub=(sym)=>{//«
let diff = end_i - start_i;
let val;
//const SPECIAL_SYMBOLS=[ "@","*","#","?","-","$","!","0" ];
switch(sym){
	case "0": val = script_name; break;
	case "#": val = script_args.length+""; break;
	case "*":
	case "@":
		val = script_args.join(" ");
		break;
	case "?": val = ShellMod.var.lastExitCode+""; break;
	default: val = "$"+sym;
}
word.splice(start_i, end_i-start_i+1, ...val);
i = end_i - diff;

};//»
const BADSUB=(arg, next)=>{return `bad/unsupported substitution: stopped at '\${${arg}${next?next:"<END>"}'`;}

	let next = word[i+1];
	if (!next) continue;
	let start_i = i;
	let end_i;
	if (next==="{") {//«
		i++;
//If no next one or the next one is a "}", barf INVSUB
//If the next one is a special symbol, there must be a "}" immediately following it
//If the next one is a digit, there must be 0 or more digits (maybe "0") followed by the "}"
//Otherwise, the next one must be a START_NAME_CHARS, followed by 0 or more 
//    ANY_NAME_CHARS, with a terminating "}".
		next = word[i+1];
		if (!next) return "bad substitution: '${<END>'";
		else if (next==="}") return "bad substitution: '${}'";

		if (SPECIAL_SYMBOLS.includes(next)){//«
			let sym = next;
			i++;
			next = word[i+1];
			if (next !== "}") return BADSUB(sym, next);
			end_i = i+1;
			do_sym_sub(sym);
		}//»
		else if (DIGIT_CHARS_1_to_9.includes(next)){//«
			let numstr=next;
			i++;
			next = word[i+1];
			while(true){
				if (next==="}"){
				//Do a parseInt on numstr, and if in a script, replace with: script_arg[num-1]
		//cwarn("Substitute script_arg #", argnum);
		//			end_i = i;
					end_i = i+1;
					do_arg_sub(parseInt(numstr)-1);
					break;
				}
				if (!ANY_DIGIT_CHARS.includes(next)){
		//			return `bad substitution: have '\${${numstr}${next?next:"<END>"}'`;
					return BADSUB(numstr, next);
				}
				numstr+=next;
				i++;
				next = word[i+1];
			}
		}//»
		else if (START_NAME_CHARS.includes(next)){//«

		let namestr=next;
		i++;
		next = word[i+1];
		while(true){
			if (next==="}"){
				end_i = i+1;
				do_name_sub(namestr);
				continue OUTER_LOOP;
			}
			if (!ANY_NAME_CHARS.includes(next)){
				return BADSUB(namestr, next);
			}
			namestr+=next;
			i++;
			next = word[i+1];
		}

		}//»
		else return INVSUB;

	}//»
	else{//«
//If the next one is a special symbol (including "0"), we can do the substitution now«
//Else if the next is one of DIGIT_CHARS "1"->"9", we can do the substitution noe
//Else if the next isn't a START_NAME_CHARS, we continue and keep this a 
//  literal '$'
//Else we look at every succeeding char, and do the sub on the first non-ANY_NAME_CHARS.

//		i++;
//		next = word[i+1];»

if (SPECIAL_SYMBOLS.includes(next)){
	end_i = i+1;
	do_sym_sub(next);
}
else if (DIGIT_CHARS_1_to_9.includes(next)){
	end_i = i+1;
	do_arg_sub(parseInt(next)-1);
}
else if (!START_NAME_CHARS.includes(next)){
	continue;
}
else{//«

let namestr=next;
i++;
next = word[i+1];
while(true){
	if (!ANY_NAME_CHARS.includes(next)){
		end_i=i;
		do_name_sub(namestr);
		continue OUTER_LOOP;
	}
	namestr+=next;
	i++;
	next = word[i+1];
}

}//»

	}//»

}//»

}

return tok;
}//»
/*1/9/25: Now just sit back and relax and meditate on com_mail @YWPOEKRN. This will be«
the very first actual application of the working system. I want 2 basic screens:
1) Saved messages (a list from the database, newest -> oldest or reverse)
2) New messages (an in-memory list received from querying the IMAP server)

We can only respond messages from the Saved screen because only these have the
actual email text.

We can delete messages (via IMAP) from either screen.

So these are the functions:
1) Compose (Reply is compose with to and subject filled in)
2) Send
3) Delete

We want our own database (like in mods/term/email.js) rather than merely using
FS data nodes because we want to enable arbitrary schemas, without screwing around
with the functionality of the  singular purpose of the FS database (making it
more complex than necessary).

In that email.js database, we made indexes out of 'from' and 'time'. I guess
'from' is an email address. Then we can connect proper names (of people and
organizations) with email addresses in another table (or database).

»*/
/*1/8/25: Shell Command Language 2.3.1 (Alias Substitution): I really have *no idea* «
what they are talking about there (not that I've tried very hard to figure it all out).
»*/
/*1/7/25: «Now that we are working on the "real" test command (aka the '[' command),
we need a way to tell getOptions @OEORMSRU to *not* check for options.

Both 'test' and '[...]' are interfaces into the new 'eval_shell_expr' function.
»*/
/*1/6/25: «Getting environments working

@IFKLJFSN is where we are passing an 'env' argument into addToEnv
for the assignments array. We need to create new envs for comsubs!!!
So it looks like we just need to pass in an 'sdup(cur_env)', for whenever we
are going into deeper levels.

Let's just pass the opts that are given as the second arg to
Shell.devexecute (@SLDPEHDBF) into expandSubs. A big point of this is simply
to efficiently pass these values (especially env, scriptName and scriptArgs) 
into ParamSub.expand @KLSDHSKD.

Now its just a matter of getting the fine arts of field-splitting and variable/parameter
environments working nicely:
1) So that commands like:
~$ FOOD=1234 echo blah blah blah
...do not pollute the environment with this value for 'FOOD' (assuming that 'FOOD' was unset
or had another value).

Also:
~$ (FOOD=abcde)
...should not pollute the environment like above, either.

So now we need to create copied environments for the situations above...

Then we need to have a concept of com_env

»*/
/*1/5/25: « NEED TO GET RID OF Word.parameterExpansion (@PMJDHSWL)??
In CaseCom:
  - @AKDMFLS
  - @DJSLPEKS

@AKDKRKSJ, we have a Word.expandSubs that is only passing the shell
and the term args, but Word.expandSubs @XNDKSLDK has this signature:
async expandSubs(shell, term, env, scriptName, scriptArgs)
...TODO NEED TO FIND ALL THE PLACES THAT Word.expandSubs IS CALLED
AND PUT THOSE ARGS IN THERE!!! $)T


AT THE END OF THE DAY: It seems the only "real" issue is that double
quotes no longer seem to keep their significance when I am doing
assignments followed by echos, eg:

~$ HAR=`ls`
~$ echo "$HAR"

WELL THIS PROBLEM IS MUCH MUCH BETTER THAN ALL OF THE OUTPUT SHOWING UP
AS "[Object object]" !!!!!

Apropos the note below (from yesterday), I am going to create Stdin
and Stdin objects immediately after doing the heredoc stuff in the parser...
@YJDHSLFJS.

Now collecting all redirects (tok.isRedir) is much simpler because we just need
the individual tokens themselves.

Just cleaned up parseSimpleCommand @JEEKSMD.

»*/
/*XXX 1/4/25: We are only calling eatRedirects from parseCompoundCommand, and XXX«
it doesn't know how to handle tok.isHeredoc @XPJSKLAJ. So we are just
going to leave that for an exercise for...
»*/
/*1/3/25:«

Now we need to make sure about output redirections vis-a-vis compound commands,
just like we did the "stdin thing." We did an envPipeInCb, so maybe we need an
envRedirLines, for when there is an out_redir in our compound command....


LPIRHSKF is where we check for this.nextCom with our simple command's out response.
We need to to the same thing for compound commands. We need to put the nextCom's
pipeIn callback into the environment of the commands that we are executing, when
it comes to the compound commands, as well as functions and scripts???

SO IT TURNS OUT THAT THE SHELL DOES DO FILEPATH EXPANSIONS ON PARAMETER SUBSTITUTIONS.
IF THERE IS A REGEX COMPILATION ERROR, THEN IT JUST LETS IT PASS THROUGH.

Now we are using the scanner to create ParamSub's from all valid uses of '$', e.g.:

1) $BLAH
2) $1
3) $#
4) ${...}

@MXDHSOERJ I want to look for the sequence:
'$' + any character that can be substituted
For a parameter that is not enclosed in braces:

If the parameter is a name, the expansion shall use the longest valid name (see
XBD 3.216 Name), whether or not the variable denoted by that name exists.

In the shell command language, a word consisting solely of underscores, digits,
and alphabetics from the portable character set. The first character of a name
is not a digit.

Note:
The Portable Character Set is defined in detail in 6.1 Portable Character Set.

Otherwise, the parameter is a single-character symbol, and behavior is
unspecified if that character is neither a digit nor one of the special
parameters (see 2.5.2 Special Parameters).
@ * # ? - $ ! 0

Need to pass the stdin of ScriptCom into its execute function, and 
need to make sure we are doing the same kind of thing for functions and compound 
commands. I think com_read needs to check for an EOF in order to return E_ERR. 
NO: COM_READ JUST NEEDS TO GET THE STDIN ARRAY.
1) ScriptCom @SKDMRJJS
2) FunctionCom

For parsing, need to allow brace group compound lists to end with '}'...


OKAY: In Shell.makeCommand @MFJKTYUS is where we are doing the conversion from
the array of in_redir tokens, e.g. ["<", "SomeFile.txt"] to the actual lines of
standard input.
BUT WE SHOULD ACUTALLY DO IT IN Shell.executePipeline2 @DNGZXER. 

The only difference etween simple_command and compound_command when it comes to
collecting redirs is that they are already together with compound_command's but
they are intermingled with assignments before the simple command names and with
arguments after the simple command names.


When we are doing expansions, for example parameter subs @LSJFANSF: We need a
way to "mask off" these characters from the rest, so there are no further
substitutions attempted on them.  This goes for all the expansions (tilde, command, etc.)...
@XMJFGRTU, we are constructing the RegExp's for pathname expansions.

HOW ABOUT @EORKTIG, we first have a check for if ch.wasExpanded, and do:

patstr += "\"+ch;

@WIUTYSNFI, need a way to escape our filepath expansion chars, defined @EPRORMSIS

»*/
/*1/1/25: Need to find all the places where we have repeating do_group's«
	- ForCom
»*/
/*12/31/24: Parameter Expansions @PMJDHSWL have a weird new ParamSub (@XMKJDHE) object that«
has an empty expand method. It will be easy to get this working in the case that
there is only a number or a plain word in there...

In all of these places where we need to repeatedly re-use certain
compound_list's, we either need to:
-  Have a dup method for the compound_list, in order to duplicate all of the Word objects
-  save the source text that makes up these objects and then send it back through the parser
   in order to get another one.

The ForCom @SLDLTOD is highlighting our inability to figure out how the environments
are used in the Unix shell. When calling shell.execute, @XKLRSMFLE, we create a new
(shallow) copy of the terminal's environment object. I guess we are only supposed to
do that copying when we are doing the subshell. Also, the assignments before an
*actual* command do not go into the terminal's environment. I guess there needs to
be a separate command env object...



NOW JUST ONE MORE KIND OF COMPOUND_COMMAND (CASE_CLAUSE) TO MAKE THIS A PRETTY
MUCH FEATURE COMPLETE MINIMAL LINUX DISTRO??? 


»*/
/*12/30/24: Just had an issue with EOFs inside of scripts @LPIRHSKF. For some reason, it was«
assumed that EOFs should only go to the next commands in your immediate pipeline,
and not to the scriptOut callback...
»*/
//«Notes

/*2/10/25: BUG: Expanding ComSubs FAILS for this @DOPMNRUK, since the environment «
set up by the for loop has not had a chance to get activated.
  
	$ HAR=`for LET in A B; do echo LET is: $LET; done` && echo $HAR 

THE QUESTION IS: WHY WOULD WE ***EVER*** WANT TO PERFORM SUBSTITTIONS ***BEFORE***
DOING SHELL.EXECUTE, @XMSKSLEO???

SO THEN ALL COMSUBS SHOULD JUST REALLY WANT TO SAVE THE RAW STRINGS.

...

Now that we just used the raw strings (as newly enabled in the Scanner @ZOHJKL
and @XMDJKT, this no longer works (since it lets the escapes pass through):

  $ echo `echo \`ls\`` 

...while these DO work (since there aren't any escapes to worry about):

  $ echo `echo $(ls)` 
  $ echo $(echo $(ls))
  $ echo $(echo `ls`)

Now that the first one works, don't we also need to, @JLXOPKEUJ, do the same thing
with stripping the escapes from in front of the '$' character?


  $ echo `echo \`ls \$DIR\`` 

»*/
/*2/9/25: I want to put a gain-node-like thing directly behind all compound commands that«
are inside of a pipeline in order to filter out all EOF's that are coming from the commands
inside of it, so that the following command only spits out 1 line instead of 4:
  $ for LET in A B C; do echo LET is $LET; done | wc
...and now that I just update the 'wc' command to stop reporting results after the first
EOF is received, it only spits out the result from the first echo command.

I guess all I needed to do was add the EOF filter @NDKSLRJL... just like I had it right
below that in the other envPipeInCb!

»*/
/*2/8/25: Yesterday was a little crazy what with my linuxontheweb gitter chat room starting«
to get active. Before going back there, I would like to get loop continues and breaks
working...»*/
/*2/6/25: Just updated com_cat to check for stdinLns (instead of stdin), in case of«
this kind of this:
  $ cat<<<$NOTHINGHERE

Now I guess I can have a loopNum variable for embedded for/until/while loops, which
can make use of continue [n] and break [n] (especially for interesting cases when n > 1).

When the argument is more than the number of embedded loops, I guess we just
end up using the outermost loop.



»*/
/*2/5/25 Issue with Terminal.readLine, when mixed with certain wonky commands: «

THE PROBLEM IS THAT THE LINE FROM WHICH THE READLINE STARTS (AND THEREFORE
KNOWING THE EXACT LINES THAT CONSTITUTE THE READLINE INPUT) *MIGHT* BECOME
INVALIDATED BY OUTPUT ONTO THE TERMINAL *AFTER* THE READLINE IS INITIATED, AND
*BEFORE* THE READLINE-TERMINATE ENTER IS PRESSED.


Here is an example command:
$ while read LN; do echo Hi from echo1: $LN; done | while read LN; do echo Hi from echo2:
 $LN; done;

In Terminal.readLine, I created a readLineStartLine variable (@WMNYTUE), which
is used by Terminal.handleReadlineEnter in order to figure out the readline
string.  But this was not enough because of the possibility of, e.g. certain
compound commands with pipeline chains (like above) to output their responses
onto the terminal *after* a readline call has been initiated. So in the
terminal's response, I checked for the existence of the readLineStartLine
variable, and then reset it to the response method's internal 'curnum' variable
(@QCKLURYH). Finally, after this is all finished, I get rid of the
readLineStartLine variable (set it to null) at the end of Terminal.handleReadlineEnter.

This appears to be "okay", as long as the user hasn't had time to type anything between
the point that Terminal.readLine is first initiated and when there has been some additional
output on the terminal. To solve *that* problem, all we would need to do is to pop off
the existing readline lines, save them, and put them back on, at the end of the response
function, ideally keeping the cursor's x position the same (so the user would hardly need to 
blink during this entire process).

But is there not *ANOTHER* solution, which would be to await the conclusion of
this particular instance of pipeline propagation? I'm not sure this would be a
"better" solution (if even really "doable") because of the amount of internal
complexity required to make it work.  Besides, there's no necessary reason to
make use of pipelines, i.e:

$ while read LN; do true; done | while read LN; do echo Hi from echo2: $LN; done;

So, all in all, the best solution (assuming it is needed, which there is *probably* a
way to invent a scenario) seems to be that one about doing the popping off,
saving, and putting back on, and then resetting Terminal.readLineStartLine.

LO AND BEHOLD, A SCENARIO HAS BEEN INVENTED:

$ while read LN; do echo Hi from echo1: $LN; done | while read LN; do msleep 5000; echo Hi from echo2: $LN; done;

WE SEEM TO BE MAKING PROGRESS HERE, BUT I'M JUST NOT QUITE SURE WHAT POSSESSED
US TO PUT A Terminal.forceNewline @SZKLIEPO (this "tacks" another line onto
things, but it doesn't seem to mess up the end result too much... in fact, we
can still use the backspace key to get back onto the line that we were previously
on)!?!? I DON'T SEE HOW THIS PURELY INTERNAL OPERATION HAS ANYTHING TO TO WITH
THE WORKINGS OF THE TERMINAL...


»*/
/*2/4/25: Just created class EnvReadLine{...}, in order to give compound commands «
an "environmental variable" to allow them to provide a readline functionality
from a preceding pipe. This overrides the crappy solution from yesterday.
The point yesterday was to implement a pipeIn method for CompoundCom, and  wait for 
the preceding command to finish, by pushing everything into an internal buffer
and the waiting for the EOF, before setting stdin/stdinLns and then invoking 'run'.
The *obvious* issue with this was that it didn't allow for "realtime" streaming,
which is the way that the shell works. So instead of treating this as a stdin redirection,
we are treating it as a readline-type of thing. So in Shell.executePipeline (@XWMNJUO), if
there is a last_com, we create a new EnvReadLine, and then hook up the wiring.

(Need to hook up the output of last_com's 'out' method with this compound_command's
readLine.)

If we are piping into a compound_command, and we want to allow the
compound_command to make use of as an "envReadline" function, which is used
just before performing term.readline. We can actually provide this
"envReadline" no matter what, but commands that are *inside* a pipeline will
simply read from pipeIn. What about putting readline directly in the command?

Now @XCJEKRNK, we have a com.readLine method. If there is an 'envReadLine' in our
opts, then will will use that. We will only get here if we are the first in our
immediate pipeline, and we are embedded in a compound command that is *inside* of
a pipeline..


!!! VERY WEIRD BEHAVIOR !!!


$ brum() { while read L; do echo FUNT: $L; done | while read L; do echo GUNT: $L; done; }
$ echodelay -d 0 hi ho he | brum

> GUNT: FUNT: hi
> GUNT: he
> GUNT: FUNT: he

This only seems to happen with the combination of setting the delay to '0' *AND* using
the same variable for both calls to read!?!?!?

THIS ALSO DOESN'T WORK WITH MULTILINE ECHO:

$ echo $'1111\n2222\n3333\n44444' | brum

HOWEVER, AS LONG AS WE USE DIFFERENT VARIABLES, THEN IT ALL SEEMS TO WORK!!!!!

»*/
/*2/3/25: Piping into compound commands (is there not a mechanism for this?): «

  cat BLAH.txt | while read LINE; do echo "HERE IS LINE: $LINE"; done

Whereas there is a mechanism for:
  while read LINE; do echo "HERE IS LINE: $LINE"; done <BLAH.txt

*** THIS IS NOT TRUE ANYMORE (SEE ABOVE) ***
OKAY: I just created a pipeIn method on the CompoundCom class (which all
compound commands inherit from), and I changed init to _init, and turned the
default init method to simply calling _init (so everybody with their own init
methods must first call _init). At the end of _init, we are checking for
prevCom and no stdin (@CWOPLIU). In that case, we are setting this.#buffer to
[] (otherwise it is undefined). Now, when the system calls the run methods
"normally" (@CWJKOI), we are promptly returning from *THAT* invocation -- if we
have a defined buffer -- because we added a runOk method (@EJKFKJ), which the
run methods *must* call first before proceeding.  Once the pipeIn method
receives an EOF (from the preceeding command in the pipeline), then it calls
this.run(true), which causes runOk to return true, and allows us to continue on
with the run method.

@FSHSKEOK is where we are constructing the pipelines. The "previous" command gets
a nextCom property and pipeTo = true; The "next" command gets pipeFrom = true, and
it is its responsibility to create a pipeIn on its command object.

»*/
/*1/29/25: On my way towards enabling 'cat | less' (not that anyone *really* needs it to work)...«
Just need to do refactoring of the key handlers, to make everything less Byzantine, and
get some clarity about what is *really* going on there.

Just created two "getter" methods (@MSFUNPEJ) in order to get the terminal's (the REPL's) 
own lines and line_colors arrays (as "getters", they are invoked without call parens).

I am able to get the basic 'cat | less' functionality working now, such that
Ctrl+c stops the eternal readLine mechanism from cat, but then pressing "q"
(which at this point gets feed into less's onkeypress handler) does *NOT* set 
the screen back to the terminal's REPL. Instead, we have to do *ANOTHER* Ctrl+c 
in order to get back to our terminal screen...

So, it looks like the trick to 'cat | less' was to send an EOF into readLineCb (@RMLDURHTJ),
which gets returned into the 'cat' command, and allows it to terminate its
otherwise interminable loop:
	while (true){
		let ln = await this.term.readLine();
		if (isEOF(ln)){
			this.ok();
			return;
		}
		this.out(ln);
	}

...this means that awaiting the cat command gets finished in executePipeline,
allowing us to get to @XJPMNYSHK, and allowing us to "normally" complete the
executePipeline function (and the rest of the functions that get called by
Shell.execute @SLDPEHDBF).

I figure this is a fairly crucial thing to get "right" because it speaks to
so many little things at the heart of the interactive shell mechanism.

!!! Invalid paragraph below !!!

But, I had to do a bunch of tortuous stuff related to printing onto the
terminal's own REPL screen even when another screen (e.g. less's screen) was
active.  For example, you can see in Terminal.handleLetterPress (@ZKLDUTHSK)
that I am now this.termLines and this.termThis, in order to print the incoming
characters onto the backgrounded terminal lines, so they don't get printed onto
the current screen lines. But really, the "real" version of 'cat | less' does
*NOT* do this at all.

UPDATE: I JUST GOT IT WORKING LIKE THE "real" 'cat | less' by creating a
Term.#readLineStr property when initiating the readLineCb (@XKLRYTJTK),
which is "concatenated to" (@VEOMRUI), and then "sent along" @HWURJIJE.
SO THIS GETS OF THE NEED TO HAVE ANY OF THE "TORTUOUS LOGIC" MENTIONED
IN THE ABOVE PARAGRAPH. SO I JUST GOT RID OF IT (except for in the respone 
mechanism)!!!




Also, I got rid of the terminal's own ondevreload mechanism, although it still
works in vim with the '-r' flag, so that:
  $ vim  CoolStuff.js -r

...allows you to use Ctrl+Alt+r (to invoke vim's toggle_reload_win in order to create a
"reload window"), and we can then use "Alt+r" in order to go through the vim interface
in order to reload it. Since that window is "owned" by the terminal window, we
can't really do anything with it from the system level (including closing it via the
"X" box on the upper right).

»*/
/*1/28/25: In com_read, there was, at first, an *error* because the command expected«
'stdin' to be an array (it wanted to do stdin.shift()), but it was really a string, 
due to recent changes. Then we *did* make it an array by splitting the 'stdin' string 
on newlines in com_read @XDUITOYL, but this made the command:

~$ { while read line; do echo HERE IS A LINE: $line; done; } < SOMEFILE.txt

...do an infinite loop, since we kept on splitting the same constant string for
every time the read command was invoked in the while loop. Then I tried to hunt
down the proper place to create a stdinLns arg (i.e. an array, which is what 
'stdin' previously was), which turned out to be in the area of @VOPDUKKD (in
shell.executePipeline). Then the stdinLns arg finally gets passed into the
appropriate command in shell.makeCommand. This is all still pretty complicated,
and there should probably be some more refactoring (plus lots of testing).


We started work today in com_grep trying to get the highlighting of the match working.
So we created a method 'fmtColLn' (of the Com class, @XVEOIP), which is meant to format 
(wrap to the terminal width) and color the output line, in the case that the output
goes to the terminal rather than anywhere else (like a pipe or redirLines array).

»*/
/*1/26/26: MAJOR TERMINAL WEIRDNESS/BUGGINESS IN COMS/MAIL.JS (@SKPLMJFY). «
WHEN WE GET ERROR MESSAGES BACK FROM THE SERVER.
The issue is that this is how we were handling errors in the server:

const no = (res, arg) => {
    res.writeHead(404, {'Content-Type': "text/plain"});
    if (arg.match(/error/i)) res.end(`${arg}\n`);
    else if (arg) res.end(`Error: ${arg}\n`);
    else res.end("Error\n");
};

And so now I just got rid of the ending newlines:

const no = (res, arg) => {
    res.writeHead(404, {'Content-Type': "text/plain"});
    if (arg.match(/error/i)) res.end(`${arg}`);
    else if (arg) res.end(`Error: ${arg}`);
    else res.end("Error");
};

The only reason I can imagine wanted to put a newline there at the end
is that the response would *actually* end unless there was one there.
If I put them there (a loooong time ago in a galaxy far far away) for
some trivial kind of reason related to client-side formatting, then that
was pretty stupid.

Regardless, the terminal's render mechanism gets all weird when there is a line
color object that looks like: {0: [0, "#f99"]} ...which means that we are
starting the coloring (#f99 in this case) at the beginning of the line. But
instead of the coloring spanning some number (1 or more) characters, this
tells the renderer to span 0 characters, which leads to...

THe weird result that this entire process ends up creating a coloring span
that spans as many lines as there are on the screen (but naturally goes away
when the beginning line scrolls behind the "top" of the terminal screen), so
that all of the lines will inherit this same coloring scheme.

Now there are 3 different mechanisms in place to stop this off-putting
result from happening. 

1) As mentioned above, the server is no longer responding with ending newlines.

2) The terminal's response method does this test on the string:

	else if (out.match(/\n$/)){
cwarn("Chomping ending NEWLINE!!!");
		out = out.replace(/\n$/,"");
	}

3) The terminal's render method checks that the color object's "how many 
characters to span" number is at no less than 1:

if (obj[0] < 1){
cwarn("GOT INVALID colobj", obj);
continue;
}

»*/
/*1/22/25 BUG @ZOPIRUTKS: The 'fname' argument to normPath was a Word object, «
so this failed with Error: "path.match is not a function".  This error was caught 
by the try/catch @LSPOEIRK, and was only printed in red on the terminal (rather than 
having the full error stack sent to the JS console). So I just changed it back to 
logging to the JS console via cerr(...).

And just above that, we had to change
the line: 
  const {op}=tok;//WRONG!!!
to:
  const {val: op}=tok;

I JUST CAN'T BELIEVE THAT WE HADN'T TESTED REDIRECTS ***AT ALL*** SINCE WE "FINISHED" THE
SHELL UP A COUPLE WEEKS AGO!?!?!
»*/
/*1/19/25:« This doesn't work: $ cat | less

...because less is the "actor" in the terminal (@CLKIRYUT), which eats up all key strokes,
before the readLine mechanism can take effect @LOUORPR.

An "actor" is whatever grabs the screen. We should distinguish between different kinds
of actors:
  editors: greedily grab every key event there is (editors want maximum control)
  pagers: grab only key downs (command keys) unless there is an active "input line"
    at the bottom of the screen to handle textual "command lines" (like searching 
	for a string).

Because 'grep' is *not* an "actor", the following command works:
  $ cat | grep blah

In the "real Linux" version of less, the command input mechanism doesn't seem
to work ('cat' appears to eat up all the keystrokes).

So we would need to check for #readLineCb before sending into the actor, which
should eat up all...

»*/
/*1/18/25: Just made a 'bgdiv' under the 'tabdiv', which internally consists of«
'nRows' worth of divs (@SJRMSJR), to be used for such things as multiline selection 
toggling within a pager. We now have a 'bgRowStyles' array property on the terminal 
object, so that the render loop can quickly set (or unset) the backgroundColor properties.

Now we have "multiline toggling" (via multilineSels) plus exitChars -> exitChar
functionality in less, and the saveFunc functionality in vim, in order to allow
for more application-controllable workflows with these modules.

»*/

//»
