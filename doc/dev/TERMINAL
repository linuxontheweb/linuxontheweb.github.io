Bash ABNF grammar:/*«*/

<ALPHA> ::= a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|
             A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z

<DIGIT> ::= 0|1|2|3|4|5|6|7|8|9

<NUMBER> ::= <DIGIT>
           | <NUMBER> <DIGIT>

<WORD> ::= <ALPHA>
         | <WORD> <ALPHA>
         | <WORD> '_'

<WORD-LIST> ::= <WORD>
             |  <WORD-LIST> <WORD>

<ASSIGNMENT-WORD> ::= <WORD> '=' <WORD>


<REDIRECTION> ::=  '>' <WORD>
                |  '<' <WORD>
                |  <NUMBER> '>' <WORD>
                |  <NUMBER> '<' <WORD>
                |  '>>' <WORD>
                |  <NUMBER> '>>' <WORD>
                |  '<<' <WORD>
                |  <NUMBER> '<<' <WORD>
                |  '<&' <NUMBER>
                |  <NUMBER> '<&' <NUMBER>
                |  '>&' <NUMBER>
                |  <NUMBER> '>&' <NUMBER>
                |  '<&' <WORD>
                |  <NUMBER> '<&' <WORD>
                |  '>&' <WORD>
                |  <NUMBER> '>&' <WORD>
                |  '<<-' <WORD>
                |  <NUMBER> '<<-' <WORD>
                |  '>&' '-'
                |  <NUMBER> '>&' '-'
                |  '<&' '-'
                |  <NUMBER> '<&' '-'
                |  '&>' <WORD>
                |  <NUMBER> '<>' <WORD>
                |  '<>' <WORD>
                |  '>|' <WORD>
                |  <NUMBER> '>|' <WORD>

<SIMPLE-COMMAND-ELEMENT> ::= <WORD>
                          |  <ASSIGNMENT-WORD>
                          |  <REDIRECTION>

<REDIRECTION-LIST> ::= <REDIRECTION>
                    |  <REDIRECTION-LIST> <REDIRECTION>

<SIMPLE-COMMAND> ::=  <SIMPLE-COMMAND-ELEMENT>
                   |  <SIMPLE-COMMAND> <SIMPLE-COMMAND-ELEMENT>

<COMMAND> ::=  <SIMPLE-COMMAND>
            |  <SHELL-COMMAND>
            |  <SHELL-COMMAND> <REDIRECTION-LIST>

<SHELL-COMMAND> ::=  <FOR-COMMAND>
                  |  <CASE-COMMAND>
                  |  while <COMPOUND-LIST> do <COMPOUND-LIST> done
                  |  until <COMPOUND-LIST> do <COMPOUND-LIST> done
                  |  <SELECT-COMMAND>
                  |  <IF-COMMAND>
                  |  <SUBSHELL>
                  |  <GROUP-COMMAND>
                  |  <FUNCTION-DEF>

<FOR-COMMAND> ::=  for <WORD> <NEWLINE-LIST> do <COMPOUND-LIST> done
            |  for <WORD> <NEWLINE-LIST> '{' <COMPOUND-LIST> '}'
            |  for <WORD> ';' <NEWLINE-LIST> do <COMPOUND-LIST> done
            |  for <WORD> ';' <NEWLINE-LIST> '{' <COMPOUND-LIST> '}'
            |  for <WORD> <NEWLINE-LIST> in <WORD-LIST> <LIST-TERMINATOR>
                   <NEWLINE-LIST> do <COMPOUND-LIST> done
            |  for <WORD> <NEWLINE-LIST> in <WORD-LIST> <LIST-TERMINATOR>
                   <NEWLINE-LIST> '{' <COMPOUND-LIST> '}'

<SELECT-COMMAND> ::=  select <WORD> <NEWLINE-LIST> do <LIST> done
                   |  select <WORD> <NEWLINE-LIST> '{' <LIST> '}'
                   |  select <WORD> ';' <NEWLINE-LIST> do <LIST> done
                   |  select <WORD> ';' <NEWLINE-LIST> '{' LIST '}'
                   |  select <WORD> <NEWLINE-LIST> in <WORD-LIST>
                           <LIST-TERMINATOR> <NEWLINE-LIST> do <LIST> done
                   |  select <WORD> <NEWLINE-LIST> in <WORD-LIST>
                           <LIST-TERMINATOR> <NEWLINE-LIST> '{' <LIST> '}'

<CASE-COMMAND> ::=  case <WORD> <NEWLINE-LIST> in <NEWLINE-LIST> esac
                 |  case <WORD> <NEWLINE-LIST> in <CASE-CLAUSE-SEQUENCE>
                         <NEWLINE-LIST> esac
                 |  case <WORD> <NEWLINE-LIST> in <CASE-CLAUSE> esac

<FUNCTION-DEF> ::=  <WORD> '(' ')' <NEWLINE-LIST> <GROUP-COMMAND>
                 |  function <WORD> '(' ')' <NEWLINE-LIST> <GROUP-COMMAND>
                 |  function <WORD> <NEWLINE-LIST> <GROUP-COMMAND>

<SUBSHELL> ::=  '(' <COMPOUND-LIST> ')'

<IF-COMMAND> ::= if <COMPOUND-LIST> then <COMPOUND-LIST> fi
          | if <COMPOUND-LIST> then <COMPOUND-LIST> else <COMPOUND-LIST> fi
          | if <COMPOUND-LIST> then <COMPOUND-LIST> <ELIF-CLAUSE> fi

<GROUP-COMMAND> ::=  '{' <LIST> '}'

<ELIF-CLAUSE> ::= elif <COMPOUND-LIST> then <COMPOUND-LIST>
           | elif <COMPOUND-LIST> then <COMPOUND-LIST> else <COMPOUND-LIST>
           | elif <COMPOUND-LIST> then <COMPOUND-LIST> <ELIF-CLAUSE>

<CASE-CLAUSE> ::=  <PATTERN-LIST>
                |  <CASE-CLAUSE-SEQUENCE> <PATTERN-LIST>

<PATTERN-LIST> ::=  <NEWLINE-LIST> <PATTERN> ')' <COMPOUND-LIST>
                 |  <NEWLINE-LIST> <PATTERN> ')' <NEWLINE-LIST>
                 |  <NEWLINE-LIST> '(' <PATTERN> ')' <COMPOUND-LIST>
                 |  <NEWLINE-LIST> '(' <PATTERN> ')' <NEWLINE-LIST>

<CASE-CLAUSE-SEQUENCE> ::=  <PATTERN-LIST> ';;'
                         |  <CASE-CLAUSE-SEQUENCE> <PATTERN-LIST> ';;'

<PATTERN> ::=  <WORD>
            |  <PATTERN> '|' <WORD>


<LIST> ::=   <NEWLINE-LIST> <LIST0>

<COMPOUND-LIST> ::=  <LIST>
                  |  <NEWLINE-LIST> <LIST1>

<LIST0> ::=   <LIST1> '\n' <NEWLINE-LIST>
           |  <LIST1> '&' <NEWLINE-LIST>
           |  <LIST1> ';' <NEWLINE-LIST>

<LIST1> ::=   <LIST1> '&&' <NEWLINE-LIST> <LIST1>
           |  <LIST1> '||' <NEWLINE-LIST> <LIST1>
           |  <LIST1> '&' <NEWLINE-LIST> <LIST1>
           |  <LIST1> ';' <NEWLINE-LIST> <LIST1>
           |  <LIST1> '\n' <NEWLINE-LIST> <LIST1>
           |  <PIPELINE-COMMAND>

<LIST-TERMINATOR> ::= '\n'
                   |  ';'

<NEWLINE-LIST> ::=
                  |  <NEWLINE-LIST> '\n'

<SIMPLE-LIST> ::=  <SIMPLE-LIST1>
                |  <SIMPLE-LIST1> '&'
                |  <SIMPLE-LIST1> ';'

<SIMPLE-LIST1> ::=  <SIMPLE-LIST1> '&&' <NEWLINE-LIST> <SIMPLE-LIST1>
                 |  <SIMPLE-LIST1> '||' <NEWLINE-LIST> <SIMPLE-LIST1>
                 |  <SIMPLE-LIST1> '&' <SIMPLE-LIST1>
                 |  <SIMPLE-LIST1> ';' <SIMPLE-LIST1>
                 |  <PIPELINE-COMMAND>

<PIPELINE-COMMAND> ::= <PIPELINE>
                    |  '!' <PIPELINE>
                    |  <TIMESPEC> <PIPELINE>
                    |  <TIMESPEC> '!' <PIPELINE>
                    |  '!' <TIMESPEC> <PIPELINE>

<PIPELINE> ::=
          <PIPELINE> '|' <NEWLINE-LIST> <PIPELINE>
       |  <COMMAND>

<TIME-OPT> ::= '-p'

<TIMESPEC> ::=  time
             |  time <TIME-OPT>

.XE "BNF (Backus-Naur Form)"
.XE "bash" "syntax, BNF form of"
/*»*/

/*10/14/24: Color output/*«

Properly colorizing terminal output is OFFICIALLY a vexation.  To get the 'ls'
command to properly colorize its output (@WKIUTYUIP), I am using an add_rows
variable that is tracked by shell.execute starting @MJUEYSKDH.  Also,
shell.execute is called with an addRows option (@DJUYEKLMI), which is only for
backquote execution. I'm not quite sure anymore what is going on here, and it
all seems quite hackish. Perhaps we should just get rid of all add_rows/addRows
things, and let everything just get colored wonkishly in case of...(backquote
execution)???.  Also, addPrompts was inserted in lib mail.js because of using
term.getch in coms/mail.js, which gets sent to Term.response (@LKMDNHYTRG).  I
started adding color yesterday to the 'err' response, and to the new 'ok'
response. It's all starting to bite me on the a** once again.

»*/
/*10/13/24: Updated command calling conventions and created 'stdok' responses«

Updated the command calling convention (@SKIOPRHJT) from:
	com(args, {opts, term, stdin, etc...})
to:
	com(args, opts, {term, stdin, etc...})

The callee is expected to use this notation:

const mycommand = async(args, opts, _)=>{
	const {term, stdin} = _;
};

Now how about having a 'stdok' stream, rather than using 'stdout' for "good" reponses?
Then, we can different colors for stdok (green) and stderr (red) on the terminal.
stdout is the only response that might get redirected into a file. These others are
simply informational for the interactive user, and do not make sense as true "output".

»*/
/*10/11/24: Just getting back into the whole command module loading/reloading thing.«
Up to now, it has been quite a complex thing juggling different variables like
ALL_LIBS, globals.shell_libs, NS.libs, and NS.coms.

Now, ALL_LIBS is the NS.libs object. This is an object like:
NS.libs={
	lib1: [com11, com12,...],
	lib2: [com21, com22, ...]
}

...where these are lists of command names (string). These commands will *not* be imported
in case they are already defined within the active shell commands.

Upon successfully importing a command library, each library's exported command functions
and options (both are objects) are put onto NS.coms, like:
NS.coms={
	lib1: {coms: lib1funcs, opts: lib1opts}
}

ADD_COMS is an array that includes all command libraries to be imported upon terminal
initialization.

DEL_COMS is used by developers to remove all of the commands from the active
commands (but not if a particular command WASN'T ACTUALLY IMPORTED by the
library, e.g. see @CJIUKLEH). Their command options are likewise removed from
the active command options.



In terms of status updates, how about just NOT putting the terminal in fullscreen,
and using the bottom status bar???


Now... back to email (see me in mail.js...)!!!

»*/
/*10/10/24: Want a hotkey that toggles the ondevreload method, rather than using the«
hardcoded variable (USE_ONDEVRELOAD). Done @VMUIRPOIUYT.

Want a dedicated 1-line status bar at the bottom of the screen in "normal" CLI mode
to allow a place for status messages of long(-ish) term commands processes, that might,
i.e. be downloading a large file or connecting to some service. This is good for commands
(like ffmpeg) that are frequently updating their progress. In standard Linux systems,
the stderr stream is normally used for this kind of updating, but these are not actually
*errors*, so it doesn't really make any sense to do this.


»*/
/*10/9/24: Updated the entire command importing machinery, and added a ondevreload method«
(depending on the truth of the global USE_ONDEVRELOAD variable), which, if it
exists, is called by the desktop's win_reload method (instead of reloading the
actual application window). Using the ALL_LIBS method allows the shell to
"know" that it must do an implicit import of a given command library
(@QKIUTOPLK), because all of the commands are initialized as the (string) names
of the library (@MYKLJDHFK) rather than with the function bodies (they are
initialized as "true builtins" @FWPORUITJ).
»*/
/*10/5/24: Setting environment variables«

Normally this is done through .bashrc files, using export. But I don't want to mess with
the complexity of machine-reading text files. Right now, the ENV variable is set here, which
forces us to manually set all environment vars on the command line. I want ENV
to be a global variable (which I just added into config.js as globals.TERM_ENV).

Now to set persistent vars to ENV, just save them to ~/.env, e.g.:
VAR1=Something
BLAH=What in the hell

»*/

//Notes (Old)«

/*Making data files (Sept/Oct 2024)«
const com_mkdat = async(args, o)=>{
	const {term, opts, stdin} = o;
	let f = args.shift();
	if (!f) return;
	let arr = await f.toParNodeAndName(term);
	if (!arr) return {err: `Not found: ${f}`};
	let par = arr[0];
	let name = arr[1];
	let fullpath = arr[2];
	let kid = await fullpath.toNode();
//Updating
	if (kid) {
if (!kid.data) return {err: "Not a data node!"}
if (!await kid.setValue({type: "harko99998", FROYNKMISCH: 4321.8765})) return {err: "Could not set value"};
log(kid);
log(kid.data);
return;
	}
//Creating data node
	kid = await fsapi.writeDataFile(fullpath, {value: 1, type: "number"});
};
»*/
/*Notes (September 2024)«
9/6/2024:
Made a global variable, "appclass".

Got rid of all things dealing with "ssh" (which is just a stupid amount of complexity
for the real world benefit that is received).

9/5/2024:

@XOPIUYTK
Looking at the editor/pager specific functions like init_edit_mode and init_pager_mode,
as well as modequit, in order to see how this can be improved and generalized to allow
for more novel applications. Want a generic workflow for entering and leaving different
application screens. The newly invoked application needs to get a handle on the 
terminal's current lines array. Then, upon quitting, it needs to give this back to
the terminal. We need the ability to do abitrarily deep recursions of applications
calling applications as submodes, calling applications as submodes...

Now after revamping everything:
It looks like the way we are switching the terminal's onescape handler back and forth
is the only thing that (almost certainly) won't allow use to do arbitrary recursion,
and we are going to need to need to attach it to the various screen_state objects.

And now it looks good for doing our crazy recursion idea.

Took out @SKLIOPMN, because this is a trivial function that unnecessarily complicates
the logic with application specific purposes.

Updated on 9/4/2024:

@SURMPLRK: The algorithm has been improved because the max_cols was being
initialized to stupidly high values, given normal terminal widths, causing
fmt_ls to be recursively called waaaay too many times.  

Also @JSOJPRI, which now has a while(true) loop, that *looks like* it *should*
always break...
»*/
/*Broken (now fixed)://«
1) Make a file with the 'touch' command
2) Use the '_blobs' command to verify there is no saved blob
3) Put something in that file with vim (this bug doesn't happen with shell redirects)
4) Verify that it has a saved blob with the '_blobs' command
5) Refresh the page
6) Verify that is no longer has a saved blob with the '_blobs' command
//»*/
//Issues«
/*@JEPOIKLMJYH: I don't understand why this was giving errors on backspaces
after pressing the up key in order to scroll back in history, but now it isn't!!
*/
//»
/*"Importing" command libraries via com_import is [NO LONGER] a deprecated solution.«
Instead, use the ALL_LIBS object, which stores the names of all of the 
commands, under an array that is keyed by the name of the given command
library in coms/, but just without the ending '.js'. This is a very
robust, quick&dirty solution to a problem that is made more complex with
something like an "import" command.
»*/
/*Websockets are *NOT* used in a kind of ssh mechanism.«

DUMB/COMPLEX IDEA BELOW!!!!
The 'ssh' command allows for 1 'server' terminal and 1 'client' terminal to
connect to the Node.js backend via websockets. The server terminal should have
all relevant environment variables set before executing the 'ssh --server' command, 
which locks the terminal.

"ssh immediate mode" means that the client sends everything after the prompt
to the ssh server. This is set via 'ssh -i'. While in immediate mode, it
can be terminated via Ctrl+c. Otherwise, any arguments to the ssh command
are interpreted as a command to be passed along to the server. This means
that all of the normal piping and redirections should work.

»*/
//»

//DevShell object«

const dev_commands = {//«

echo: function(args, opts, _) {//«
this.run=async()=>{
	for (let arg of args){
		_.out(arg);
		await sleep(1500);
	}
	_.out(EOF);
	this.ok();
};

},//»
pipe: function(args, opts, _){//«

let num = args.shift();
if (num) num = parseInt(num);
else num=1;

this.pipein=(val)=>{
log(val, num);
	if (isStr(val)) val = val.repeat(num);
//log(val);
	_.out(val);
	if (isEOF(val)) this.ok();
};

}//»

};//»

const dev_options = {};

const DevCommand = function(com_fn, args, opts, _){//«
	let com = new com_fn(args, opts, _);
	this.init = com.init;
	this.run = com.run;
	com.args=args;
	com.opts=opts;
	com._=_;
	if (_.pipein){
		this.pipein = com.pipein;
	}
	this.end = new Promise((Y,N)=>{
		com.end = Y;
		com.ok=()=>{Y(E_SUC);};
		com.no=()=>{Y(E_ERR);};
	});
};//»
const DevScript = function(com_lines, script_name, args, _){//«
	let prom_cb;
	this.end = new Promise(async(Y,N)=>{prom_cb = Y;});
	this.run=async()=>{
	};
};//»
const DevNoCommand = function(){//«

};//»
const DevErrCommand = function(err, _){//«

this.run=()=>{
	_.err(err);
};
this.end=()=>{
	return {code: E_ERR};
};

};//»

const DevShell = function(term){

//Var«

const shell = this;

/*Very dumbhack to implement cancellations of hanging commands, e.g. that might do fetching,«
so that no output from a cancelled command is sent to the terminal, although
whatever the command might be doing to keep it busy is still happening, so it
is up to the shell user to be aware of what is going on behind the scenes:

In shell.execute("command --line -is here"), the first local variable that is
set is started_time (@WIMNNUYDKL).

There is a global cancelled_time that is set when we do a Ctrl+c when the shell is busy.

Immediately after every 'await' in shell.execute(), we do the following check:

if (started_time < cancelled_time) return;

»*/
this.cancelled_time = 0;

//»

const get_script_text = async(comword, cur_dir)=>{//«
	const e=s=>{
		return {err: `${comword}: ${s}`};
	};
	let node = await fsapi.pathToNode(normPath(comword, cur_dir));
	if (!node) return e(`not found`);
	let app = node.appName;
	if (app===FOLDER_APP) return e("is a directory");
	if (app!==TEXT_EDITOR_APP) return e("not a text file");
	if (!comword.match(/\.sh$/i)){
		return e(`only executing files with '.sh' extension`);
	}
	let text = await node.text;
	if (!text) return e("no text returned");
	return {lines: text.split("\n")};
};//»

const execute_file = async (comword, script_args, cur_dir, env)=>{//«

	const e=s=>{
		return {err: `${comword}: ${s}`};
	};
	let node = await fsapi.pathToNode(normPath(comword, cur_dir));
	if (!node) return e(`not found`);
	let app = node.appName;
	if (app===FOLDER_APP) return e("is a directory");
	if (app!==TEXT_EDITOR_APP) return e("not a text file");
	if (!comword.match(/\.sh$/i)){
		return e(`only executing files with '.sh' extension`);
	}
	let text = await node.text;
	if (!text) return e("no text returned");
	let rv;
	let lines = text.split("\n");
	let out = [];
	let last_code;
	for (let ln of lines){
		let com = ln.trim();
		if (!com) continue;
		let {code, isExit} = await this.execute(com, {script_out: out, env, script_args, script_name: comword});
		last_code = code;
		if (isExit) break;
	}
//	return out;
	return {code: last_code, out};
};//»
this.execute=async(command_str, opts={})=>{//«

const can=()=>{//«
//Cancel test function
	return started_time < this.cancelled_time;
};//»

//Init/Var«
//WIMNNUYDKL

let started_time = (new Date).getTime();

let {script_out, script_args, script_name, env}=opts;

const sherr=(arg)=>{//«
	term.response(`sh: ${arg}`, {isErr: true});
//	if (!script_name) term.response_end();
	return {code: E_ERR};
};//»
let rv;

//Where does the output go?
let redir;

//This is only used for pipeline commands that are after the first command
// cat somefile.txt | these | might | use | the | stdin | array
let stdin;

//Refuse and enter command that seems too long for our taste
if (command_str.length > MAX_LINE_LEN) return sherr(`'${command_str.slice(0,10)} ...': line length > MAX_LINE_LEN(${MAX_LINE_LEN})`, script_out);

command_str = command_str.replace(/^ +/,"");
//»

//Parser«

//Escaping/Quoting«
//Only for creating newlines in single quotes: $'1\n2' and escaping spaces outside of quotes
let arr = shell_escapes([command_str]);

//Makes quote objects from single, double and backtick quotes. Fails if not terminated
arr = shell_quote_strings(arr);
if (isStr(arr)) return sherr(arr);
//»
//Tokenization«

//Comments are stripped
//This creates word objects and '$' objects.
//It also creates '>' and '>>' redirections.
//All unsupported tokens (redirects like '<' and control like '&') cause failure

let toks = shell_tokify(arr);
if (isStr(toks)) return sherr(toks);
//»
//Collect commands with their arguments«
let com = [];
let coms = [];
for (let tok of toks){
	if (tok.c_op){
		coms.push({com});
		com = [];
		coms.push(tok);
	}
	else{
		com.push(tok);
	}
}
if (com.length) coms.push({com});
//»
//Collect pipelines with their subsequent logic operators (if any)«
let pipes = [];
let pipe = [];
for (let tok of coms){
	if (tok.c_op && tok.c_op != "|"){
		if (tok.c_op==="&&"||tok.c_op==="||") {
			pipes.push({pipe, type: tok.c_op});
		}
		else {
			pipes.push({pipe}, tok);
		}
		pipe = [];
	}
	else if (!tok.c_op){
		pipe.push(tok);
	}
}
if (pipe.length) pipes.push({pipe});
//»
//Collect ';' separated lists of pipelines+logic operators (if any)«
let statements=[];
let statement=[];
for (let tok of pipes){
	let cop = tok.c_op;
	if (cop) {
		if (cop==="&"||cop===";"){
			statements.push({statement, type: cop});
			statement = [];
		}
		else{
			return sherr(`Unknown control operator: ${cop}`);
		}
	}
	else{
		statement.push(tok);
	}
}
if (statement.length) statements.push({statement});
//»

/*BAD LOGIC«
//NEUTYIOP
let all3 = [];
let andlist = [];
for (let tok of all2){
	if (tok.c_op && tok.c_op != "&&"){
		all3.push({andlist});
		andlist = [];
		all3.push(tok);
	}
	else if (!tok.c_op){
		andlist.push(tok);
	}
}
if (andlist.length) all3.push({andlist});

//WMJFOPUT
let statements = [];
let orlist = [];
for (let tok of all3){
	if (tok.c_op && tok.c_op != "||"){
		statements.push({orlist});
		orlist = [];
	}
	else if (!tok.c_op){
		orlist.push(tok);
	}
}
if (orlist.length) statements.push({orlist});
»*/

//»

let lastcomcode;
STATEMENT_LOOP: for (let state of statements){//«A 'statement' is a list of boolean-separated pipelines.

let loglist = state.statement;
if (!loglist){
	return sherr(`Logic list not found!`);
}
LOGLIST_LOOP: for (let i=0; i < loglist.length; i++){//«
	let pipe = loglist[i];
	let pipelist = pipe.pipe;
	if (!pipelist){
		return sherr(`Pipeline list not found!`);
	}
	let pipetype = pipe.type;

	let pipeline = [];
	let pipein;

	for (let j=0; j < pipelist.length; j++) {//«
		let inpipe = j < pipelist.length-1;
const out_cb=(lns, opts={})=>{//«

if (can()) return;

if (inpipe){
let next_com = pipeline[j+1];
if (next_com.pipein) next_com.pipein(lns);
return;
}

if (isStr(lns)) lns=[lns];
else if (isEOF(lns)){}
else if (!isArr(lns)){
log(lns);
throw new Error("Invalid value in out_cb");
}

//if (save_lns) return save_lns.push(...lns);

//MDKLIOUTYH
//else{
term.response(lns, opts);
term.scroll_into_view();
term.refresh();
//}
};//»
const err_cb=(lns)=>{//«
if (can()) return;
if (isStr(lns)) lns=[lns];
else if (!isArr(lns)){
log(lns);
throw new Error("Invalid value in err_cb");
}
term.response(lns, {isErr: true});
term.scroll_into_view();
term.refresh();

};//»
const suc_cb=(lns)=>{//«
if (can()) return;
if (isStr(lns)) lns=[lns];
else if (!isArr(lns)){
log(lns);
throw new Error("Invalid value in suc_cb");
}
term.response(lns, {isSuc: true});
term.scroll_into_view();
term.refresh();
};//»
const wrn_cb=(lns)=>{//«
if (can()) return;
if (isStr(lns)) lns=[lns];
else if (!isArr(lns)){
log(lns);
throw new Error("Invalid value in wrn_cb");
}
term.response(lns, {isWrn: true});
term.scroll_into_view();
term.refresh();
};//»
const inf_cb=(lns)=>{//«
if (can()) return;
if (isStr(lns)) lns=[lns];
else if (!isArr(lns)){
log(lns);
throw new Error("Invalid value in inf_cb");
}
term.response(lns, {isInf: true});
term.scroll_into_view();
term.refresh();
};//»

		let arr = pipelist[j].com;
		let args=[];

//Everything here
//Expansions/Redirections«

//1) Environment variable substitution
//2) File globbing '*', '?' and character ranges [a-zA-Z0-9]
//3) Curly brace expansion:
//
//$ echo file{0..3}.txt
//file0.txt file1.txt file2.txt file3.txt
		rv = await all_expansions(arr, term, {script_name, script_args});
		if (can()) return;
		if (rv){
			term.response(rv, {isErr: true});
		}

//- Turn quote objects into word objects
//- Single quotes that start with '$' look for internal escapes (currently only newline)
//- Backquotes are executed and replaced with the output
		for (let i=0; i < arr.length; i++){//«
			let tok = arr[i];
			let typ = tok.t;
			let val = tok[typ];
			if (typ==="quote") { 
				let typ = tok.quote_t;
				let ds = tok['$'];
				let outstr='';
				for (let ch of val){
					if (isObj(ch)&&ch.t=="esc"){
						if (ch.esc=="n"&&typ=="'"&&ds) outstr+="\n";
						else outstr+=ch.esc;
					}
					else outstr+=ch;
				}
				val = outstr;
				if (typ=="\x60") {
					let out=[];
//DJUYEKLMI
					await this.execute(val, {script_out: out, env});
					if (can()) return;
					if (isStr(out)) val = out;
					else if (isArr(out)&&out.length) val = out.join(" ");
					else val = "";
				}
//				arr[i]={t:"word", word: val, from_quote: true};
				arr[i]={t:"word", word: val};
			}
		}//»

//All sequences of non-whitespace separated quotes and words are concatenated:
//~$ echo "q 1"A"q 2""q 3"B   "q 4"C"q       5"D"q 6"
//q 1Aq 2q 3B q 4Cq       5Dq 6
		for (let i=0; i < arr.length-1; i++){//«
			let tok0 = arr[i];
			let tok1 = arr[i+1];
//XCFIUYO
//			let have_quote = tok0.from_quote || tok1.from_quote;
//			if (tok0.word && tok1.word && have_quote){
			if (tok0.word && tok1.word){
//				arr[i] = {t: "word", word: `${tok0.word}${tok1.word}`, from_quote: true}
				arr[i] = {t: "word", word: `${tok0.word}${tok1.word}`};
				arr.splice(i+1, 1);
				i--;
			}
		}//»

//Concatenate all sequences of escaped spaces and words
// ~$ touch this\ is\ cool.txt
		for (let i=0; i < arr.length-1; i++){//«
			let tok0 = arr[i];
			let tok1 = arr[i+1];
			if (tok0.esc === " " || tok1.esc === " "){
				arr[i] = {t: "word", word: `${tok0.word||" "}${tok1.word||" "}`, esc: tok1.esc}
				arr.splice(i+1, 1);
				i--;
			}
		}//»

//- Create redirection objects
//- Objects are converted into strings ({t:"word", word: "blah"} -> "blah")
//- Replace tilde with home path
		for (let i=0; i < arr.length; i++){//«
			let tok = arr[i];
			let typ = tok.t;
			let val = tok[typ];
			if (tok===" "){
				continue;
			}
			if (typ==="r_op"){
				let rop = tok.r_op;
				if (!(rop==">"||rop==">>")) {
					return sherr(`unsupported operator: '${tok.r_op}'`);
				}
				let tok2 = arr[i+1];
				if (!tok2) return sherr("syntax error near unexpected token `newline'");
				if (tok2.t == "quote") tok2={t: "word", word: tok2.quote.join("")}
				if (tok2==" ") {
					i++;
					tok2 = arr[i+1];
				}
				if (!(tok2 && tok2.t==="word")) return sherr(`invalid or missing redirection operand`);
				arr.splice(i+1, 1);
				val = null;
				redir = [tok.r_op, tok2.word];
			}
			if (val) {
				if (val.match(/^~/)){
					if (val==="~") val = globals.HOME_PATH;
					else if (val.match(/^~\x2f/)) val = globals.HOME_PATH+val.slice(1);
				}
				args.push(val);
			}
		}//»

		arr = args;

//Set environment variables (exports to terminal's environment if there is nothing left)
		rv = add_to_env(arr, env, {term});
		if (rv.length) term.response(rv, {isErr: true});
		if (arr[0]==" ") arr.shift();
//»

//Get the command. Immediately return to prompt if it is empty and we are not in a script.
		let comword = arr.shift();
		if (!comword) {
			pipeline.push(new DevNoCommand());
			continue;
		}
//Replace with an alias if we can«
		let alias = ALIASES[comword];
		if (alias){
//This should allow aliases that expand with options...
			let ar = alias.split(/\x20+/);
			alias = ar.shift();
			if (ar.length){
				arr.unshift(...ar);
			}
		}//»

		let usecomword = alias||comword;
/*
		if (usecomword=="exit"){//«
			let numstr = arr.shift();
			let code;
			if (numstr){
				if (!numstr.match(/^-?[0-9]+$/)) sherr("exit: numeric argument required");
				else code = parseInt(numstr);
			}
			else if (arr.length) sherr("exit: too many arguments");
			if (script_name) return {code, isExit: true};
			term.response("sh: not exiting the toplevel shell", {isWrn: true});
			break STATEMENT_LOOP;
		}//»
*/
		let com = dev_commands[usecomword];
/*
		if (isStr(com)){//QKIUTOPLK«
//If we have a string rather than a function, do the command library importing routine.
//The string is always the name of the library (rather than the command)
//This happens when: 
//1) libraries are defined in PRELOAD_LIBS, and 
//2) this is the first invocation of a command from one of those libraries.
			try{
				await import_coms(com);//com is the library name
				if (can()) return;
			}catch(e){
				if (can()) return;
cerr(e);
				sherr(`command library: '${com}' could not be loaded`);
				return;
			}
			let gotcom = active_commands[usecomword];
			if (!(gotcom instanceof Function)){
				sherr(`'${usecomword}' is invalid or missing in command library: '${com}'`);
				return;
			}
			com = gotcom;
		}//»
*/

		if (!com) {//Command not found!«
//If the user attempts to use, e.g. 'if', let them know that this isn't that kind of shell

			if (CONTROL_WORDS.includes(comword)){
//				sherr(`control structures are not implemented`);
				pipeline.push(new DevErrCommand(`control structures are not implemented`, {err: err_cb}));
//				lastcomcode = E_ERR;
				continue;
			}

//It doesn't look like a file.
//EOPIUYTLM
			if (!comword.match(/\x2f/)) {
				pipeline.push(new DevErrCommand(`${comword}: command not found`, {err: err_cb}));
//				sherr(`${comword}: command not found`);
				continue;
			}

//XGJUIKM
//Try to execute a "shell script" from file
			let {lines, err} = await get_script_text(comword, term.cur_dir);
			if (err){
				pipeline.push(new DevErrCommand(err, {err: err_cb}));
//				sherr(err);
				continue;
			}
			pipeline.push(new DevScript(lines, comword, arr, {
				redir,
				script_out,
				stdin,
				inpipe,
				term,
				env,
				command_str
			}));
/*«
			let {out, code, err} = await execute_file(comword, arr, term.cur_dir, env);
			if (can()) return;
if (err){
sherr(err);
lastcomcode = E_ERR;
continue;
}
			if (Number.isFinite(code)) lastcomcode = code;

//Redir/Pipe/Script out«
			if (redir&&redir.length){
				let {err} = await write_to_redir(term, out.join("\n"), redir, env);
				if (can()) return;
				if (err) {
					term.response(err);
				}
				if (inpipe) stdin = [];
			}
			else if (inpipe) {
//Collect the stdin (used as optional input for the next command) for pipelines
				stdin = out;
			}
			else {
				if (script_out){
					 if (out && out.length) script_out.push(...out);
				}
				else{
					term.response(out);
				}
			}
//»
»*/
		}//»
		else {//«
//Look for the command's options
			let opts;
			let gotopts = dev_options[usecomword];

//Parse the options and fail if there is an error message
			rv = get_options(arr, usecomword, gotopts);
			if (rv[1]&&rv[1][0]) {
				term.response(rv[1][0]);
				continue;
			}
			opts = rv[0];

			pipeline.push(new DevCommand(com, arr, opts, {//«
				redir,
				script_out,
				pipein: j>0,
//				stdin,
//				inpipe,
				term,
				env,
				opts,
				command_str,
				out: out_cb,
				err: err_cb,
				suc: suc_cb,
				wrn: wrn_cb,
				inf: inf_cb,
			}));//»
		}//»

	}//»

	for (let com of pipeline){
		if (com.init) await com.init();
	}
	for (let com of pipeline){
		if (com.run) com.run();
	}
	for (let com of pipeline){
		if (com.end) await com.end;
	}

/*«
//Command response callbacks«

//Everything that gets sent to redirects and pipes must be collected
//By default, only the 'out' stream will be collected.
let save_lns;
if (inpipe || script_out || (redir && redir.length)){
save_lns = [];
}


//»

//SKIOPRHJT
//Run command

		let code = await com(arr, opts, {//«
			redir,
			script_out,
			stdin,
			inpipe,
			term,
			env,
			opts,
			command_str,
			out: out_cb,
			err: err_cb,
			suc: suc_cb,
			wrn: wrn_cb,
			inf: inf_cb,
		});//»

		if (can()) return;

if (!Number.isFinite(code)) {
log(code);
throw new Error(`Invalid return value from: '${usecomword}'`);
}


		lastcomcode = code;

		if (redir&&redir.length){
			let {err} = await write_to_redir(term, save_lns.join("\n"), redir, env);
			if (can()) return;
			if (err) {
				term.response(err);
			}
			save_lns = [];
		}

		if (inpipe) {
			stdin = save_lns;
		}
		else if (script_out) script_out.push(...save_lns);

»*/


//LEUIKJHX
/*
	if (lastcomcode===E_SUC){//SUCCESS«
		if (pipetype=="||"){
			for (let j=i+1; j < loglist.length; j++){
				if (loglist[j].type=="&&"){
					i=j;
					continue LOGLIST_LOOP;
				}
			}
			break LOGLIST_LOOP;
		}
//		else:
//			1 pipetype=="&&" and we automatically go to the next one or:
//			2 there is no pipetype because we are the last pipeline of this loglist, and the logic of the thing doesn't matter
	}
	else{//FAILURE
		if (pipetype=="&&"){
			for (let j=i+1; j < loglist.length; j++){
				if (loglist[j].type=="||"){
					i=j;
					continue LOGLIST_LOOP;
				}
			}
			break LOGLIST_LOOP;
		}
//		else:
//			1 pipetype=="||" and we automatically go to the next one or:
//			2 there is no pipetype because we are the last pipeline of this loglist, and the logic of the thing doesn't matter
	}//»
*/

}//»

}//»

//In a script, refresh rather than returning to the prompt
if (script_out) {
	term.refresh();
	return {code: lastcomcode};
}

//Command line input returns to prompt
term.response_end();

}//»

};

//»
/*«DevShell2*/
const DevShell2 = (()=>{

class BaseCommand {//«
	constructor(shell, term, env, args, next, redir){
		this.shell = shell;
		this.term = term;
		this.env = env;
		this.args = args;
		this.next = next;//The next command in a pipeline (if any). Scripts can't be a 
						//'next', since there currently is no scripting mechanism for 
						//reading an input stream.
						//But if this command is in a script, and is at the end of
						//a pipeline, when the script command is itself inside a pipeline,
						//then the 'next' arg here needs to be the next command
						//of *that* pipeline.
		this.redir = redir;
		this.awaitEnd = new Promise((Y,N)=>{
			this.end=(arg)=>{
				this.killed = true;
				Y(arg);
			};
		});
	}
	getPipe(){}
	run(){}
	kill(){
		this.killed = true;
	}
	ok(){
		this.end({code: E_SUC});
	}
	no(){
		this.end({code: E_ERR});
	}
	out(mess){//Only the output stream gets sent to redir or through pipes
		if (this.killed) return;
		if (this.redir){
			//Write to redirect file
			return;
		}
		if (this.next){
			if (this.next.pipeIn) this.next.pipeIn(mess);
			return;
		}
		this.term.response(mess);
	}
	err(mess){
		if (this.killed) return;
		this.term.response(mess,{isErr: true});
	}
	wrn(mess){
		if (this.killed) return;
		this.term.response(mess,{isWrn: true});
	}
	suc(mess){
		if (this.killed) return;
		this.term.response(mess,{isSuc: true});
	}
	inf(mess){
		if (this.killed) return;
		this.term.response(mess,{isInf: true});
	}

}//»
class com_Whatever extends BaseCommand {//«

	getOpts(){
		return {
			s:{
				a:1,
				b:2,
				c:3
			},
			l:{
				anoarg: 1,
				bmaybearg: 2,
				cneedarg:3
			}
		}
	}

	setPipe(){
		if (this.args.length) return;
		this.inPipe = true;
		this.pipeIn = (val) => {
			if (this.killed) return;
			//...process val...
			val = this.doThis(val);
			//...and send stuff out
			this.out(val);
			if (isEOF(val)){
				this.ok();
			}
		};
	}

	doThis(val){
	}
	doThat(val){
	}

	run(){
		if (this.inPipe) return;
		let arg1 = this.args.shift();
		//...process arg1... 
		if (badarg){//...maybe barf...
			this.err("Ohhhhh noooooo!!!!");
			this.no();
			return;
		}
		//...or send stuff out
		this.out("Heee hee heee heee!!!");
		this.ok();
	}

}//»
class ScriptCommand extends BaseCommand {//«
	setScriptName(name){
		this.scriptName = name;
	}
	async run(){
		let scr = this.script;
		if (!scr){
			this.err("No script");
			this.no();
			return;
		}
		let pipeIn;
		if (this.next && this.next.pipeIn) pipeIn = this.next.pipeIn;
		let last_code;
		for (let ln of scr){
			let {haveExit, code} = await this.shell.execute(ln, {
				scriptName: this.scriptName,
				scriptArgs: this.args,
				scriptPipeOut: pipeIn,
				env: this.env
			});
			last_code = code;
			if (haveExit) break;
		}
		this.end({code: last_code});
	}
}//»
class BadCommand extends BaseCommand {//«
	run(){
		this.err(this.mess);
		this.no();
	}
}//»
class NullCommand extends BaseCommand {//«
	run(){
		this.no();
	}
}//»

const parse = command_str => {//«

//Escaping/Quoting«
//Only for creating newlines in single quotes: $'1\n2' and escaping spaces outside of quotes
let arr = shell_escapes([command_str]);

//Makes quote objects from single, double and backtick quotes. Fails if not terminated
arr = shell_quote_strings(arr);
if (isStr(arr)) return arr;
//»
//Tokenization«

//Comments are stripped
//This creates word objects and '$' objects.
//It also creates '>' and '>>' redirections.
//All unsupported tokens (redirects like '<' and control like '&') cause failure

let toks = shell_tokify(arr);
if (isStr(toks)) return toks;

//»
//Collect commands with their arguments«
let com = [];
let coms = [];
for (let tok of toks){
	if (tok.c_op){
		if (!com.length) return `unexpected empty command (found: '${tok.c_op}')`;
		coms.push({com});
		com = [];
		coms.push(tok);
	}
	else{
		if (!com.length && tok===" "){}//Do not allow a command to begin with whitespace
		else com.push(tok);
	}
}
if (com.length) coms.push({com});
//»
//Collect pipelines with their subsequent logic operators (if any)«
let pipes = [];
let pipe = [];
for (let i=0; i < coms.length; i++){
	let tok = coms[i];
	if (tok.c_op && tok.c_op != "|"){//Anything "higher order" than '|' ('&&', ';', etc) goes here
		if (tok.c_op==="&&"||tok.c_op==="||") {
			if (!coms[i+1]) return "malformed logic list";
			pipes.push({pipe, type: tok.c_op});
		}
		else {
			pipes.push({pipe}, tok);
		}
		pipe = [];
	}
	else if (!tok.c_op){//Commands and redirects
		pipe.push(tok);
	}
	else if (pipe.length && coms[i+1]){//noop: This token "must" be a '|'
	}
	else {
		return "malformed pipeline";
	}

}
if (pipe.length) pipes.push({pipe});
//»
//Collect ';' separated lists of pipelines+logic operators (if any)«
let statements=[];
let statement=[];
for (let tok of pipes){
	let cop = tok.c_op;
	if (cop) {
		if (cop==="&"||cop===";"){
			statements.push({statement, type: cop});
			statement = [];
		}
		else{
			return `unknown control operator: ${cop}`;
		}
	}
	else{
		statement.push(tok);
	}
}
if (statement.length) statements.push({statement});
return statements;

//»

};//»
const flatten_expand_quotes=async arr=>{//«
	for (let i=0; i < arr.length; i++){
		let tok = arr[i];
		let typ = tok.t;
		let val = tok[typ];
		if (typ==="quote") { 
			let typ = tok.quote_t;
			let ds = tok['$'];
			let outstr='';
			for (let ch of val){
				if (isObj(ch)&&ch.t=="esc"){
					if (ch.esc=="n"&&typ=="'"&&ds) outstr+="\n";
					else outstr+=ch.esc;
				}
				else outstr+=ch;
			}
			val = outstr;
			if (typ=="\x60") {
				val="BACK_QUOTE_EXPANSION_HERE";
/*
				let out=[];
				await this.execute(val, {commandSubOut: out, env});
				if (isStr(out)) val = out;
				else if (isArr(out)&&out.length) val = out.join(" ");
				else val = "";
*/
			}
			arr[i]={t:"word", word: val};
		}
	}
}//»
const extract_redirects = arr => {//«
	let redir;
	let com = [];
	for (let i=0; i < arr.length; i++){
		let tok = arr[i];
		let typ = tok.t;
		let val = tok[typ];
		if (typ==="r_op"){
			let rop = tok.r_op;
			if (!(rop==">"||rop==">>")) {
				return {err: `unsupported operator: '${tok.r_op}'`};
			}
			let tok2 = arr[i+1];
//log("TOK2", tok2);
			if (!tok2) return {err: "syntax error near unexpected token `newline'"};
/*Shouldn't have any quotes or spaces«
			if (tok2.t == "quote") tok2={t: "word", word: tok2.quote.join("")}
			if (tok2==" ") {
				i++;
				tok2 = arr[i+1];
			}
»*/
			if (!(tok2 && tok2.t==="word")) return {err: `invalid or missing redirection operand`};
			arr.splice(i+1, 1);
			val = null;
			redir = [tok.r_op, tok2.word];
		}
		if (val) com.push(val);
	}
	return {com, redir};
}//»

return function(term){

this.cancelled_time = 0;

this.execute = async(command_str, opts={})=>{

const cancelled=()=>{//«
//Cancel test function
	return started_time < this.cancelled_time;
};//»

let started_time = (new Date).getTime();

//scriptPipeOut: when the command is in a script, at the end of a pipeline, but
//				 the script is itself in a pipeline. This is the next command-in-the-pipeline's 
//				 'pipeIn' function.
//commandSubOut: for command/backquote substitutions. Everything in the output 
//				 stream that would get printed to the terminal gets pushed into this array
const { scriptName, scriptArgs, scriptPipeOut, commandSubOut, env } = opts;

const sherr=mess=>{
	term.response(`sh: ${mess}`, {isErr: true});
	if (!scriptName) term.response_end();
};

let statements = parse(command_str);
if (isStr(statements)) {
	sherr(statements);
	return;
}

STATEMENT_LOOP: for (let state of statements){//«A 'statement' is a list of boolean-separated pipelines.

let loglist = state.statement;
LOGLIST_LOOP: for (let i=0; i < loglist.length; i++){//«
	let pipe = loglist[i];
	let pipelist = pipe.pipe;
	let pipetype = pipe.type;
	let pipeline = [];
//Better go "forwards" so any error messages will be in the left-to-right pipeline sequence
	for (let j=0; j < pipelist.length ; j++){//«
//	for (let j=pipelist.length-1; j >=0 ; j--){
		let err, com, redir;
		let arr = pipelist[j].com;
//dollar sign ($<digit>, $<word>), file glob (*?), and curly brace (e.g. {1..9})
//curly brace expansions only works on single "word" tokens, which DO NOT include quote strings
//But according to the POSIX spec, quotes should be treated as PARTS of word tokens rather than 
//separate tokens!
//In other words, there should (according to POSIX) be *no difference* in output between:
//    $ echo "a"{1..5}"b"
//...and...
//    $ echo a{1..5}b
//    => a1b a2b a3b a4b a5b
		err = await env_glob_brace_expansions(arr, term, {script_name: scriptName, script_args: scriptArgs});
		if (cancelled()) return;
//cwarn("HI");
//jlog(arr);
//Non-fatal (?) expansion error
		if (err) term.response(err, {isErr: true});
//Fake backquote expansion: `whatever --the hell` => "BACK_QUOTE_EXPANSION_HERE"
		await flatten_expand_quotes(arr);
		if (cancelled()) return;
//Concatenate non-whitespace-separated words into a single word
		for (let i=0; i < arr.length-1; i++){//«
			let tok0 = arr[i];
			let tok1 = arr[i+1];
			if (tok0.word && tok1.word){
				arr[i] = {t: "word", word: `${tok0.word}${tok1.word}`};
				arr.splice(i+1, 1);
				i--;
			}
		}//»
//Concatenate successive backslash-escaped spaces and words
		for (let i=0; i < arr.length-1; i++){//«
			let tok0 = arr[i];
			let tok1 = arr[i+1];
			if (tok0.esc === " " || tok1.esc === " "){
				arr[i] = {t: "word", word: `${tok0.word||" "}${tok1.word||" "}`, esc: tok1.esc}
				arr.splice(i+1, 1);
				i--;
			}
		}//»
//Remove spaces between all tokens

		for (let i=0; i < arr.length; i++){//«
			if (arr[i]==" "){
				arr.splice(i, 1);
				i--;
			}
		}//»

		({err, com, redir} = extract_redirects(arr));
		if (err){
			sherr(err);
			return;
		}
		err = add_to_env(com, env, {term});
		if (err.length) term.response(err, {isErr: true});
jlog(com);
		let comword = com.shift();
//Replace with an alias if we can«
		let alias = ALIASES[comword];
		if (alias){
//This should allow aliases that expand with options...
			let arr = alias.split(/\x20+/);
			comword = arr.shift();
			if (arr.length){
				com.unshift(...arr);
			}
		}//»

//log("COMWORD", comword);
//if comword === "exit": break STATEMENT_LOOP
//jlog(com);
//See if comword:

// 0) Is literally nothing (whitespace in the logical "machinery")
//	  - The shell command language doesn't allow completely empty commands (there must
//		at least be variables being assigned/exported)
//	  => use NullCommand (implicitly "falsey")

// 1) is a key in the "active_commands" object
//	  - is the value a string? => Need to load the command library given by the string 
//										into "active_commands", and reevaluate the value
//	  - is the value a subclass of BaseCommand? => use the "com_Whatever extends BaseCommand"!
//	  - after new'ing it, attempt to parse the options from getOpts() (or whatever), and if 
//		there's a failure => use BadCommand (with the option-parsing error message) instead.

// 2) has a path separater in it (it must be a shell script)
//	- locate the script (using the current directory if necessary) => use ScriptCommand

// 3) exists somewhere in the environmental PATH variable 
//  - for now, it must be a shell script, since we are only loading JS commands as modules 
//	  inside of the server-side /coms folder
//  - use ScriptCommand

// 4) Doesn't exist: use BadCommand

	}//»

}//»


}//»

//jlog(statements);
//log(command_str);
term.response_end();

};

};
})();
/*»*/

/*11/14/24:« Want to put the different quote types inside of the words as their own
array objects. How about word objects:

class EscChar {//«
	#ch;
	#qtyp;
	constructor(ch){
		this.ch = ch;
	}
	toString(keepSlash){
		if (this.qtyp==="$'"){
			//...
		}
		else if (this.qtyp) {
			if (this.qtyp==='"' && (this.ch==='"'||this.ch==='$')) return this.ch;
			return "\\"+this.ch;
		}
		return this.ch;
	}
}//»
class BQuote {//«
	#arr;
	constructor(){
		this.arr=[];
	}
	addVal(ch){
//bare 'ch' or escaped('`')
	}
	toString(){}
	get length(){}
}//»
class DQuote{//«
	#arr;
	constructor(){
		this.arr=[];
	}
	addVal(ch){
//bare 'ch' or escaped('$' or '"') or expansion result
	}
	toString(){}
	get length(){}
}//»
class SQuote{//«
	#arr;
	constructor(){
		this.arr=[];
	}
	addVal(ch){
//bare 'ch' (can't be a "'")
	}
	toString(){}
	get length(){}
}//»
class DSQuote{//«
	#arr;
	constructor(){
		this.arr=[];
	}
	addVal(ch){
//bare 'ch' or escaped 'ch'
	}
	toString(){}
	get length(){}
}//»

class Word {//«
	#arr;
	constructor(){
		this.arr=[];
	}
	addVal(ch){
//bare 'ch' or escaped 'ch' or quote object or expansion result
	}
	toString(){}
	get length(){}
}//»

»*/
/*11/12/24: dev_mode 'DEBUG' flag, esp. certain logging statements that might«
take up a lot of room in the console, like jlog(some_large_object). We've
inserted a d_CAS keysym in order to toggle this.
»*/
/*11/9/24: class Command« 


»*/
/*« The shell is going to set args, opts, _, stdin, and end (the call back to 
call when it is done, which has the return code) on 'this'.

const com_blah = function(args, opts, _){
	this.init=()=>{
		//Set up io, via pipes

	};
	this.run=()=>{

	};
};

const Command = function(com_fn, args, opts, _, stdin){
	this.end = new Promise((Y,N)=>{
		let com = new com_fn(args, opts, _, stdin);
		this.init = com.init;
		this.run = com.run;
		com.end = Y;
		com.ok=()=>{Y(E_SUC);};
		com.no=()=>{Y(E_ERR);};
		com.args=args;
		com.opts=opts;
		com._=_;
	});
};

const get_command=async(com_fn, args, opts, _ stdin)=>{
	let com = new Command(com_fn, args, opts, _, stdin);
	if (com.init && (com.init instanceof Function)) {
		await com.init();
	}
	return com;
};

let command = new Command(com_blah, args, opts, _, stdin);

...

await command.end();

»*/
/*11/5/24: We are NOT supporting any kind of arguments/options for the "shell scripts"«
detected @XGJUIKM. Parsing options are actually the job of the scripts themselves, 
via the 'getopt' command. The example scripts for 'getopt' are kept in ChromeOS
at /usr/local/share/doc/util-linux/.

The positional arguments are kept in $1->$9 ($0 is the name of the script). Now
we are properly detecting these @FOPLIHGB. A shift command would allow us to
support more positional args than just the 9 in $1->$9 ($0 can't be "shifted"
off from the zeroth position).

Also: spaces are inserted in between substituted params:

echo $USER$USER // me me

FIXED @XCFIUYO by getting rid of the 'have_quote' requirement (that only concatenated
successive quotes).

»*/
/*11/5/24: I know there is a flaw in my handling of "logic lists" (FIXED?):«
this && that || the && other 
...but I can't recreate it now. I am first collecting up sequences of
'&&' separated pipelines @NEUTYIOP, and then sequences of these
'||' separated 'andlists' @WMJFOPUT.

First, @SHJUTIOP, we loop through the 'andlists' of each 'orlist', and break
out of the first successful 'andlist' at @KDRETATY. We break out of the first
unsuccessful pipeline in each 'andlist' @TOPIKLMN. I know this is *NOT* the
correct way of implementing shell logic but for some strange reason, I can't
demonstrate the simple way that it differs.

I HAVE THE RECREATION OF THE BUG:
In bash:
$ true || false && echo hi
...outputs "hi", while mine skips over the entire 'andlist' of "false && echo hi", and
so the echo command is never reached.

What we need to do is use the return value of each pipeline.
In the case of success, skip over the next or-pipelines.
In the case of failure, skip over the next and-pipelines.


@LEUIKJHX: Hopefully this is the fix!


---------------------------------------------------------

Now with pattern matching:
Just updated the dotfile logic @SMKOIOPU so that we just match dotfiles in the case
of a leading dot:
	echo .*
...but leave out the dotfiles otherwise:
	echo *

»*/
/*« 10/26/24: Create a dev_shell object, so that we can toggle between it and the 
normal shell (Ctrl+Alt+s). It currently just has an execute method that just 
logs the command string calls response_end(). So now we can implement alternative
parsing methods, while still keeping all of the terminal's REPL (history and line
editing, etc.) capabilities perfectly in tact.
»*/
/*10/18/24: There may be issues with parsing @IORTYUEWJ: There we are just looking for«
the shortest match (like for pipes). So when we do:
	$ true|||false
...we get...
	I'm true
...rather than...
	syntax error near unexpected token `|'
So we *MUST* check for the next token to ensure it is a valid "word-type" token
rather than a metacharacter
»*/
//Notes«
/*Incorrect way to create success/error/warning colors @WOPIUTHSDKL.
Instead, we need to do it @DJKUIOJED*/
/*TODO:Update rest of the command libraries with the new response and return mechanism«

const com_what=(args, opts, _)=>{

const {term, out, err, suc} = _;
...
err("Error message in red here");
return E_ERR;
...
suc("Success message in green here");
return E_SUC;
...
//Standard output for the terminal (or pipes/redirects)
out(some_lines, {colors: opt_colors});
return E_SUC;

};

»*/
/*10/16/24: I've been getting into edge cases of expected shell behaviour, such as
whether to treat a non-existent command as a simple command failure or to exit the
current command line (which is what I was doing). Here, "barf" doesn't exist as a command:

$ barf ||  echo This will never be seen

Now (@EOPIUYTLM), we are sending an error response and setting lastcomcode to E_ERR.

*/
/*10/15/24: Getting command output streams to "just work".«

-There are 3 streams: out, err, suc
-Only the out stream will be sent through pipes and redirects (there should be a shell option)
to merge/flatten all streams into the out stream.
-The out stream can be arbitrarily colorized
-The err stream will be colored red
-The suc stream will be colored green

These are the names of the callbacks that are given in the "_" (3rd) argument to the
called commands (@SKIOPRHJT).

Commands should only return an error code @CKLOPUTIK.

Now need to update all commands so that they call the output functions (out, err, suc)
and return *either* E_SUC or E_ERR.

Want to give hints to the respective response callbacks (like @MDKLIOUTYH) whether
the terminal should do scroll_into_view and refresh. If we are in a tight loop, such
as in com_ls, we might want to save on the cpu cycles, when it comes to very long
(possibly recursive) listings.

»*/
//»

/*«DevShell*/
//SOTFKL
const DevShell = (()=>{

/*«Command Classes*/
class BaseCommand {//«
	constructor(shell, term, env, args, next, redir){
		this.shell = shell;
		this.term = term;
		this.env = env;
		this.args = args;
		this.next = next;//The next command in a pipeline (if any). Scripts can't be a 
						//'next', since there currently is no scripting mechanism for 
						//reading an input stream.
						//But if this command is in a script, and is at the end of
						//a pipeline, when the script command is itself inside a pipeline,
						//then the 'next' arg here needs to be the next command
						//of *that* pipeline.
		this.redir = redir;
		this.awaitEnd = new Promise((Y,N)=>{
			this.end=(arg)=>{
				this.killed = true;
				Y(arg);
			};
		});
	}
	getPipe(){}
	run(){}
	kill(){
		this.killed = true;
	}
	ok(){
		this.end({code: E_SUC});
	}
	no(){
		this.end({code: E_ERR});
	}
	out(mess){//Only the output stream gets sent to redir or through pipes
		if (this.killed) return;
		if (this.redir){
			//Write to redirect file
			return;
		}
		if (this.next){
			if (this.next.pipeIn) this.next.pipeIn(mess);
			return;
		}
		this.term.response(mess);
	}
	err(mess){
		if (this.killed) return;
		this.term.response(mess,{isErr: true});
	}
	wrn(mess){
		if (this.killed) return;
		this.term.response(mess,{isWrn: true});
	}
	suc(mess){
		if (this.killed) return;
		this.term.response(mess,{isSuc: true});
	}
	inf(mess){
		if (this.killed) return;
		this.term.response(mess,{isInf: true});
	}

}//»
class com_Whatever extends BaseCommand {//«

	getOpts(){
		return {
			s:{
				a:1,
				b:2,
				c:3
			},
			l:{
				anoarg: 1,
				bmaybearg: 2,
				cneedarg:3
			}
		}
	}

	setPipe(){
		if (this.args.length) return;
		this.inPipe = true;
		this.pipeIn = (val) => {
			if (this.killed) return;
			//...process val...
			val = this.doThis(val);
			//...and send stuff out
			this.out(val);
			if (isEOF(val)){
				this.ok();
			}
		};
	}

	doThis(val){
	}
	doThat(val){
	}

	run(){
		if (this.inPipe) return;
		let arg1 = this.args.shift();
		//...process arg1... 
		if (badarg){//...maybe barf...
			this.err("Ohhhhh noooooo!!!!");
			this.no();
			return;
		}
		//...or send stuff out
		this.out("Heee hee heee heee!!!");
		this.ok();
	}

}//»
class ScriptCommand extends BaseCommand {//«
	setScriptName(name){
		this.scriptName = name;
	}
	async run(){
		let scr = this.script;
		if (!scr){
			this.err("No script");
			this.no();
			return;
		}
		let pipeIn;
		if (this.next && this.next.pipeIn) pipeIn = this.next.pipeIn;
		let last_code;
		for (let ln of scr){
			let {haveExit, code} = await this.shell.execute(ln, {
				scriptName: this.scriptName,
				scriptArgs: this.args,
				scriptPipeOut: pipeIn,
				env: this.env
			});
			last_code = code;
			if (haveExit) break;
		}
		this.end({code: last_code});
	}
}//»
class BadCommand extends BaseCommand {//«
	run(){
		this.err(this.mess);
		this.no();
	}
}//»
class NullCommand extends BaseCommand {//«
	run(){
		this.no();
	}
}//»
/*»*/

/*«Var*/
const EOF_Type = 1;
const OPERATOR_CHARS=[//«
"|",
"&",
";",
"<",
">",
"(",
")",
];//»
const UNSUPPORTED_OPERATOR_CHARS=["(",")"];
const OPERATOR_TOKS=[//«
'&&',
'||',
';;',
';&',
'>&',
'>>',
'>|',
'<&',
'<<',
'<>',
'<<-',
'<<<',
];//»
const UNSUPPORTED_OPERATOR_TOKS=[/*«*/
	'&',
	'<',
	';;',
	';&',
	'>&',
	'>|',
	'<&',
	'<<',
	'<>',
	'<<-',
	'<<<'
];/*»*/
const OCTAL_CHARS=[ "0","1","2","3","4","5","6","7" ];

const INVSUB="invalid/unsupported substitution";
const START_NAME_CHARS = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "_"];
const DIGIT_CHARS_1_to_9=["1","2","3","4","5","6","7","8","9"];
const ANY_DIGIT_CHARS=["0", "1","2","3","4","5","6","7","8","9"];
const ANY_NAME_CHARS = [...START_NAME_CHARS, ...ANY_DIGIT_CHARS];
const SPECIAL_SYMBOLS=[/*«*/
	"@",
	"*",
	"#",
	"?",
	"-",
	"$",
	"!",
	"0"
];/*»*/
/*»*/
//Util«

const escapes = arr => {//«

let in_single = false;
for (let j = 0; j < arr.length; j++) {
	let tok = arr[j];
	if (tok === "\\") {
		if (!in_single && arr[j+1]) {
			let obj = new String(arr[j+1]);
			obj.escaped = true;
			obj.toString=function(){
				return "\\"+this.valueOf();
			};
			arr[j] = obj;
			arr.splice(j + 1, 1);
		}
	}
	else if(tok==="'") {
		if (in_single) in_single = false;
		else if (j>0 && arr[j-1] !== "$") in_single = true;
	}
}
return arr;

};//»

const ds_single_quote_escapes = tok=>{//«
let wrd = tok.word;
if (!wrd){
cwarn("WHAT THE HELL IS HERE????");
log(tok);
return tok;
}
let arr = wrd;
let out = [];
let in_ds_single = false;

for (let i=0; i < arr.length; i++){
let ch = arr[i];
let next = arr[i+1];
if (!in_ds_single&&ch==="$"&&next==="'"){
	in_ds_single=true;
//	out.push("$'");
	out.push("$","'");
	i++;
}
else if (in_ds_single){
//log("INDSSINGLE");
	if (ch.escaped){
//log("CH.ESCAPED", ch);
	let c;
//switch(ch){/*«*/

//\" yields a <quotation-mark> (double-quote) character, but note that
//<quotation-mark> can be included unescaped.
if  (ch=='"') {c='"';}
//\' yields an <apostrophe> (single-quote) character.
//else if (ch=="'") { c="'";}

//\\ yields a <backslash> character.
else if (ch=='\\') { c='\\';}

//\a yields an <alert> character.
else if (ch=='a') { c='\x07';}

//\b yields a <backspace> character.
else if (ch=='b') { c='\x08';}

//\e yields an <ESC> character.
else if (ch=='e') { c='\x1b';}

//\f yields a <form-feed> character.
else if (ch=='f') { c='\x0c';}

//\n yields a <newline> character.
else if (ch=='n') { c='\n';}

//\r yields a <carriage-return> character.
else if (ch=='r') { c='\x0d';}

//\t yields a <tab> character.
else if (ch=='t') { c='\t';}

//\v yields a <vertical-tab> character.
else if (ch=='v') { c='\x0b';}

else if (ch=='x'){/*«*/
//\xXX yields the byte whose value is the hexadecimal value XX (one or more hexadecimal digits). If more than two hexadecimal digits follow \x, the results are unspecified.
	if (next&&next.match(/[0-9a-fA-F]/)){
	let next2 = arr[i+2];
		if (next2 &&next2.match(/[0-9a-fA-F]/)){
			c = eval( '"\\x' + next + next2 + '"' );
			i+=2;
		}
		else{
			c = eval( '"\\x0' + next + '"' );
			i++;
		}
	}
}/*»*/

//\ddd yields the byte whose value is the octal value ddd (one to three octal digits).
else if(ch=="0"|| ch=="1"|| ch=="2"|| ch=="3"|| ch=="4"|| ch=="5"|| ch=="6"|| ch=="7"){/*«*/
	let s = ch;
//Array.includes tests for strict equality, so escaped chars will not match...
	if (next&&OCTAL_CHARS.includes(next)){
		s+=next;
		let next2 = arr[i+2];
		if (next2&&OCTAL_CHARS.includes(next2)){
			s+=next2;
			i+=2;
		}
		else i++;
		c = eval( '"\\x' + (parseInt(s, 8).toString(16).padStart(2, "0")) + '"' );
	}
}/*»*/

//The behavior of an unescaped <backslash> immediately followed by any other
//character, including <newline>, is unspecified.

//\cX yields the control character listed in the Value column of Values for
//cpio c_mode Field in the OPERANDS section of the stty utility when X is one
//of the characters listed in the ^c column of the same table, except that \c\\
//yields the <FS> control character since the <backslash> character has to be
//escaped.

//}/*»*/
	if (c) out.push(c);
	else out.push(ch);
	}
	else if (ch==="'"){
		in_ds_single = false;
		out.push("'");
	}
	else{
		out.push(ch);
	}
}
else {
//	if (ch.escaped) out.push("\\"+ch);
//	else out.push(ch);
	out.push(ch);
}
}

return {t:"word",word: out};
};//»
const curly_expansion = (arr, from_pos) => {//«
//log("FROM", from_pos);
let ind1 = arr.indexOf("{", from_pos);
let ind2 = arr.lastIndexOf("}");

if (ind1 >= 0 && ind2 > ind1) {//«
//We know these aren't escaped, but they *might* be inside of quotes
let qtyp=null;
let curly_arr;
let start_i;
let final_i;
let have_comma = false;
let have_dot = false;
let have_quote = false;
let have_escape = false;
let comma_arr;
let num_open_curlies = 0;
for (let i=from_pos; i < arr.length; i++){//«

let ch = arr[i];
if (!qtyp){//«
	if (["'",'"','`'].includes(ch)) {
		qtyp = ch;
		have_quote = true;
	}
	else if (ch==="{" && (i===0 || arr[i-1] !== "$")){
		num_open_curlies++;
		if (num_open_curlies === 1 && !curly_arr) {
			start_i = i;
			curly_arr = [];
			continue;
		}
	}
	else if (ch==="}"){
		num_open_curlies--;
		if (num_open_curlies === 0 && curly_arr){
			final_i =  i;
			break;
		}
	}
}//»
else if (qtyp===ch) qtyp=null;

if (curly_arr) {//«
	if (!qtyp){
		if (ch===",") {
			have_comma = true;
			if (num_open_curlies===1){
				if (!comma_arr) comma_arr = [];
				comma_arr.push([...curly_arr]);
				curly_arr = [];
				continue;
			}
		}
		else {
			if (!have_dot) have_dot = ch === ".";
			if (!have_escape) have_escape = ch.escaped;
		}
	}
	curly_arr.push(ch);
}//»

}//»

if (comma_arr){
	comma_arr.push([...curly_arr]);
}

if (!final_i){//«
	if (Number.isFinite(start_i)){
		if (start_i+2 < arr.length){
			return curly_expansion(arr, start_i+1);
		}
		else{
//cwarn("GIVING UP!");
		}
	}
	else{
//log("NOT OPENED");
	}
	return arr;
}//»
else{//«

let pre = arr.slice(0, start_i);
let post = arr.slice(final_i+1);
if (comma_arr){//«
	let words=[];
	for (let comarr of comma_arr){
		words.push(pre.slice().concat(comarr.slice()).concat(post.slice()));
	}
	return words;
}//»
else if (have_dot&&!have_quote&&!have_escape){//«
//The dot pattern is a very strict, very literal pattern
let cstr = curly_arr.join("");
let marr;
let from, to, inc, is_alpha;

let min_wid=0;
if (marr = cstr.match(/^([-+]?\d+)\.\.([-+]?\d+)(\.\.([-+]?\d+))?$/)){//«
//cwarn("NUMS",marr[1], marr[2], marr[4]);

//We're supposed to look for '0' padding on the from/to
	let min_from_wid=0;
	let from_str = marr[1].replace(/^[-+]?/,"");
	if (from_str.match(/^(0+)/)) min_from_wid = from_str.length;

	let min_to_wid=0;
	let to_str = marr[2].replace(/^[-+]?/,"");
	if (to_str.match(/^(0+)/)) min_to_wid = to_str.length;

	if (min_from_wid > min_to_wid) min_wid = min_from_wid;
	else min_wid = min_to_wid;

	from = parseInt(marr[1]);
	to = parseInt(marr[2]);
	inc = marr[4]?parseInt(marr[4]):1;
}
else if (marr = cstr.match(/^([a-z])\.\.([a-z])(\.\.([-+]?\d+))?$/i)){
//cwarn("ALPHA",marr[1], marr[2], marr[4]);
	is_alpha = true;
	from = marr[1].charCodeAt();
	to = marr[2].charCodeAt();
	inc = marr[4]?parseInt(marr[4]):1;
}
else{
	return arr;
}//»

inc = Math.abs(inc);

let vals=[];
let iter=0;
//log(from, to);
if (from > to){
	for (let i=from; i >= to; i-=inc){
	iter++;
	if (iter > 10000) throw new Error("INFINITE LOOP AFTER 10000 iters????");
		if (is_alpha) vals.push(String.fromCharCode(i));
		else vals.push(((i+"").padStart(min_wid, "0")));
	}
}
else {
	for (let i=from; i <= to; i+=inc){
	iter++;
	if (iter > 10000) throw new Error("INFINITE LOOP AFTER 10000 iters????");
		if (is_alpha) vals.push(String.fromCharCode(i));
		else vals.push(((i+"").padStart(min_wid, "0")));
	}
}

let words = [];
for (let val of vals){
	words.push(pre.slice().concat([val]).concat(post.slice()));
}
return words;

}//»
else{
//log("NOTHING");
return arr;
}
}//»

}//»
else{//«
	if (ind1<0 && ind2 < 0) {
//log("NO CURLIES");
	}
	else if (ind1 >= 0 && ind2 >= 0){
//log("BOTH CURLIES DETECTED IN WRONG POSITOIN");
	}
	else if (ind1 >= 0) {
//log("OPEN CURLY ONLY");
	}
	else if (ind2 >= 0){
//log("CLOSE CURLY ONLY");
	}
	return arr;
}//»

}//»
const tilde_expansion = tok => {//«
//log("TILDE", tok);
//Just expand everything after NAME=
//NAME=...
//let pref = tok
let wrdarr = tok.word;
let wrdstr = tok.word.join("");
//cwarn(`CHECK: <${wrdstr}>`);
let marr;
if (marr = wrdstr.match(/^([_a-zA-Z][_a-zA-Z0-9]*=)/)){
//If this is a valid shell variable assignment, expand lone '~' or all '~/' after 
//the first '=' and every ':' with $HOME
let from = marr[1].length;
let start = tok.word.slice(0, from);
let arr = tok.word.slice(from);
//cwarn("EXPAND LONE '~' or initial '~/' and every one after a ':'");
//log(arr);
if (!arr.length) return tok;
if (arr.length===1&&arr[0]==="~"){
	return {t: "word",word: [...start, ...globals.HOME_PATH]};
}
let out=[];
for (let i=0; i < arr.length; i++){/*«*/
	if (i===0&&arr[0]==="~"&&arr[1]=="/"){
		out.push(...globals.HOME_PATH, arr[1]);
		i++;
	}
	else if (arr[i]===":" && arr[i+1]==="~"){
		if (!arr[i+2]){
			out.push(":", ...globals.HOME_PATH);
			return {t: "word",word: [...start,...out]};
		}
		else if (arr[i+2]=="/"){
			out.push(":", ...globals.HOME_PATH,"/");
			i+=2;
		}
		else{
			out.push(arr[i], arr[i+1]);
			i++;
		}
	}
	else {
		out.push(arr[i]);
	}
}/*»*/
return {t: "word",word: [...start,...out]};
}
else if (wrdstr==="~") {
//Expand '~' or the leading '~/'
//cwarn("EXPAND LONE '~'");
//log(tok.word);
tok.word=[...globals.HOME_PATH];
}
else if (wrdstr.match(/^~\x2f/)){
tok.word=[...globals.HOME_PATH, ...wrdarr.slice(1)];
//cwarn("EXPAND initial '~/'");
}
return tok;
};/*»*/
const parameter_expansion = tok => {//«
//We will also need env, script_name, and script_args passed in here
/*«

A "parameter" is a NAME or a SYMBOL, as described below.

We are looking for one of:

$LONGESTNAME, $ONEDIGIT, ${NAME}, ${ONEORMOREDIGITS}, $[@*#?-$!0] or ${[@*#?-$!0]}:
@: positional parameters starting from 1, and something about field splitting
*: Same as above, with something else about field splitting
#: Number of positional parameters (minus the 0th)
?: Most recent exit code
-: Current options flag
$: pid of the shell
!: pid of most recent '&' statement
0: name of shell or shell script

All DIGIT's (other than 0) are the current (1-based) positional parameters

These expands in anything other than single quotes

We can also easily support '${#NAME}', since this just gives the length of the
string of the variable, NAME.

I'm not sure how to handle:
$ DQUOTE='"'
$ echo "$DQUOTE"

Maybe escape all quote substitutions (in double quotes or out), and all redir chars?

»*/
/*

Should we not put everything inside $'...', and then escape ALL
single quotes that are in the replacement value??? Otherwise, there can't be
escaped single quotes inside of pure single quotes: '\'' (doesn't work!)

So, if we do:
PARAM_WITH_SINGLE_QUOTES="...'//..."

echo BLAH${PARAM_WITH_SINGLE_QUOTES}BLAH
=> BLAH$'...\'//...'BLAH

*/
let word = tok.word;
let qtyp;
for (let i=0; i < word.length; i++){

let ch = word[i];
if (!qtyp){
	if (["'",'"','`'].includes(ch)) {
		qtyp = ch;
		continue;
	}
	else{
//Unquoted stuff
	}
}
else if (qtyp===ch) {
	qtyp=null;
	continue;
}
else if (qtyp!=='"') continue;

//We are unquoted or in double quotes

if (ch==="$"){/*«*/

const do_name_sub=(name)=>{//«
cwarn("NAME", name, start_i, end_i);

let env={
choint:"1",
UB:"Far   in   the   harrrr!!!"
};
let diff = end_i - start_i;
let val = env[name]||"";
word.splice(start_i, end_i-start_i+1, ...val);

/*
for (let i=0; i < val.length; i++){
	if (val[i]==="'"){
		let s = new String("'");
		s.escaped = true;
		s.toString=function(){
			return "\\"+this.valueOf();
		};
		val[i]=s;
	}
}
//word.splice(start_i, end_i-start_i+1, "$", "'", ...val,"'");

word.splice(start_i, end_i-start_i+4, "$", "'", ...val,"'");
i = end_i + (name.length - (val.length+3));

*/

i = end_i + (name.length - val.length);

};/*»*/
const do_arg_sub=(num)=>{//«
cwarn("ARG", num, start_i, end_i);
};/*»*/
const do_sym_sub=(sym)=>{//«
cwarn("SYM", sym, start_i, end_i);
};/*»*/
const BADSUB=(arg, next)=>{return `bad substitution: stopped at '\${${arg}${next?next:"<END>"}'`;}

	let next = word[i+1];
	if (!next) continue;
	let start_i = i;
	let end_i;
	if (next==="{") {/*«*/
		i++;
//If no next one or the next one is a "}", barf INVSUB
//If the next one is a special symbol, there must be a "}" immediately following it
//If the next one is a digit, there must be 0 or more digits (maybe "0") followed by the "}"
//Otherwise, the next one must be a START_NAME_CHARS, followed by 0 or more 
//    ANY_NAME_CHARS, with a terminating "}".
		next = word[i+1];
		if (!next) return "bad substitution: '${<END>'";
		else if (next==="}") return "bad substitution: '${}'";

if (SPECIAL_SYMBOLS.includes(next)){/*«*/
	let sym = next;
	i++;
	next = word[i+1];
//	if (next !== "}") return INVSUB;
//	if (next !== "}") return `bad substitution: have '\${${sym}${next?next:"<END>"}'`;
	if (next !== "}") return BADSUB(sym, next);
	end_i = i+1;
	do_sym_sub(sym);
//cwarn("Substitute symbol", sym);
//Substitute symbol, 'sym'
}/*»*/
else if (DIGIT_CHARS_1_to_9.includes(next)){/*«*/
	let numstr=next;
	i++;
	next = word[i+1];
	while(true){
		if (next==="}"){
		//Do a parseInt on numstr, and if in a script, replace with: script_arg[num-1]
//cwarn("Substitute script_arg #", argnum);
//			end_i = i;
			end_i = i+1;
			do_arg_sub(parseInt(numstr)-1);
			break;
		}
		if (!ANY_DIGIT_CHARS.includes(next)){
//			return `bad substitution: have '\${${numstr}${next?next:"<END>"}'`;
			return BADSUB(numstr, next);
//			return INVSUB;
		}
		numstr+=next;
		i++;
		next = word[i+1];
	}
}/*»*/
else if (START_NAME_CHARS.includes(next)){/*«*/

let namestr=next;
i++;
next = word[i+1];
while(true){
	if (next==="}"){
//Replace with the substitution of 'namestr'
//cwarn("Substitute param name", namestr);
//		end_i = i;
		end_i = i+1;
		do_name_sub(namestr);
		break;
	}
	if (!ANY_NAME_CHARS.includes(next)){
//		return `bad substitution: have '\${${namestr}${next?next:"<END>"}'`;
		return BADSUB(namestr, next);
//		return INVSUB;
	}
	namestr+=next;
	i++;
	next = word[i+1];
}

}/*»*/
else return INVSUB;

	}/*»*/
	else{/*«*/
//If the next one is a special symbol (including "0"), we can do the substitution now«
//Else if the next is one of DIGIT_CHARS "1"->"9", we can do the substitution noe
//Else if the next isn't a START_NAME_CHARS, we continue and keep this a 
//  literal '$'
//Else we look at every succeeding char, and do the sub on the first non-ANY_NAME_CHARS.

//		i++;
//		next = word[i+1];»

if (SPECIAL_SYMBOLS.includes(next)){
	end_i = i+1;
	do_sym_sub(next);
}
else if (DIGIT_CHARS_1_to_9.includes(next)){
	end_i = i+1;
	do_arg_sub(parseInt(next)-1);
}
else if (!START_NAME_CHARS.includes(next)){
	continue;
}
else{/*«*/

let namestr=next;
i++;
next = word[i+1];
while(true){
	if (!ANY_NAME_CHARS.includes(next)){
cwarn("Substitute param name", namestr);
end_i=i;
do_name_sub(namestr);
		break;
	}
	namestr+=next;
	i++;
	next = word[i+1];
}

}/*»*/

	}/*»*/

}/*»*/

}

return tok;
};/*»*/

//»

//ErrorHandler«

const ErrorHandler = class {

	constructor() {//«
		this.errors = [];
		this.tolerant = false;
	}//»
	recordError(error) {//«
		this.errors.push(error);
	};//»
	tolerate(error) {//«
		if (this.tolerant) {
			this.recordError(error);
		}
		else {
			throw error;
		}
	};//»
	constructError(msg, column) {//«
		var error = new Error(msg);
		try {
			throw error;
		}
		catch (base) {

			if (Object.create && Object.defineProperty) {
				error = Object.create(base);
				Object.defineProperty(error, 'column', { value: column });
			}
		}
		return error;
	};//»
	createError(index, line, col, description) {//«
		var msg = description + ` (line ${line})`;
		var error = this.constructError(msg, col);
		error.index = index;
		error.lineNumber = line;
		error.description = description;
		return error;
	};//»
	throwError(index, line, col, description) {//«
		throw this.createError(index, line, col, description);
	};//»
	tolerateError(index, line, col, description) {//«
		var error = this.createError(index, line, col, description);
		if (this.tolerant) {
			this.recordError(error);
		}
		else {
			throw error;
		}
	};//»

};//»
//Scanner«

//These 2 functions are "holdover" logic from esprima, which seems too "loose" for 
//typical shell scripting purposes
const isWhiteSpace = (cp) => {//«
	return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
		(cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
};//»
const isLineTerminator = (cp) => {//«
	return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
};//»

const Scanner = class {

constructor(code, handler) {//«
	this.source = code;
	this.errorHandler = handler;
	this.length = code.length;
	this.index = 0;
	this.lineNumber = (code.length > 0) ? 1 : 0;
	this.lineStart = 0;
}//»

eof() {//«
	return this.index >= this.length;
};//»

throwUnexpectedToken(message) {//«
	if (message === void 0) { message = Messages.UnexpectedTokenIllegal; }
	return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
};//»

skipSingleLineComment() {//«
	while (!this.eof()) {
//		let ch = this.source.charCodeAt(this.index);
		let code = this.source[this.index].charCodeAt();
		if (isLineTerminator(code)) {
			return;
		}
		this.index++;
	}
};//»
scanComments() {//«
	while (!this.eof()) {
		let code = this.source[this.index].charCodeAt();
		if (isWhiteSpace(code)) {
			++this.index;
		}
		else if (isLineTerminator(code)) {
			break;
		}
		else if (code===0x23){//'#' in 0th line position or preceeded by a space or tab«
			if (this.index - this.lineStart === 0 || this.source[this.index-1] === " " || this.source[this.index-1] === "\t"){
				this.index++;
				this.skipSingleLineComment();
			}
			else {
				break;
			}
		}//»
		else {
			break;
		}
	}
};//»

scanOperator(){/*«*/

	let src = this.source;
	let start = this.index;
	let str = src[start];
	switch(str){
	case '(':/*«*/
	case ')':
		++this.index;
		break;/*»*/
	case '&':/*«*/
		++this.index;
		if (src[this.index]==="&"){
			this.index++;
			str="&&";
		}
		break;/*»*/
	case '|':/*«*/
		++this.index;
		if (src[this.index]==="|"){
			this.index++;
			str="||";
		}
		break;/*»*/
	case '>'://«
		++this.index;
		if ([">","&","|"].includes(src[this.index])){
			str+=src[this.index];
			++this.index;
		}
		break;/*»*/
	case '<':/*«*/
		++this.index;
	//'<<',
	//'<>',
	//'<<-',
	//'<<<',
		if (src[this.index]===">"){
			str = "<>";
			++this.index;
		}
		else if (src[this.index]==="<"){
			++this.index;
			if (src[this.index]==="<"){
				++this.index;
				str = "<<<";
			}
			else if (src[this.index]==="-"){
				++this.index;
				str = "<<-";
			}
			else{
				str="<<";
			}
		}
		break;/*»*/
	case ';':
		++this.index;
		break;
	}
	if (this.index === start) {
		this.throwUnexpectedToken(`Unexpected token ${str}`);
	}
	if (UNSUPPORTED_OPERATOR_TOKS.includes(str)) this.throwUnexpectedToken(`Unsupported token ${str}`);

	if (str.match(/[<>]/)) return {t:"r_op", r_op:str};
	return {t:"c_op", c_op:str};

}/*»*/
scanQuote(which, prev){/*«*/
	this.index++;
	let start = this.index;
	let src = this.source;
	let iter=0;
	let out = [which];
	let len = this.length;
	let cur = start;
	let is_ds_single = (which == "'") && prev == "$" && !prev.escaped;
	let ch = src[cur];
	while(ch && ch != which || (ch.escaped && ch != "'") || (ch.escaped && is_ds_single)){
		if (ch=="\n") {
			if (ALLOW_NEWLINES_IN_QUOTES) this.lineNumber++;
			else return null;
		}
		cur++;
		if (cur>=len) return null;
		out.push(ch);
		if (which==='"'&&ch==="$"&&src[cur]==="(") return "unsupported substitution pattern: '$('";
		ch = src[cur];
	}
	if (cur>=len) return null;
	this.index = cur;
	return out;
}/*»*/
scanWord(){/*«*/
	let start = this.index;
	let src = this.source;
//	let str='';
	let rv;
	let start_line_number = this.lineNumber;
	let start_line_start = this.lineStart;
	let word = [];
	while (!this.eof()) {
		let ch = src[this.index];
//		if (["'",'"','`'].includes(ch)){
		if (ch==="'"||ch==='"'||ch==='`'){
			if (this.index > 0) rv = this.scanQuote(ch, src[this.index-1]);
			else rv = this.scanQuote(ch);
			if (rv===null) this.throwUnexpectedToken(`Unterminated quote ${ch}`);
			else if (isStr(rv)) this.throwUnexpectedToken(rv);
			word.push(...rv);
		}
		else if (ch==="\\"){//Error condition (either known or unknown)
			let next = src[this.index+1];
			if (!next || next === "\n") this.throwUnexpectedToken("Unsupported line continuation");
//We should not get here because all other "naked" backslashes should either be 
//inside a quote or escaping something.
this.throwUnexpectedToken("Should not get here!?! (found a literal '\\' that never got used to escape the following character)");

		}
//		if (["\n","\r"," ","\t"].includes(ch)) break;
//		if (["\n"," ","\t"].includes(ch)) break;

		if (ch==="\n"||ch===" "||ch==="\t") break;
		if (OPERATOR_CHARS.includes(ch)) {
			if (UNSUPPORTED_OPERATOR_CHARS.includes(ch)) this.throwUnexpectedToken(`Unsupported token: ${ch}`);
			break;
		}
		this.index++;
//		if (ch.escaped) str+="\\"+ch;
//		else str+=ch;
		word.push(ch);
	}

	return {t:"word", word};
}/*»*/
scanNewlines(){/*«*/

	let start = this.index;
	let src = this.source;
	let str="";
	let iter=0;
	let start_line_number = this.lineNumber;
	let start_line_start = this.index;;
	while (src[start+iter]==="\n"){
		str+="\n";
		iter++;
	}
	this.index+=iter;
	this.lineStart = start_line_start+iter;
	this.lineNumber+=iter;
	return {t:"nl", nl:str};

}/*»*/

lex(){/*«*/

if (this.eof()) {//«
	return {
		type: EOF_Type,
		value: '',
		lineNumber: this.lineNumber,
		lineStart: this.lineStart,
		start: this.index,
		end: this.index
	};
}//»

let ch = this.source[this.index];
if (ch==="\n") return this.scanNewlines();
if (OPERATOR_CHARS.includes(ch)) {
	if (UNSUPPORTED_OPERATOR_CHARS.includes(ch)) this.throwUnexpectedToken(`Unsupported token: ${ch}`);
	return this.scanOperator();
}
return this.scanWord();

}/*»*/

};

//»
//Parser«

const Parser = class {

constructor(code, options={}) {//«
	this.errorHandler = new ErrorHandler();
	this.scanner = new Scanner(code, this.errorHandler);
	this.lookahead = {//«
		type: EOF_Type,
		value: '',
		lineNumber: this.scanner.lineNumber,
		lineStart: 0,
		start: 0,
		end: 0
	};//»
	this.hasLineTerminator = false;
	this.tokens = [];
	this.nextToken();
}//»

nextToken() {//«
	let token = this.lookahead;
	this.scanner.scanComments();
	let next = this.scanner.lex();
	this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
	this.lookahead = next;
	return token;
};//»

parse() {//«
	let chars = [];
	while (this.lookahead.type !== EOF_Type) {
		chars.push(this.lookahead);
		this.nextToken();
	}
	return chars;
};//»

};
//»

const parse = command_str => {//«


let escaped = escapes(command_str.split(""));

let parser = new Parser(escaped);
let toks;
try {
toks = parser.parse();
}
catch(e){
cerr(e);
return e.message;
}

//Collect commands with their arguments«
let com = [];
let coms = [];
for (let tok of toks){
	if (tok.c_op){
		if (!com.length) return `unexpected empty command (found: '${tok.c_op}')`;
		coms.push({com});
		com = [];
		coms.push(tok);
	}
	else{
		if (!com.length && tok===" "){}//Do not allow a command to begin with whitespace
//		else com.push(ds_single_quote_escapes(tok));
		else com.push(tok);
	}
}
if (com.length) coms.push({com});
//»
//Collect pipelines with their subsequent logic operators (if any)«
let pipes = [];
let pipe = [];
for (let i=0; i < coms.length; i++){
	let tok = coms[i];
	if (tok.c_op && tok.c_op != "|"){//Anything "higher order" than '|' ('&&', ';', etc) goes here
		if (tok.c_op==="&&"||tok.c_op==="||") {
			if (!coms[i+1]) return "malformed logic list";
			pipes.push({pipe, type: tok.c_op});
		}
		else {
			pipes.push({pipe}, tok);
		}
		pipe = [];
	}
	else if (!tok.c_op){//Commands and redirects
		pipe.push(tok);
	}
	else if (pipe.length && coms[i+1]){//noop: This token "must" be a '|'
	}
	else {
		return "malformed pipeline";
	}

}
if (pipe.length) pipes.push({pipe});
//»
//Collect ';' separated lists of pipelines+logic operators (if any)«
let statements=[];
let statement=[];
for (let tok of pipes){
	let cop = tok.c_op;
	if (cop) {
		if (cop==="&"||cop===";"){
			statements.push({statement, type: cop});
			statement = [];
		}
		else{
			return `unknown control operator: ${cop}`;
		}
	}
	else{
		statement.push(tok);
	}
}
if (statement.length) statements.push({statement});

//»

return statements;

};//»

return function(term){

this.cancelled_time = 0;

this.execute = async(command_str, opts={})=>{

const cancelled=()=>{//«
//Cancel test function
	return started_time < this.cancelled_time;
};//»

let started_time = (new Date).getTime();

//scriptPipeOut: when the command is in a script, at the end of a pipeline, but
//				 the script is itself in a pipeline. This is the next command-in-the-pipeline's 
//				 'pipeIn' function.
//commandSubOut: for command/backquote substitutions. Everything in the output 
//				 stream that would get printed to the terminal gets pushed into this array
const { scriptName, scriptArgs, scriptPipeOut, commandSubOut, env } = opts;

const sherr=mess=>{
	term.response(`sh: ${mess}`, {isErr: true});
	if (!scriptName) term.response_end();
};

let statements = parse(command_str);
if (isStr(statements)) {
	sherr(statements);
	return;
}

for (let state of statements){
let loglist = state.statement;

LOGLIST_LOOP: for (let i=0; i < loglist.length; i++){//«

let pipe = loglist[i];
let pipelist = pipe.pipe;
let pipetype = pipe.type;
let pipeline = [];

for (let j=0; j < pipelist.length ; j++){//«
let err, com, redir;
let arr = pipelist[j].com;

//For each word within a command, the shell processes <backslash>-escape«
//sequences inside dollar-single-quotes (See 2.2.4 Dollar-Single-Quotes)
for (let k=0; k < arr.length; k++){
	let tok = arr[k];
	if (tok.t==="word"){
		arr[k] = ds_single_quote_escapes(tok);
	}
}
//»

//and then performs various word expansions (see 2.6 Word Expansions ). «
/*2.6 Word Expansions«

This section describes the various expansions that are performed on words. Not
all expansions are performed on every word, as explained in the following
sections and elsewhere in this chapter. The expansions that are performed for a
given word shall be performed in the following order:

1) Tilde expansion (see 2.6.1 Tilde Expansion ), parameter expansion (see 2.6.2
Parameter Expansion ), command substitution (see 2.6.3 Command Substitution ),
and arithmetic expansion (see 2.6.4 Arithmetic Expansion ) shall be performed,
beginning to end. See item 5 in 2.3 Token Recognition .

2) Field splitting (see 2.6.5 Field Splitting ) shall be performed on the portions
of the fields generated by step 1.

3) Pathname expansion (see 2.6.6 Pathname Expansion ) shall be performed, unless
set -f is in effect.

4) Quote removal (see 2.6.7 Quote Removal ), if performed, shall always be
performed last.

Tilde expansions, parameter expansions, command substitutions, arithmetic
expansions, and quote removals that occur within a single word shall expand to
a single field, except as described below. The shell shall create multiple
fields or no fields from a single word only as a result of field splitting,
pathname expansion, or the following cases:

1) Parameter expansion of the special parameters '@' and '*', as described in
2.5.2 Special Parameters , can create multiple fields or no fields from a
single word.

2) When the expansion occurs in a context where field splitting will be performed,
a word that contains all of the following somewhere within it, before any
expansions are applied, in the order specified:

	a) an unquoted <left-curly-bracket> ('{') that is not immediately preceded by an
	unquoted <dollar-sign> ('$')

	b) one or more unquoted <comma> (',') characters or a sequence that consists of
	two adjacent <period> ('.') characters surrounded by other characters (which
	can also be <period> characters)

	c) an unquoted <right-curly-bracket> ('}')

may be subject to an additional implementation-defined form of expansion that
can create multiple fields from a single word. This expansion, if supported,
shall be applied before all the other word expansions are applied. The other
expansions shall then be applied to each field that results from this
expansion.

When the expansions in this section are performed other than in the context of
preparing a command for execution, they shall be carried out in the current
shell execution environment.

When expanding words for a command about to be executed, and the word will be
the command name or an argument to the command, the expansions shall be carried
out in the current shell execution environment. (The environment for the
command to be executed is unknown until the command word is known.)

When expanding the words in a command about to be executed that are used with
variable assignments or redirections, it is unspecified whether the expansions
are carried out in the current execution environment or in the environment of
the command about to be executed.

The '$' character is used to introduce parameter expansion, command
substitution, or arithmetic evaluation. If a '$' that is neither within
single-quotes nor escaped by a <backslash> is immediately followed by a
character that is not a <space>, not a <tab>, not a <newline>, and is not one
of the following:

- A numeric character
- The name of one of the special parameters (see 2.5.2 Special Parameters )
- A valid first character of a variable name
- A <left-curly-bracket> ('{')
- A <left-parenthesis>
- A single-quote

the result is unspecified. If a '$' that is neither within single-quotes nor
escaped by a <backslash> is immediately followed by a <space>, <tab>, or a
<newline>, or is not followed by any character, the '$' shall be treated as a
literal character.

»*/
/*«When we find a: 
1) '{' ? "," ? '}' (ignore embedded curlies or give a syntax error)
2) '{' \d .. \d '}'
3) '{' \[a-z] .. \[a-z] '}'
3) '{' \[A-Z] .. \[A-Z] '}'

Skip over quotes to look for unescaped '{' followed by the closest unescaped '}'
Collect everything inside.
If there is a strict '..' pattern, use it
Else if there is an internal unquoted (unescaped) comma, use it
Else, let it pass through

»*/

for (let k=0; k < arr.length; k++){//«

let tok = arr[k];
if (tok.t==="word") {
	let rv = curly_expansion(tok.word, 0);
	if (rv !== tok.word){
		let newtoks = [];
		for (let wrd of rv){
			newtoks.push({t:"word",word: wrd});
		}
		arr.splice(k, 1, ...newtoks);
		k--;//Need to revisit the original position, in case there are more expansions there
	}
}

}//»
for (let k=0; k < arr.length; k++){//«

let tok = arr[k];
if (tok.t==="word") {
	arr[k] = tilde_expansion(tok);
}

}//»
for (let k=0; k < arr.length; k++){//«

let tok = arr[k];
if (tok.t==="word") {
	let rv = parameter_expansion(tok);
	if (isStr(rv)) return sherr(rv);
	arr[k] = rv;
}

}//»


/*»*/

}//»

}//»

}
//log(statements);
if (DEBUG){
jlog(statements);
}
//log(command_str);


term.response_end();

};

};
})();
/*»*/

/*Let's make a command that gets a binary file and replaces one sequence (1+) of bytes«
with another sequence (1+). Let's call it "brep".

While doing this, I just needed to allow for Uint8Array's in the terminal's logic,
such as @KIUREUN. I'm not quite sure if the logic where there is concatenation
going on really works or even makes much "real world" sense. Also, in the places
where I make calls to write_to_redir, I had to check to see if the value was an
Uint8Array (otherwise, it is treated as a bunch of text lines to be joined). Maybe
I should do that checking stuff in the actual write_to_redir function call.

***NOW THIS MAKES SENSE***, WHEN I CONSIDER THE FACT THAT OUT_CB CAN BE CALLED
ARBITRARY NUMBERS OF TIMES (RATHER THAN THE "OLD" WAY OF MAKING THE OUTPUT BE
SIMPLY RETURNED AFTER THE COMMAND FINISHED). SO IF FOR SOME REASON YOU ARE
REPEATEDLY CALLING THE "OUT" CB WITH BINARY DATA, THEN DOING THIS CONCATENATION
MAKES SENSE. PERHAPS WE NEED A "BIN_OUT" METHOD, OR RATHER WE SHOULD (SOMEHOW)
"DECLARE" OUR COMMAND (PIPELINE???) TO BE BINARY, SO THAT SENDING *ANY* TEXTUAL
DATA WILL CAUSE AN ERROR.

»*/
/*11/14/24: I am mainly getting into the concept of the larger/"meta" structure«
of this file, given my interest in restarting shell development over and over and
over and over... . My main interest is to continue refactoring into more and more
understandable (i.e. objective, rather than algorithmic) constructs.
»*/

/*12/11/24 Now we are sitting with an ast in a new ShellProgram class's execute«
method (@KDRTIOP). Maybe we should just take a breather at this point (perhaps just till
the end of the day). It is now 11 am.

Other than doing the compound commands, there is really nothing different we
need to do, expect for stuff like making the word expansion process more
class-based (object-oriented).

I'm seriously thinking about creating an application that receives the ShellProgram
object, and offers all of the debugging/stepping options that you might want in order 
to understand the shell's dynamics.

»*/

/*To keep the integrity of this thing, I want _Parser.end() @SLKIURUJ to«
return(this.tokNum===this.numToks);
... rather than
return(this.tokNum>=this.numToks);

So we need to make sure that this.numToks is always set to: tokens.length.
So, whenever we do stuff like pushNewline, we need to update that variable,
like @LCMJHFUEM.

@DYUTYDHFK: Need to make 'isCommandStart' a property of individual tokens
»*/

/*12/5/24: An example of the weird case of Arrays vs Strings«
1) @WPRLKUT, we are calling make_sh_error_com(comword, `command not found`, com_env),
2) in that function @SPOIRUTM, we use to do:
	com.errorMessage = `sh: ${name}: ${mess}`;
...but at the out_cb (@WLKUIYDP), we do testing for isStr, without checking for
embedded newlines, so now we do:
	com.errorMessage = `sh: ${name}: ${mess}`.split("\n");
...in order to get the correct output in the terminal for the case when comword
has embedded newlines
»*/
/*12/4/24: At this late date, we still needed to add the line @DPORUTIH !!!«
»*/
/*12/2/24: Lexing and Parsing the Shell Command Language«
1) The lexer just spits out these tokens:
 - Words
 - Operators
 - Newline lists

The tricky part is a Word:

A sequence of non-whitespace separated:
 - Chars (plus Escaped Chars)
 - Substitutions ( $(...), $((...)) or ${...} )
 - Strings ( "...", $'...', '...' or `...` )
  ) Strings must be recorded faithfully as an array of Chars or Escaped Chars
  ) "...": 
   > can include embedded Substitutions and `...`
  ) `...`:
   > can include embedded Substitutions and Strings (expect itself)
   > all scans for embedded entities must end when an unescaped '`' is detected

To "be in the top-level" means that you are not inside of a String
 - at the appropriate point, top-level Strings can be turned into sequences of 
   Chars, Substitutions and Strings
 - there can be an 'unflatten' or 'objectify' class method to do this

»*/
/*11/30/24: Heredocs: Instead of passing a string into execute, perhaps we should«
pass in a object with a "scan for eof marker", in order to allow heredocs to be
collected.

We are passing in heredocScanner's in from the terminal's shell.execute call, and
the call in class ScriptCom.

We are not currently doing anything past tilde expansion for the redir words (including
herestrings),
and we are not currently expanding anything in the heredocs. So, the herestrings
themselves only get tilde expanded.
»*/
//11/27/24: We are silently skipping file glob patterns with slashes in them//«
//@EJUTIOPB, so only globs in the current directory will work.
//$ echo */* *
// -> */* [...all files in the current directory]

/*Also, we are using Old_curly_expansion, which does NOT do comma expansions, but
the new curly_expansion @QXDPOLIT DOES do them (but that one uses the newer 
parsing algorithm in the DevShell in /doc/dev/TERMINAL @SOTFKL).
*/

//»
/*11/26/24: No calls to com.out in the 'init' phase please!«
Migrate to the new 'class extends Com{...}' notation or get the error message @VKJEOKJ.
com.init is mainly for doing all the the async stuff that your command needs to work
(like loading modules), and also for checking the sanity of the particular combination
of arguments and options that are given to you. Outputting error messages (or other kinds
of messages like warning or info) is always okay because these always go to the terminal.
So we want to be sure that everyone in the pipeline is totally "ready to rumble" before 
any calls to com.out(...) are made.
»*/
/*11/25/24: New 'Com class{...}' and 'Com_whatever extends Com{...}'«

class Com {
	constructor(args, opts, _){
		this.args=args;
		this.opts=opts;
		for (k in _) {
			this[k]=_[k];
		}
	}
}

const Com_blah = class extends Com {

async init(){
//Parse the options
}
async run(){
}
pipeIn(val){
}

}

»*/

//«DevShell
const DevShell = (()=>{

//«Var

//Maybe quote these (depending on context)
// *  ?  [  ]  ^  -  !  #  ~  =  %  {  ,  }

//»

class Oper{//«
	#chars;
	constructor(){
		this.#chars="";
	}
	add(ch){
		let str = this.#chars + ch;
		if (OPERATOR_TOKS.includes(str)){
			this.#chars = str;
			return true;
		}
		return false;
	}
	get chars(){
		return this.#chars;
	}
	get isRedir(){
		return this.#chars[0]===">"|| this.#chars[0]==="<";
	}

}//»

class Word{//«
	#arr;
	constructor(){
		this.#arr=[];
	}
	add(val){
		this.#arr.push(val);
	}
}//»

//Return an array of Word's and Oper's
//There might be a start_i and a stopping condition (an end quote or paren)

//If 'typ' is undefined, we are in "free space"
//Otherwise, it is one of:
/*
- ' (no escaping)
- $'
- "
- $(
- ` (DO NOT flat scan for the final '`'. Set off a tokenizer with a halt_on_bq flag)
- ${
*/
const tokenize = (arr, start_i, typ) => {//«

let tok = null;//The current token
let out = [];//The array of tokens

for (let i=start_i; i < arr.length; i++) {

let ch=arr[i];
let ch1=arr[i+1];

/*«If the end of input is recognized, the current token (if any) shall be
delimited.
»*/

/*«If the previous character was used as part of an operator and the current
character is not quoted and can be used with the previous characters to form an
operator, it shall be used as part of that (operator) token.
»*/

if (tok instanceof Oper && tok.add(ch)){
	continue;
}

/*«If the previous character was used as part of an operator and the current
character cannot be used with the previous characters to form an operator, the
operator containing the previous character shall be delimited.
»*/

if (tok instanceof Oper){
	out.push(tok);
	tok = null;
}

/*«If the current character is an unquoted <backslash>, single-quote, or
double-quote or is the first character of an unquoted <dollar-sign>
single-quote sequence, it shall affect quoting for subsequent characters up to
the end of the quoted text. The rules for quoting are as described in 2.2
Quoting . During token recognition no substitutions shall be actually
performed, and the result token shall contain exactly the characters that
appear in the input unmodified, including any embedded or enclosing quotes or
substitution operators, between the start and the end of the quoted text. The
token shall not be delimited by the end of the quoted field.
»*/
if (ch==="\\") {
/*

By "escaping", we are just jumping over this character, and the either adding the next one to
the current word or starting a new word.

in free space:
  -Escape if an operator, quote or ds+[ ' ( { START_NAME_CHARS SPECIAL_SYMBOLS DECIMAL_CHARS_1_to_9 ]
  -Otherwise, skip this char
type==='"':
  -Escape if a '"'
*/

}
else if (ch==="'") {
//Scan for next "'" (no escapes)
}
else if (ch ==='"') {
// tokenize(arr, i+1, '"')
//	 - No "$'" will be done
}
else if(ch==="$" && ch1==="'"){
//Flat scan for next "'" (with escapes)

}
/*«If the current character is an unquoted '$' or '`', the shell shall identify
the start of any candidates for parameter expansion ( 2.6.2 Parameter Expansion
), command substitution ( 2.6.3 Command Substitution ), or arithmetic expansion
( 2.6.4 Arithmetic Expansion ) from their introductory unquoted character
sequences: '$' or "${", "$(" or '`', and "$((", respectively. The shell shall
read sufficient input to determine the end of the unit to be expanded (as
explained in the cited sections). While processing the characters, if instances
of expansions or quoting are found nested within the substitution, the shell
shall recursively process them in the manner specified for the construct that
is found. For "$(" and '`' only, if instances of io_here tokens are found
nested within the substitution, they shall be parsed according to the rules of
2.7.4 Here-Document ; if the terminating ')' or '`' of the substitution occurs
before the NEWLINE token marking the start of the here-document, the behavior
is unspecified. The characters found from the beginning of the substitution to
its end, allowing for any recursion necessary to recognize embedded constructs,
shall be included unmodified in the result token, including any embedded or
enclosing substitution operators or quotes. The token shall not be delimited by
the end of the substitution.
»*/
else if (ch==="$" && ch1==="(") {
// tokenize(arr, i+2, '$(')

}
else if (ch==="$" && ch1==="{") {
/*
Scan forward for a valid parameter (or #parameter), and the following possible chars
before doing: tokenize(arr, some_i, "${")

:- := :? :+ - = ? + % %% # ##

*/

}
else if (ch==="$" && START_NAME_CHARS.includes(ch[i+1])) {
//Param sub: scan forward until non-ANY_NAME_CHARS
}
else if (ch==="$" && SPECIAL_SYMBOLS.includes(ch[i+1])) {
//Symbol sub: Just grab this next char
}
else if (ch==="$" && DECIMAL_CHARS_1_to_9.includes(ch[i+1])) {
//Arg sub: Just grab this next char
}
else if (ch==="`") {
//Flat scan forward for the first unescaped "`"
}
/*«If the current character is not quoted and can be used as the first character
of a new operator, the current token (if any) shall be delimited. The current
character shall be used as the beginning of the next (operator) token.
»*/
else if (START_OPERATOR_CHARS.includes(ch)){
	if (tok) {
		out.push(tok);
	}
	tok = new Oper();
	if (!tok.add(ch)){
throw new Error(`Could not start the operator tok with: '${ch}' !?!?!?`);
	}
}
/*«If the current character is an unquoted <blank>, any token containing the
previous character is delimited and the current character shall be discarded.
»*/
else if (ch===" " || ch==="\t"){
	if (tok){
		out.push(tok);
		tok = null;
	}
	continue;
}
/*«If the previous character was part of a word, the current character shall be
appended to that word.
»*/
else if (tok instanceof Word){
	tok.add(ch);
}

/*«If the current character is a '#', it and all subsequent characters up to, but
excluding, the next <newline> shall be discarded as a comment. The <newline>
that ends the line is not considered part of the comment.
»*/
else if (ch==="#"){
//THis *would be* the start of a new word (since that is the default, else condition)
	while (arr[i+1] && arr[i+1]!=="\n") i++;
}

//The current character is used as the start of a new word.
	else{
		tok = new Word();
		tok.add(ch);
	}
}

return out;

};//»

return function(term){

//this.cancelled_time = 0;

this.cancelled = false;

this.execute = async(command_str, opts={})=>{

let started_time = (new Date).getTime();

const { interactive } = opts;

const sherr = mess => {//«
	term.response(`sh: ${mess}`, {isErr: true});
	if (!scriptName) term.response_end();
};//»

let tokens = tokenize(command_str.split(""), 0);
if (isStr(tokens)) {
	sherr(tokens);
	return;
}

if (DEBUG){
jlog(tokens);
}
//log(command_str);

term.response_end();

};

this.cancel=()=>{
	this.cancelled = true;
	let pipe = this.pipeline;
	if (!pipe) return;
	for (let com of pipe) com.cancel();
};

};
})();
/*»*/
//Expansions/Redirections«

//1) Environment variable substitution
//2) File globbing '*', '?' and character ranges [a-zA-Z0-9]
//3) Curly brace expansion:
//
//$ echo file{0..3}.txt
//file0.txt file1.txt file2.txt file3.txt
		rv = await all_expansions(arr, term, {script_name, script_args});
		if (this.cancelled) return;
		if (rv){
			term.response(rv, {isErr: true});
		}
//		let inpipe = pipelist.length;
//BBBBBBBBB
//- Turn quote objects into word objects
//- Single quotes that start with '$' look for internal escapes (currently only newline)
//- Backquotes are executed and replaced with the output
		for (let i=0; i < arr.length; i++){//«
			let tok = arr[i];
			let typ = tok.t;
			let val = tok[typ];
			if (typ==="quote") { 
				let typ = tok.quote_t;
				let ds = tok['$'];
				let outstr='';
				for (let ch of val){
					if (isObj(ch)&&ch.t=="esc"){
						if (ch.esc=="n"&&typ=="'"&&ds) outstr+="\n";
						else outstr+=ch.esc;
					}
					else outstr+=ch;
				}
				val = outstr;
				if (typ=="\x60") {
					let out=[];
//DJUYEKLMI
					await this.execute(val, {subLines: out});
					if (this.cancelled) return;
//jlog(out);
					if (!out.length) out = [""];
					let did_splice = false;
					for (let wrd of out){
						if (!did_splice) {
							arr.splice(i, 1, " ");
							did_splice = true;
						}
						arr.splice(i, 0, {t: "word", word: wrd}, " ");
						i+=2;
					}
				}
				else arr[i]={t:"word", word: val};
			}
		}//»

//All sequences of non-whitespace separated quotes and words are concatenated:
//~$ echo "q 1"A"q 2""q 3"B   "q 4"C"q       5"D"q 6"
//q 1Aq 2q 3B q 4Cq       5Dq 6
		for (let i=0; i < arr.length-1; i++){//«
			let tok0 = arr[i];
			let tok1 = arr[i+1];
			let tok0word = tok0.word||tok0.esc;
			let tok1word = tok1.word||tok1.esc;
			if (tok0word && tok1word){
//				arr[i] = {t: "word", word: `${tok0.word}${tok1.word}`, from_quote: true}
				arr[i] = {t: "word", word: `${tok0word}${tok1word}`};
				arr.splice(i+1, 1);
				i--;
			}
		}//»

//Concatenate all sequences of escaped spaces and words
// ~$ touch this\ is\ cool.txt
		for (let i=0; i < arr.length-1; i++){//«
			let tok0 = arr[i];
			let tok1 = arr[i+1];
			if (tok0.esc === " " || tok1.esc === " "){
				arr[i] = {t: "word", word: `${tok0.word||" "}${tok1.word||" "}`, esc: tok1.esc}
				arr.splice(i+1, 1);
				i--;
			}
		}//»

//- Create redirection objects
//- Objects are converted into strings ({t:"word", word: "blah"} -> "blah")

		for (let i=0; i < arr.length; i++){//«
			let tok = arr[i];
			let typ = tok.t;
			let val = tok[typ];
			if (tok===" "){
				continue;
			}
			if (typ==="r_op"){
				let rop = tok.r_op;
				if (!(rop==">"||rop==">>")) {
					return terr(`sh: unsupported operator: '${tok.r_op}'`);
				}
				let tok2 = arr[i+1];
				if (!tok2) return terr("sh: syntax error near unexpected token `newline'");
				if (tok2.t == "quote") tok2={t: "word", word: tok2.quote.join("")}
				if (tok2==" ") {
					i++;
					tok2 = arr[i+1];
				}
				if (!(tok2 && tok2.t==="word")) return terr(`sh: invalid or missing redirection operand`);
				arr.splice(i+1, 1);
				val = null;
				redir = [tok.r_op, tok2.word];
			}
			if (val) {
				args.push(val);
			}
		}//»

		arr = args;

//Set environment variables (exports to terminal's environment if there is nothing left)
		rv = add_to_env(arr, env, {term});
		if (rv.length) term.response(rv, {isErr: true});
		if (arr[0]==" ") arr.shift();

//»
/*
const com_help = async(args, opts, _)=>{//«
	let help = globals.shell_help;
	const {err, out}=_;
	if (!help){
		try{
			help = (await import("shell_help")).help_text;
		}catch(e){
			err("Could not load the help module");
			return E_ERR;
		}
		globals.shell_help = help;
	}
	let out = [];
	let nargs = args.length;
	if (!args.length) args = ["help"];
	while (args.length){
		if (out.length) out.push("");
		let which = args.shift();
		if (nargs > 1) out.push(`${which}:`);
		let txt = help[which];
		if (!txt) out.push("not found");
		else out.push(...txt.split("\n"));
	}
	return {out, pretty: true};
};//»
const com_termlines=(args,opts, _)=>{//«
	const {term, stdin, out, err} = _;
	let idstr = args.shift();
	if (!idstr) {
		err("No winid given");
		return E_ERR;
	}
	let id = idstr.ppi();
	if (isNaN(id)) {
		err("Invalid id: want a positive integer");
		return E_ERR;
	}
	let win = document.getElementById(`win_${id}`);
	if (!win) {
		err("No window with that id");
		return E_ERR;
	}
	if (win._winObj.appName!=="Terminal") {
		err("Not a terminal");
		return E_ERR;
	}
	out( win._winObj.app.lines);
	return E_SUC;
};//»
const com_hi = async(args, o)=>{//«
	const {term, opts} = o;
	if (term.ssh_server) return {out: "Ready to serve"};
	return {err: "Not connected"}
};//»
const com_ssh = async(args, o)=>{//«
//let server_response_cb;
const server_response=()=>{
	return new Promise((Y,N)=>{
		ws.server_response_cb = Y;
	});
};
const open_socket = () => {//«
return new Promise((Y,N)=>{
const WS_URL = 'wss://192.168.1.100:4443/';
cwarn(`Using WS_URL: ${WS_URL}`)
s = new WebSocket(WS_URL);
//s = new WebSocket('wss://192.168.0.98:4443/');

s.onclose=()=>{//«
cwarn("Socket closed!");
	if (is_client) {
		delete ws.client;
		delete term.ssh_client;
		delete term.ssh_immediate_mode;
	}
	else {
		delete ws.server;
		delete term.ssh_server;
		delete term.locked;
	}
	term.response("Socket closed");
	term.response_end();
};//»
s.onopen=(e)=>{//«
	if (is_client) {
		ws.client = s;
		term.ssh_client = s;
		if (opts.i) {
			term.ssh_immediate_mode = true;
			s.send("pwd");
		}
	}
	else {
		ws.server = s;
		term.ssh_server = s;
		term.locked = true;
	}
	Y();
};//»
s.onmessage=async(e)=>{//«
	let txt = await e.data.text();
	if (is_server){
		let out = [];
		let o = JSON.parse(txt);
		if (o.com) {
			let out = [];
			let err = [];
//			await term.shell.execute(o.com, {script_out: out});
			await term.shell.execute(o.com, {ssh_out: out, ssh_err: err});
			s.send(JSON.stringify({cwd: term.cur_dir, out: out.join("\n"), err: err.join("\n")}));
		}
		else if (o.tab){
			term.handle_tab(o.pos, o.com_arr);
		}
		else{
cwarn("Found non 'com' in server.onmessage...");
log(o);
		}
	}
	else{

		let o = JSON.parse(txt);
		if (o.cwd) {
			term.ssh_cwd = o.cwd;
			let use_cb;
			if (ws.server_response_cb) use_cb = ws.server_response_cb;
			else use_cb = term.response;
			if (o.err) use_cb(o.err.split("\n"));
			if (o.out) use_cb(o.out.split("\n"));
			if (ws.server_response_cb) delete ws.server_response_cb;
			else term.response_end();
		}
		else if (o.chars){
			let chars = o.chars;
			for (let c of chars) term.handle_letter_press(c);
		}
		else if (o.names){
			term.response_com_names(o.names);
		}
		else{
cwarn("What in client.onmessage...");
log(o);
		}
	
	}
};//»

});
};//»
const {term, opts} = o;

let s;
let is_client = opts.client||opts.c;
let is_server = opts.server||opts.s;
let do_close = opts.x;
let mess;
if (!globals.ws) globals.ws = {};
let ws = globals.ws;
if (!ws) return {err: "Not connected"}
if (!is_client && opts.i){
	if (!ws.client) return {err: "Not a client"}
	term.ssh_immediate_mode = true;
	return {out: "Immediate mode on"};
}
if (do_close) {//«
	if (ws.client) {
		ws.client.close();
		delete ws.client;
		return {out: "Client closed"};
	}
	if (ws.server) {
		ws.server.close();
		delete ws.server;
		return {out: "Server closed"};
	}
	return {err: "Nothing to close!"};
}//»
if (args.length){
	if (ws.client) {
		ws.client.send(args.join(" "));
		return {out: await server_response()};
	}
	return {err: "Nowhere to send to!"};
}
if (!(is_client||is_server)) return {err: "Need -s or -c specified"}
if (is_client) {//«
	if (ws.client) return {err: "Already a client"}
	if (ws.server) return {err: "Cannot connect as a client (already a server)"}
	mess="Client";
}
else {
	if (ws.server) return {err: "Already a server"}
	if (ws.client) return {err: "Cannot connect as a server (already a client)"}
	mess="Server";
}//»
await open_socket();
s.send(mess);
if (is_client) {
	if (opts.i){
		await sleep(100);
		s.send(JSON.stringify({com: "pwd"}));
		await server_response();
	}
	return {out: `The ssh client is up${opts.i?" (immediate mode)":""}`}
}
term.response(["The ssh server is up","(terminal locked)"]);
term.scroll_into_view();
term.refresh({noCursor: true});
await hang();

};//»
const com_meta = async(args, o)=>{//«
	let {term}=o;
	let {cwd} = term;
	let file = args.shift();
	if (!file) return {err: "No file"}
	let node = await file.toNode({cwd});
	if (!node) return {err: `${file}: not found`}
	let s = await node.text;
	if (!s) return {err: "No file text"}
	let rv;
	try {
		rv = eval(`(async()=>{${s}})()`);
	}
	catch(e){
cerr(e);
		return {err: e.message};
	}
	return rv;
};//»
const com_pokerruns = async(args, o)=>{//«
	let poker = globals.poker;
	if (!(poker&&poker.hole_cards)) return;
	let hands = poker.hole_cards;
	let text = JSON.stringify(hands);
	let node = await ("/home/me/.data/poker/all-in_trials.json".toNode());
	if (node){
		let rv = await node.setValue(text);
		if (rv && rv.size){
			return {out: `Saved: ${rv.size}`}
		}
	}
	return {out: text};
}//»
const com_pokerhands = async(args, o)=>{//«
	let poker = globals.poker;
	if (!(poker&&poker.hole_cards)) return;
	let hands = poker.hole_cards;
	let keys = Object.keys(hands);
	let arr = [];
	for (let k of keys){
		let o = {};
		o.hand = k;
		o.val = hands[k];
		arr.push(o);
	}
	let all = [];
	let sorted = arr.sort((_a,_b)=>{
		let a = _a.val;
		let b = _b.val;
		let aper = (a.w+a.t) / (a.w+a.l+a.t);
		let bper = (b.w+b.t) / (b.w+b.l+b.t);
		_a.per = aper;
		_b.per = bper;
		if (aper > bper) return -1;
		if (aper < bper) return 1;
		return 0;
	});
	let len = sorted.length;
	let out = {};
	arr = [];
	sorted.forEach((o, idx)=>{
		let per = ((len-idx)/len).toFixed(3);
		out[o.hand] = {rank: per, per: o.per.toFixed(3)};
		arr.push(`${idx}) ${o.hand} ${o.per.toFixed(3)}`);
	});
//log(arr);
	return {out: JSON.stringify(out)};
};//»
*/

/*@GYWJNFGHXP: Just started on a "solution" to the issue referenced on the Bug below.«

For now, we are doing replacements for open paren, open square brace and plus sign.
What about period, asterisk and question mark?


We now allow for the tab completion like:

$ cat 'Some (weird) f<TAB>

to become:

$ cat 'Some (weird) filename.txt'

But this also actually works when we are at the beginning:

$ 'Some (weird) f<TAB>

becomes:

$ 'Some (weird) filename.txt'

...this is *really* only supposed to search in the command pathway.

»*/
/*Bug found on Feb. 14, 2023://«

There seems to be an issue with commands that wrap around that have long
arguments (like filenames) with embedded spaces that are escaped. Say
the terminal is only like 40 chars wide:

$ ls /home/me/videos/This\ is\ a\ video\
with\ embedded\ spaces.mp4

There was actually a line break inserted here in the command history, probably
related to doing a tab completion that had to wrap around.

I want to implement tab completions that are inside of quotes (like bash does).
Given a file named "file with spaces.txt", doing:

$ cat 'file w<TAB>

...should complete to:

$ cat 'file with spaces.txt'

There needs to be some basic parsing done to ensure that this does not work,
i.e. there should be an odd number of non-escaped quotes.

$ cat ' 'file w<TAB>

//»*/
