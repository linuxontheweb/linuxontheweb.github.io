//Notes«
/*THIS IS ALL VERY SHITTY, SO JUST SPEND TIME THINKING ABOUT IT AND GETTING IT«
REASONABLY DEBUGGED, THEN DON'T FUCKING WORRY ABOUT THIS SHITTY ADVANCED FEATURE.

Very, very stupid hacks because of the idea of using vim to edit local
javascript files that are used for local app developement. There is a hotkey in
vim for reloading the app windows that are under development. First of all, vim
"owns" the app window by putting a "owned_by" member on it, so the window
cannot be closed (via mouse or desktop shortcut) or reloaded via the desktop's
Alt+r shortcut. Also, the window now has a reload method on it, which is passed
a callback (from vim.js @FJUSOP) that is called back with the new window object
(so that vim can have a handle to the new one, since the old one is lost). When
vim exits cleanly, it deletes the "owned_by" member, so that the window can
once more be independently closed/reloaded. The app window needs to be raised
to the top of the stack (as CWIN) in order to be reloaded, and then vim's terminal
window needs to be raised right after reloading.

How about an owned_by property?

»*/
/*The concept of local application development://«

1) We save to the local fs.
	a) Create a url via URL.createObjectURL (portable), using the text of the file
	b) Create a filesystem:// URL (Chrome only? Would Edge even allow this?)

»*/
/*Here's the situation: Whenever the icon cursor moves away from an icon«
on the desktop, the icon's label should hide the overflow of the name, so that only
one line is showing. Usually, the Window.on method will take care of this @VKUIOKL
(i.e. when cycling through the window stack). But when we are opening a window, the
newly created window is already occluding the desktop by the time this is called. So,
we added in the test @FRUTIOP in open_file_by_path, for whenever the path refers
to a folder window.
»*/
/*@HFYUIOTS: Don't understand why app.onfocus was called by desk_menu.kill_cb. That
messes up menu functions that call popups which call window.on, which calls app.onfocus.
*/
/*Maybe change certain desktop keydown functions from, e.g. m_ to the keypress "m", so
that toggling windows doesn't mean that the m press event gets sent to a window (like
the Terminal).
*/
/*3 simple changes to enable a (hopefully) seamless icon accounting experience«
(but it really currently only seems to apply to literally mv'ing icons between
desktop/folders). The idea is that there can be an arbitrary number of icons
for each node. These changes allows us to remove all icons from the display
(except for the one that is being handled by the mouse and controlled by the
gui) whenever an underlying node's location (parent directory) is being
changed. This means that we can "talk" directly to each icon's DOM elements
rather than, e.g. needing to search around for the parent folder windows and 
querying them for the icon with the given name.

1) In fs.js, added a .icons property to the Node constructor that points to an 
	empty array.
2) @CNJPLMYTY (at the end of the Icon constructor): We did node.icons.push(this)
3) @WMKFTYIOP1 (in move_icon_by_path)://«
	if (frompath !== topath){
		while (node.icons.length) node.icons.pop().del();
	}//»
4) But 3 was WRONG because it failed to allow for the graceful removal of those//«
icons that are being actively manipulated by the mouse user, causing them to
disappear from the interface while the animation moves them to their
destination folder. So, in fs.js, just before the move_icon_by_path function is
called (@MDEROPI), we do this:

	if (if_cp) {
		gotfrom = null;
	}
	else if (gotfrom !== gotto){
		let icons = fent.icons;
		while (icons.length) {
			let icn = icons.pop();
			if (icn === fromicon) {
				continue;
			}
			icn.del();
		}
	}

... where fent is just a dumb name for the node, and fromicon is whatever icon
is being manipulated in the gui.

So hopefully all relevant icons are being accounted for, and those
icons that are no longer relevant are being gracefully removed.
//»
5) But 4 was wrong because gotfrom and gotto included icons that were just
being renamed, so now have: @WMKFTYIOP2, just after all the non-moving icons
have been renamed...

...but what about the case in which the icons don't have permission to be moved
to wherever the user is trying to move them to?

»*/
//»
/*10/31/24« 

@SJNMYEJK we create a "fake" icon (in open_file_by_path), in order to feed into
open_icon_app (@WKIUTHJU), if it has a ".app" extension. The 'open' command
does it this way. Now I want vim to be able to call open_icon_app with a fake
icon that includes an object URL, created by URL.createObjectURL. After it does
this, it will have a handle on the given Window object, and should be able to
call reload on it with a new object URL. IMPORTANT: I WANT TO USE LOTW VIM TO
DEVELOP A SHELL COMMAND LANGUAGE PARSING ENGINE.

let fake = {
	winargs: opt.WINARGS,
	name: fname,
	path: (patharr.join("/")).regpath(true),
	fullpath: () => {
		return fullpath;
	}
};

But really, we just need to call open_app:

open_app(appname, {
	winArgs: icn.winargs,
	appArgs: obj.args,
	icon: icn,
	fsUrl: fsUrl(`/blobs/${node.blobId}`),
	winCb: win_cb
});

But instead of giving it an fsUrl, we want to give it a dataUrl, to work with
purely in-memory strings of text.

But *first*, the api.openApp interface needs to only take an opts object as
the second arg. This is also defined as Desk.open_app.

Need to make sure NOONE is calling Desk.open_app.

Now we can call api.openApp(appname,{force, winArgs, appArgs, dataUrl: ...}).

Let's get rid of the entire "fs_url/fsUrl" concept as a way to open an
application window. Instead, we can do the same thing with a dataUrl concept.
Then, it is just a matter of *where* we are getting the original Javascript
text string.  It can be either from somewhere in the filesystem or from the
lines of a text editor (or for that matter, from some other application's
in-memory data structures). Either way, we are doing URL.createObjectURL with
a new Blob([string_of_js_here]);

In vim, there is a reload_win arg. Just need to clean up all of the old/crusty 
mechanisms related to applications/windows/reloading...

So once I get this stuff working, I can develop the shell parser in it...

»*/
const win_reload = (cbarg) => { //«
	if (!globals.dev_mode) {
		popup(`win_reload: "dev mode" is not enabled!`);
		return;
	}
	let win = CWIN;
	if (!win) return;
	if (win.app.ondevreload) return win.app.ondevreload();
	let {is_fullscreen, fsholdw, fsholdh, fsholdx, fsholdy, bor_hold} = win;
	let {is_maxed, maxholdw, maxholdh, maxholdx, maxholdy} = win; 
	let winCb=(win)=>{//«
		if (is_maxed){
			win.is_maxed = true;
			win.maxholdw=maxholdw; 
			win.maxholdh=maxholdh; 
			win.maxholdx=maxholdx; 
			win.maxholdy=maxholdy;
			if (!fsholdw) win.set_max_dims();
		}
		if (is_fullscreen){
			win.is_fullscreen=true;
			win.fsholdw=fsholdw; 
			win.fsholdh=fsholdh; 
			win.fsholdx=fsholdx; 
			win.fsholdy=fsholdy;
			win.bor_hold=bor_hold;
			win.set_fullscreen_dims();
		}
		cbarg && cbarg(win);
	};//»
	let winargs = {
		WINTITLEIMG: win.img_div.childNodes[0],
		ID: win.id,
		X: win.winElem._x,
		Y: win.winElem._y,
		WID: win.main._w,
		HGT: win.main._h
	};
	let app = win.appName;
	let fs_url = win._fs_url;
	if (fs_url) app = `local.${app}`;
	let scr = gbid(`script_${app}`);
	if (scr) scr._del();
	delete LOTW.apps[app];

	let icn = win.icon;
	if (icn && !icn.path) icn=null;
	win.forceKill(true);
	let appobj = win.appobj||{};
	appobj.reInit = win.app.reInit;
	CWIN&&CWIN.off();
	if(!icn) {
		open_app((win._fs_url || win.appName), {winCb, force: true, winArgs: winargs, appArgs: appobj, fullpath: win.fullpath});
		return 
	}
	icn.winargs = winargs;
	open_icon(icn,{winCb});

};//»
const Icon = function(node, opts={}){//«
let {elem, observer, ref}=opts;

//Var«

let fullname = node.name;
let name = node.baseName;
let usenode = node;
let ext;
let ext_text;

let app;
let linkapp;
let islink=false;

if (node.link){
	islink = true;
	this.link = node.link;
	usenode = ref;
}

if (usenode && usenode.ext) {
	ext = usenode.ext.toLowerCase();
	if (TEXT_EXTENSIONS.includes(ext)) {
		ext_text = ext;
	}
}

if (node.kids) app=FOLDER_APP;
else if (node.appicon){
	try{
		app=JSON.parse(node.appicon).app;
		ext_text = "\u{2699}";
	}
	catch(e){cerr(e);};
}
else if (islink){
	app = ref.appName;
	islink = true;
}
else if (node.appName) app = node.appName;
else if (ext) {
	app = extToApp(ext);
}

if (!app) app = DEF_BIN_APP;

if (app=="Application"&&ref&&ref.appicon){
	try{linkapp=JSON.parse(node.ref.appicon).app;}
	catch(e){cerr(e);};
}

let isFolder = (app === FOLDER_APP) || (ref && ref.appName === FOLDER_APP);

//»

//DOM«

let d;
let icn = this;
if (elem) d = elem;
else {
	d = make("div");
	d.className="icon";
}
let iconelm = d;
d.iconElem = d;
d.icon = this;
d.innerHTML=`<span class="iconw"></span><div class="iconl"><div class="iconn"></div></div>`;

d._z=ICON_Z;

let wrapper = d.childNodes[0];
wrapper.draggable=true;
wrapper.iconElem=d;

//GJKLIUYT
//let img = wrapper.childNodes[0];
//img.iconElem = d;

let label = d.childNodes[1];
label._over="hidden";
let namesp = label.childNodes[0];
label.iconElem = d;
label.title = name;

//»

//Listeners«

if (!isFolder) {//«
	wrapper.ondragover=nopropdef;
	wrapper.ondrop=e=>{
		e.stopPropagation();
		e.preventDefault();
		popup("Cannot drop files onto non-folders!");
	};
}//»
else {//«
let didleave;
let isopen = false;
let in_transit = false;
let not_allowed = false;
let on = () => {//«
	isopen = true;
	wrapper.style.cursor = "copy";
	if (!CDL) return;
	CDL.into(icn.name); 
	icn.imgdiv.innerHTML = '\u{2009}\u{1f4c2}';
};//»
let off = () => {//«
	if (in_transit) return;
	not_allowed=false;
	isopen = false;
	iconelm.style.cursor = "";
	wrapper.style.cursor="";
	if (!CDL) return;
	CDL.reset();
	icn.imgdiv.innerHTML = '\u{1f4c1}';
};//»
wrapper.onmouseover = async e => {//«
	e.stopPropagation();
	if (!CDICN) return;
	if (CDICN === icn) return;
	let node = this.node;
	let typ = node.type;
	if (ref) {
		ref.type;
		node = ref;
	}
	if (CDICN.noMove || typ!==FS_TYPE || !fs.check_fs_dir_perm(node) || (CDICN.path === icn.linkfullpath) || (newPathIsBad(CDICN.fullpath, icn.linkfullpath + "/" + CDICN.name))) {
		not_allowed = true;
	}
	didleave = false;
	if (!CDICN) return;
	if (not_allowed) {
		CDL.nogo();
		wrapper.style.cursor = "not-allowed";
	}
	else if (!didleave) on();
};//»
wrapper.onmouseout = e => {//«
	off();
	if (CDICN === icn) return;
	e.stopPropagation();
	if (!CDICN) return;
	didleave = true;
};//»
wrapper.onmouseup = async e => {//«
	e.stopPropagation();
	if (CDICN) {
		icn.off(true);
		if (!ICONS.length) return;
		desk.style.cursor = "";
		if (not_allowed) {
			CDICN.shake();
		}
		if (!isopen) {
			CDICN = null;
			off();
			cldragimg();
			return;
		}
		let rect = iconelm._gbcr();
		in_transit = true;
		await move_icons(icn.fullpath, {loc:{X: rect.left, Y: rect.top}});
		in_transit = false;
		off();
		CWIN&&CWIN.off();
		if (icn.parWin !== desk) icn.parWin.on();
		CDICN = null;
		cldragimg();
		for (let icn of ICONS) icn.off();
		ICONS=[];
		if (icn.win) icn.win.app.reload();
		return;
	}
	if (DDIE) {
		DDIE = null;
		DDD._loc(-1, -1);
		DDD._w= 0;
		DDD._h = 0;
	}
	if (icn.parWin === desk) return;
	icn.parWin.clear_drag();
};//»
wrapper.ondragover=e=>{//«
	e.stopPropagation();
	e.preventDefault();
};//»
wrapper.ondrop=async e=>{//«
	e.stopPropagation();
	e.preventDefault();
	let win = await icn.openWin();
	await save_dropped_files(e, win);
};//»

}
//}//»
wrapper.ondragstart = e => {//«
	e.preventDefault();
	e.stopPropagation();
	if (globals.read_only) return;
	let par = iconelm.parentNode;
	CDICN = icn;
	CDL = make_cur_drag_img();
	if (par !== desk) par = par.parentNode; //Sad but true(for now):origins are always the mainwin,NOT topwin OR icon_div
	desk.style.cursor = "grabbing";
	CDL._loc(e.clientX + CDL_OFFSET - winw(), e.clientY + CDL_OFFSET - winy());
	desk._add(CDL);
};//»
wrapper.onmousedown = e => {//«
	e.stopPropagation();
	if (e.button != 0) return;
	let par = icn.parWin;
	if (par === desk) {
		CWIN&&CWIN.off();
	}
	else par.on();
//	if (e.ctrlKey&&ICONS.includes(icn)) icon_off(icn,true);
	if (e.ctrlKey&&ICONS.includes(icn)) icn.off(true);
	else if (!ICONS.includes(icn)) {
		if (!e.ctrlKey) icon_array_off(18);
//		icon_on(icn,true);
		icn.on(true);
	}
};//»
wrapper.onclick = e => {//«
	e.stopPropagation();
};//»
wrapper.oncontextmenu = e => {//«
if (isMobile) return;
if (!e.isFake) nopropdef(e);
if (have_window_cycle) return;
let menu = [//«
"Properties",()=>{show_node_props(node);},
"Rename", () => {
	setTimeout(() => {
		icn.nodelete = true;
		init_icon_editing(icn);
	}, 25);
}, 
"Delete", () => {delete_selected_files(icn);}
];//»
let open_opts=["Binary\xa0Viewer", ()=>{open_icon(icn,{useApp: DEF_BIN_APP});}];
if (icn.appName !== FOLDER_APP){
	if (TEXT_EXTENSIONS.includes(icn.ext)){
		open_opts.unshift(()=>{open_icon(icn,{useApp:TEXT_EDITOR_APP});});
		open_opts.unshift("Text\xa0Editor");
	}
	menu.unshift(open_opts);
	menu.unshift("Open\xa0with...");
}
set_context_menu({X:e.clientX,Y:e.clientY},{items:menu});

};//»
wrapper.ondblclick = e => {//«
	e.stopPropagation();
	icn.dblclick = true;
	open_icon(icn, {e: e});
};//»

//»
//Methods«

if (observer) {//«
	this.moveCb=()=>{
		observer.unobserve(d);
		delete this.moveCb;
	};
}//»
this.setImg=(namearg)=>{//«

	let ext_div="";
	if (usenode && usenode.ext) {
		ext = usenode.ext.toLowerCase();
		if (TEXT_EXTENSIONS.includes(ext)) {
			ext_text = ext;
		}
	}
	if (ext_text){
		ext_div = `<div class="iconext">${ext_text}</div>`;
	}
	let ch = getAppIcon(linkapp||this.appName,{html:true});
	wrapper.innerHTML=`${ext_div}<span class="iconi">${ch}</span>`;

};//»
this.del=()=>{//«
	if (!d.parentNode) return;
	this.clearFromStorage(null,1);
	d._del();
};//»
this.off = do_vacate => {//«
//	if (!(icn && icn.imgdiv)) return;
	if (do_vacate && ICONS.includes(icn)) ICONS.splice(ICONS.indexOf(icn), 1);
//	icn.iconElem._bor= "2px solid transparent";
	wrapper._bor="";
	icn.iconElem._bgcol="";
	label._bgcol="";
	namesp._bgcol="";
	label._tcol="";
	icn.isOn=false;
	if (icn.parWin!==desk) {
		if (ICONS.length===1) icn.parWin.app.stat(ICONS[0].fullname);
		else icn.parWin.app.stat(`${ICONS.length} selected`);
	}
}//»
this.on = do_add => {//«
	if (isMobile) return;
	let iconelm = icn.iconElem;
	if (do_add && !ICONS.includes(icn)) {
		if (ICONS.length && (icn.parWin !== ICONS[0].parWin)) icon_array_off(9);
		ICONS.push(icn);
	}
	wrapper._bor = "1px solid #ff0";
	label._bgcol="#bb0";
	label._tcol="#000";
	namesp._bgcol="#bb0";

	if (iconelm.parentNode === desk) {
		iconelm._bgcol= DESK_ICON_BG;
	}
	else {
		iconelm._bgcol= FOLDER_ICON_BG;
		if (ICONS.length===1) icn.parWin.app.stat(icn.fullname);
		else icn.parWin.app.stat(`${ICONS.length} selected`);
	}
	icn.isOn = true;
}//»
this.showLabelName=()=>{label._over="";};
this.hideLabelName=()=>{label._over="hidden";};
this.setLabelName = s =>{//«
	namesp.innerHTML="";
	if (s.length > MAX_ICON_NAME_LEN) s = s.slice(0, MAX_ICON_NAME_LEN)+"...";
	namesp.innerText = s.replace(/-/g, "\u{2011}");
};//»
this.updateDOMElement = namearg => {//«
	icn.clearFromStorage(null,0);
	let oldext = icn.ext||"";
	let name;
	if (app!==FOLDER_APP) {
		let arr = getNameExt(namearg);
		name = arr[0];
		icn.ext = arr[1]||"";
	}
	else name = namearg;
	this.setLabelName(name);

	d.dataset.name = namearg;
	icn.name = name;
	icn.label.title = name;

	icn.off();
	if (icn.appName == FOLDER_APP) {}
	else if (icn.ext.toLowerCase() != oldext.toLowerCase()) {
//«
		delete icn.wrapper;
//LCUITYEP
		icn.imgdiv.innerHTML = "";
		let newapp = extToApp(icn.ext.toLowerCase());
		if (!newapp) newapp = DEF_BIN_APP;
		icn.appName = newapp;
		this.setImg(namearg);
//		set_app_img(icn.imgdiv, newapp);
//»
	}
	icn.saveToStorage();

};//»
this.shake = () => {//«
	iconelm.style.animation = "shake 0.5s cubic-bezier(.36,.07,.19,.97)\x20both";
	iconelm.addEventListener("animationend", () => {
		iconelm.style.animation = "";
	});
};//»
this.clear = (patharg, which) =>{//«
	if (this.parWin !== desk) return;
	let path;
	if (patharg) path = patharg;
	else path = this.fullpath;
	let k =`${FS_PREF}:${path}`;
	if (!localStorage[k]) {
if (debug_localstorage) {
log(`Nothing found in localStorage[${k}]`);
}
return 
}
if (debug_localstorage) {
log(`Deleting: localStorage["${k}"]`);
}
	delete localStorage[`${k}`];
};//»
this.save = ()=>{//«
	if (globals.read_only) return;
	if (this.parWin!==desk) return;
	let k =`${FS_PREF}:${this.fullpath}`;
let verb;
	if (localStorage[k]) {
verb="Updating";
	}
	else{
verb="Setting";
	}
if (debug_localstorage) {
log(`${verb}: localStorage["${k}"]`);
}
	localStorage[k]=`${this.col} ${this.row}`;
};//»
this.setWindowName = (name) => {//«
	let win = this.win;
	if (!win) return;
	win.title = name;
	win.name = name;
}//»
this.addOverlay = () => {//«
	let oncontext = (e) => {
		e.preventDefault();
		e.stopPropagation();
		if (overdiv.context_menu) return;
		let canfunc = this.cancel_func;
		set_context_menu({
			X: e.clientX,
			Y: e.clientY
		}, {
			items: ["Stop File Transfer", canfunc]
		});
	};
	let overdiv = make('div');
	let rect = icn.iconElem.getBoundingClientRect();
	overdiv._w= rect.width;
	overdiv._h = rect.height;

	let od = overdiv;
	icn.overdiv = od;
	od._dis= "flex";
	od.style.alignItems = "center";
	od.style.justifyContent = "center";
	od.style.flexDirection = "column";
	od._bgcol= "#000";
	od._op= 0.66;
	od._tcol= "#fff";
	od._ta= "center";
	od._fs= 21;
	od._pos= "absolute";
	od._w="100%";
	od._h="100%";
	od._loc(0, 0);
	icn.iconElem._add(overdiv);
	icn.activate = () => {
		this.cancel_func = null;
		overdiv._del();
		delete icn.disabled;
	};
	overdiv.oncontextmenu = oncontext;
	return overdiv;
};
//»
this.openWin = ()=>{//«
	return new Promise((Y,N)=>{
		if (this.win) return Y(this.win);
		open_icon(icn, {winCb: Y});
	});
};//»
this.addLink = if_broken => {//«
	if (this.link_div) this.link_div._del();
	let l = make('div');
	this.link_div = l;
	wrapper._add(l);
	l._fs=14;
	l.innerHTML="\u{27a5}";
	l._padl=3;
	l._padr=3;
	l._bgcol="#000";
	if (if_broken) l._tcol="#f77";
	else l._tcol="#fff";
	l._pos= "absolute";
	l._r="0px";
	l._b="-5px";
};//»

//»
//Properties«

Object.defineProperty(this, "fullpath", {get:()=>{
	return this.node.fullpath;
}});
Object.defineProperty(this, "linkfullpath", {//«
	get: ()=>{
//		if (this.link) this.link.regpath();
		if (ref) return ref.fullpath;
		return this.node.fullpath;
	}
});//»
Object.defineProperty(this,"path",{get:function(){return this.node.path;}});
Object.defineProperty(this, "fullname", {get: function() {return this.node.name;}});

{
	let typ;
	if (ref) typ = ref.type;
	else typ = node.type;
	this.type = typ;
	if (typ!==FS_TYPE && app == FOLDER_APP){
		this.noMove = true;
	}
	else {
		this.noMove = false;
	}
}
this.node = node;
this.iconElem = d;
this.wrapper = wrapper;
//this.imgdiv = wrapper.childNodes[0];
this.name = name;
this.ext = ext;
this.appName = app;
this.label = namesp;
this.setImg(name);
//FKIOPIU
this.imgdiv = wrapper.childNodes[wrapper.children.length-1];
this.imgdiv.iconElem = d;


if (islink) {
	if (ref) {//«
		let arr = getNameExt(ref.name);
		this.linkName = arr[0];
		this.linkExt = arr[1];
		this.linkPath = ref.par.fullpath;
		this.ref = ref;
	}//»
	this.addLink(!ref);
}
//»
this.setLabelName(name);
//CNJPLMYTY
if (!node.fake) node.icons.push(this);

};
api.Icon = Icon;
//»
const Window = function(arg){//«

//Var«

	const thiswin = this;
	let app = arg.appName;
	let is_folder = app === FOLDER_APP;
	let winid;
	let marr;
//	let fs_url, data_url;

	let usex, usey, usew, useh;
	let winargs = arg.WINARGS||{};
	let defwinargs = get_newwin_obj();
	if (isFin(winargs.X)) usex = winargs.X;
	else usex = defwinargs.X;

	if (isFin(winargs.Y)) usey = winargs.Y;
	else usey = defwinargs.Y;

	if (isFin(winargs.WID)) usew = winargs.WID;
	else if (winargs.WID === "100%") usew = winw();
	else usew = defwinargs.WID;

	let botpad = winargs.BOTTOMPAD;
	if (isFin(winargs.HGT)) useh = winargs.HGT;
	else if (winargs.HGT === "100%") useh = winh();
	else {
		useh = defwinargs.HGT;
		if (botpad) useh -= botpad;
	}

	let wintitle;
	if (arg.name) wintitle = arg.name;
	else if (winargs.TITLE) wintitle = winargs.TITLE;
	else wintitle = "Untitled";

//This won't work when the local filesystem is no longer uses this
// kind of one-to-one mapping between files and the physically stored blobs

//Test for app.match(/filesystem:.+.js$/, and "slice out" the "app" name)
//	if (marr = app.match(/^filesystem:.+\/([a-z][a-z0-9]*)\.js$/i)){
//		fs_url = app;
//		app = `local.${marr[1]}`;
//	}
//log("ARG", arg);
//	if (arg.fsUrl){
//fs_url = arg.fsUrl;
//log("FSURL", fs_url);
//	}

//»

//DOM«

	let win = make("div");//The top level window«
	no_select(win);

//I guess this is here so the app name shows up in the Elements view of devtools
	win.dataset.app = app;
	win._pos= "fixed";
	win._bor= "1px solid #333";
	win.id = winargs.ID || `win_${++win_num}`;
	winid = win.id;
	win._x=usex;
	win._y=usey;
	win._z=HI_WIN_Z+1;
	win.className="topwin";
	win.style.boxShadow = window_boxshadow;
	win._winObj = this;
//»
	let main = make("div");//The application area«
	no_select(main);
	main.top = this;
	main.id = "main_"+winid;
	main._w=usew;
	main._h=useh;
	main._bgcol= APP_BG_COL;
	main._tcol= APP_TEXT_COL;
	main._bor= "0px solid transparent";
	main._pos= "relative";
	main.className="mainwin";
	main.type = "window";
//»
	let titlebar = make('div');//«
	titlebar.id="titlebar_"+winid;
	titlebar._h = 18;
	no_select(titlebar);
	titlebar.className = "titlebar";
	titlebar.win = win;
	main.titlebar = titlebar;
	main.appName = app;
	let title = make("div");
	title.id="title_"+winid;
	title._padt=1.25;
	title._ta= "center";
	title._pos= "relative";
	title._tcol= "black";
	title._ff= "sans-serif";
	titlebar._add(title);

	let namespan = make('span');
	namespan._dis="block";
	namespan.id="namespan_"+winid;
	namespan._fs= 12;
//	namespan._padt=1;
//	namespan._ff="monospace";
//	namespan.style.maxWidth = "100px";
//	namespan._over="hidden";
//log(namespan);
	namespan.title = winid;
	titlebar.label = namespan;
	title._add(namespan);
	main._over="hidden";

	let img_div = make('div');
	img_div._pos= "absolute";
	img_div._bor= "0px solid transparent";
	img_div._x= 0;
	img_div._y= 0;
	img_div._padb= 3;
	img_div.style.cursor = "default";

	img_div.draggable=true;
	img_div.ondragstart=nopropdef;

	img_div.onclick = ()=>{this.contextMenuOn()};
	title._add(img_div);
	let useimg = winargs.WINTITLEIMG;
	if (useimg) {
		img_div.img = useimg;
		img_div._add(useimg);
	}
	else set_app_img(img_div, app);
	img_div.id="titleimgdiv_"+winid;
	img_div._fs=12;
	img_div._tcol="#a7a7a7";
	img_div.title = app.split(".").pop();
//»
//«Min/Max/Close buttons

	const mkbut = (sz) => {//«
//	const mkbut = (col, sz) => {
		let b = make('div');
		b._over= "hidden";
		b._padl=b._padr=2;
		b._ta= "center";
		b._fs= sz;
		b._w= 16;
		b._h = 16;
		b._bor="1px solid #000";
		b._bgcol= WINBUT_OFF_COL;
		b.onmousedown=e=>{e.stopPropagation();};
		b.hover = () => {
			b._bgcol=WINBUT_ON_COL;
		};
		b.unhover = () => {
			b._bgcol=WINBUT_OFF_COL;
		};
		b.top = win;
		butdiv._add(b);
		return b;
	};//»
	const doclose = (force, if_dev_reload)=>{//«
//	const doclose = function(evt, thisarg, force, if_dev_reload) {

		if (this.isMinimized||this.isTiled) return;
		if (!force && (this != CWIN)) return;
		if (this.no_events) return;
		if (this.nobuttons && !force) return;
		if (this.app.onkill) this.app.onkill(if_dev_reload, force);
		OUTERLOOP2: for (let wins of workspaces) {
			for (let i = 0; i < wins.length; i++) {
				if (wins[i] == this) {
					wins.splice(i, 1);
					break OUTERLOOP2;
				}
			}
		}
		if (is_folder) icon_array_off(3);
		this.killed = true;
		this.app.killed = true;
		win._del();
		let icn = this.icon;
		let node = this.node;
		if (icn) {
			if (!node) node = icn.node;
			icn.win = null;
		}
		if (node && node.unlockFile) node.unlockFile();
		top_win_on();
	};//»
	const onhover=function(){//«
		if (CDL) return;
		butdiv._op= 1;
		this.hover();
	};//»
	const onunhover=function(){//«
		if (CDL) return;
		if (thiswin !== CWIN) butdiv._op=0.5;
		else butdiv._op= 0.75;
		this.unhover();
	};//»

	let butdiv = make('div');//«
	butdiv.style.cursor = "default";
	butdiv.off = () => {
		butdiv._op= 0.5;
	};
	butdiv.on = () => {
		butdiv._op= 0.75;
	};
	butdiv._pos= "absolute";
	butdiv._r= 3;
	butdiv._y= 0;
	butdiv._dis= "flex";
	butdiv.style.flexDirection = "row-reverse";
	butdiv._h = 16;
	butdiv._z=1000000;
	butdiv._tcol= "#000";
	butdiv.win = thiswin;
//»
	let close = mkbut("15px");//«
	close.id="closebut_"+winid;
	close.innerHTML="<b>X</b>";
	close.title="Close";
	close.style.lineHeight = "110%";
	butdiv.close = close;
	titlebar.close = close;
	this.easyKill=()=>{
//		doclose(null, close);
		doclose();
	}
	this.forceKill = if_dev_reload => {
		if (this.isMinimized) this.unminimize(true);
//		doclose(null, close, true, if_dev_reload);
		doclose(true, if_dev_reload);
	};
	close.onclick=()=>{
		if (check_cwin_owned()) return;
//		if (this._savecb) this._savecb();
		this.forceKill();
	}
	this.keyKill = () => {
		if (this.app && this.app.is_editing) {
			if (this.app.try_kill) this.app.try_kill();
			else cwarn("Dropping close signal");
		} 
		else {
//			doclose(null, close, true);
			doclose(true);
		}
	};
//»
	let max = mkbut("14px");//«
	max.id="maxbut_"+winid;
	max.style.lineHeight = "16px";
	max.reset=()=>{
		max.innerText="\u{1f5d6}";
		max.title="Maximize";
		win.style.boxShadow = window_boxshadow;
	};
	max.onclick = () => {
		close.unhover();
		max.unhover();
		min.unhover();
//		toggle_max_window(win);
//		maximize_window(thiswin);
		this.maximize();
	};
	max.reset();
//»
	let min = mkbut("14px");//«
	min.id="minbut_"+winid;
//	min.innerText="\u{1f5d5}"; 
	min.innerText="\u{2b07}"; //Solid down arrow
	min.style.lineHeight="135%";
	min.title="Minimize";
	min.onclick=()=>{
		if (this.isFullscreen) {
			if (thiswin!==CWIN) {
cwarn("thiswin!==CWIN ????");
				return;
			}
			this.fullscreen(true);
		}
		if (this.isMinimized||this.isTiled) return;
		if (ICONS.length && ICONS[0].parWin==this) icon_array_off();
		taskbar.addwin(thiswin);
	};
//»
//Button event listeners«
	close.draggable=max.draggable=min.draggable=true;
	close.ondragstart=max.ondragstart=min.ondragstart=(e)=>nopropdef;
	close.onmousedown=max.onmousedown=min.onmousedown=(e)=>{
		icon_array_off();
	}
	close.onmouseenter=onhover;
	close.onmouseleave=onunhover;
	max.onmouseenter=onhover;
	max.onmouseleave=onunhover;
	min.onmouseenter=onhover;
	min.onmouseleave=onunhover;
//»
	title._add(butdiv);

//»
	let footer = make('div');//«
	let footer_wrap=make('div');

//«
//The BOTTOMPAD property is ultimately given to us via a WINARG argument, so
//that, for example, from Desk.api.saveAs (@DWEUNFKL), a folder window can be
//opened up that has a Main window with a smaller height than normal (shrunken by
//the amount of SAVEAS_BOTTOM_HGT), so that buttons (like Save and Cancel) can be
//put on the bottom. The point is that this bottom area is considered to be part
//of the system's "window chrome" (like the titlebar), and the application
//doesn't have to worry about changing anything about the logic of it's own
//layout.
//»
	let bottom_div = make('div');
	if (botpad){
		bottom_div._bgcol="#373747";
		bottom_div._tcol="#ddd";
		bottom_div.style.borderTop="1px solid #556";
		bottom_div.style.borderBottom="1px solid #556";
		bottom_div._h=botpad-2;
		footer_wrap._add(bottom_div);
	}

	footer._dis="flex";
	footer.style.justifyContent="space-between";
	footer._h=18;
	let statdiv=make('div');
	statdiv.id="stat_"+winid;
	statdiv.onmousedown=e=>{
		e.stopPropagation();
		icon_array_off();
	};
	statdiv.onclick=noprop;
	statdiv.oncontextmenu=noprop;
	statdiv._tcol="#ddd";
	statdiv._fs=14;
	statdiv._padl=3;
	statdiv._padt=1;
	statdiv._over="hidden";
	let rsdiv = make('div');
	rsdiv.id="rsdiv_"+winid;
	rsdiv.win = thiswin;
	rsdiv.style.flex="0 0 15px";
	rsdiv._bgcol="#778";
	rsdiv._bor="2px inset #99a";
//	rsdiv._bor="1px solid #333";
	rsdiv.onmouseover=e=>{
		if (CDL) rsdiv.style.cursor = "";
		else rsdiv.style.cursor = "nwse-resize";
	};
	rsdiv.draggable=true;
	rsdiv.ondragstart=e=>{
		e.preventDefault();
		if (this.isMaxed) {
			max.reset();
			this.isMaxed = false;
		}
		CRW = thiswin;
		if (CRW != CWIN) CRW.on();
		desk.style.cursor = "nwse-resize";
	};
	statdiv.resize=()=>{statdiv.style.maxWidth = main._w - 20;};

	footer._add(statdiv);
	footer._add(rsdiv);
	footer_wrap._add(footer);
//»

	win._add(titlebar);
	win._add(main);
	win._add(footer_wrap);
	desk._add(win);
//»

//Properties«

Object.defineProperty(this, "fullpath", {//«
	get: ()=>{
		if (!this.name) {
//cwarn("This window has no name!!!");
			return null;
		}
		let path = (this.path ? this.path : "/") + "/" + this.name;
		if (this.ext) path = path + "." + this.ext;
		return path.regpath();
	}
});//»
Object.defineProperty(this, "title", {//«
	get: () => {
		return namespan.innerText.trim();
	},
	set: arg => {
		let str = arg;
		namespan.innerText = str;
		if (this.isMinimized) this.mintitle.innerText = str
	}
});//»

	this.Desk = Desk;
	this.Main = main;
	this.main = main;
	this.workspaceNum = current_workspace_num;
	this.bottom_div = bottom_div;
	this.statusBar = statdiv;
	this.rs_div = rsdiv;
	this.footer=footer_wrap;
	this.butdiv = butdiv;
	this.close_button = close;
	this.max_button = max;
	this.minimize_button = min;
	this.titlebar = titlebar;
	this.title_div = title;
	this.title = wintitle;
	this.winElem = win;
	this.app = {onresize:NOOP};
	this.appName = app;
	this.type = "window";
	this.id=winid;
	this.namespan = namespan;
	this.img_div = img_div;
	if (arg.APPARGS) this.nosave = true;
	else this.nosave = null;
	this.ownedBy = undefined;

//»
//Methods«

this.setWinArgs=args=>{//«
//	let args={BOTTOMPAD: w.bottompad, X: w.winElem._x, Y:w.winElem._y, WID: w.main._w, HGT: w.main._h};
	args.BOTTOMPAD = this.bottompad;
	args.X = win._x;
	args.Y = win._y;
	args.WID = main._w;
	args.HGT = main._h;
	if (this.isMaxed){
		args.isMaxed = true;
		args.holdDims={W: this.maxholdw, H: this.maxholdh, X: this.maxholdx, Y: this.maxholdy};
	}
	if (this.isFullscreen){
		args.isFullscreen = true;
		args.holdDims={W: this.fsHoldW, H: this.fsHoldH, X: this.fsHoldX, Y: this.fsHoldY, BOR: this.bor_hold};
	}
};//»
	this.makeScrollable=()=>{//«
		main._overy="auto";
		main.tabIndex="-1";
		this.isScrollable = true;
	};//»
	this.up=()=>{//«
		if (this.isMinimized) this.unminimize(true);
		win.style.zIndex = ++HI_WIN_Z;
		if (this.overdiv) this.overdiv.style.zIndex = ++HI_WIN_Z;
	};//»
	this.getIcons=()=>{//«
		let _icons = main.getElementsByClassName("icon");
		let ret = [];
		for (let icn of _icons) ret.push(icn.icon);
		return ret;
	};//»
	this.on = (which, if_no_zup) => {//«
//		if (this.killed) {
//cwarn("This window has been killed. Who is calling the 'on' method?");
//			return;
//		}
		if (!windows_showing) toggle_show_windows();
		if (CPR) return;
		if (CWIN) {
			if (this === CWIN) return;
			CWIN&&CWIN.off();
		}
		if (this.workspaceNum !== current_workspace_num) {
			switch_win_to_workspace(this, current_workspace_num);
			if (this.child_win){
				switch_win_to_workspace(this.child_win, current_workspace_num);
			}
		}
		if (is_folder && !this.isMinimized) {
//VKUIOKL
			if (CUR.curElem.parentNode === desk) {
				let icn = CUR.geticon();
				if (icn) icn.hideLabelName();
				desk.lastcurpos = CUR.getpos();
			}
			this.main.focus();
			CUR.icon_div = this.main.icon_div;
			CUR.main = this.main;
			this.main._add(CUR.curElem);
			this.cursor = CUR;
//			CUR.set(2);
			CUR.on();
		}
		this.winElem._dis= "block";
		if (if_no_zup){}
		else if (this.winElem._z && this.winElem._z < 10000000) this.up();
		
		if (!this.no_shadow) this.winElem.style.boxShadow = window_boxshadow;
		document.activeElement.blur();
		this.img_div._op= 0.75;
		this.namespan._fw = "bold";
		this.namespan._tcol= WINNAME_COL_ON;
		this.winElem._bgcol= WIN_COL_ON;
		if (this.butdiv) this.butdiv.on();
		if (this.movediv) this.movediv.on();
		let winobj = this.app;
		if (winobj) {
			if (winobj.onfocus&&!this.popup) {
				winobj.onfocus();
			}
		}
		else{
cwarn(`window_on(): NO WINOBJ for this`, this);
		}
		if (this.isScrollable) this.main.focus();
		if (this.isMinimized) this.taskbar_button.onmousedown();
		if (this.child_win) this.child_win.on();
		CWIN = this;
	};
	//»
	this.off = () => {//«
		if (is_folder) {
			delete this.cursor;
			this.cursor = null;
		}
		this.img_div._op= 0.5;
		this.namespan._fw = "";
		this.namespan._tcol= WINNAME_COL_OFF;
		this.winElem._bgcol = WIN_COL_OFF;
		if (this.butdiv) this.butdiv.off();
		if (this.movediv) this.movediv.off();
		if (this.area) {
			this.area.selectionEnd = this.area.selectionStart;
			this.area.blur();
		}
		this.winElem.style.boxShadow = "";
		if (this.app && this.app.onblur) this.app.onblur();
		if (this.isScrollable) this.main.blur();
		if (this === CWIN) CWIN = null;
		if (this.isMinimized) {
			this.taskbar_button.onmouseup();
			this.winElem._dis="none";
		}
	};
	//»
	this.setDefs = () => {//«
		if (isMobile) this.fullscreen(true);
		let a = this.app;
		a.winid = this.id;
		a.topwin = this;
		if (!a.onresize) a.onresize = NOOP;
		if (!a.onappinit) a.onappinit = NOOP;
		if (!a.onkill) a.onkill = NOOP;
		if (!a.onsave) a.onsave = NOOP;
		if (!a.onloadfile) a.onloadfile = NOOP;
		if (!a.onfocus) a.onfocus = NOOP;
		if (!a.onblur) a.onblur = NOOP;
		if (!a.onkeydown) a.onkeydown = NOOP;
		if (!a.onkeyup) a.onkeyup = NOOP;
		if (!a.onkeypress) a.onkeypress = NOOP;
		if (!a.get_context) a.get_context = ()=>{return [];}
	//	check_win_visible(this);

	};//»
	this.checkVisible=()=>{//«
		let rect = win.getBoundingClientRect();
		if (!rect) return;
		if ((rect.left > winw()) || (rect.right < 0) || (rect.top > winh()) || rect.bottom < 0) {
			cwarn("WINDOW IS OFFSCREEN... moving it to 0,0!");
			win._loc(0, 0);
		}
	};
	//»
	this.checkLoc = () => {//«
		let rect = win._gbcr();
		let w = rect.width,
			h = rect.height;
		let miny = 0;
		if (win._x < 0) {
			if (!win_overflow.left) win._x= 0;
			else if (win._x + w < 0) win._x += 2 * win_move_inc;
		} else if (win._x + w > winw()) {
			if (!win_overflow.right) win._x= winw() - w;
			else if (win._x > winw()) win._x -= 2 * win_move_inc;
		}
		if (win._y < miny) {
			if (!win_overflow.top) win._y= miny;
			else if (win._y + h < 0) win._y += 2 * win_move_inc;
		} else if (win._y > miny && win._y + h > winh()) {
			if (!win_overflow.bottom) {
				let usey = winh() - h;
				if (usey < miny) usey = miny;
				win._y= usey;
			} else if (win._y > winh()) win._y -= 2 * win_move_inc;
		}
	}//»
	this.checkSize = () => {//«

		let wid = main._w;
		if (wid < win.clientWidth){
			main._w = win.clientWidth;
		}
		else if (wid < min_win_width) {
			main._w = min_win_width;
		}
//		if (main._w < min_win_width) main._w= min_win_width;
		else if (win._x + win.clientWidth > winw()) {
			if (!win_overflow.right) main._w= winw() - win._x;
		}
		if (win._h < 1) win._h = 1;
		else if (win._y + win.clientHeight > winh()) {
			if (!win_overflow.bottom) {
				let menu_hgt = 0;
				let winfrills = this.titlebar._h + 15;
				let calc_hgt = winh() - win._y - winfrills - 3;
				if (calc_hgt < 1) calc_hgt = 1;
				main._h = calc_hgt;
			}
		}
	}//»
	this.addToResizeWins=()=>{//«
		if (!CRWINS) CRWINS=[];
		if (CRWINS.indexOf(this)<0) {
			CRWINS.push(this);
		}
	};//»
	this.set_fullscreen_dims=()=>{//«
		let usepl = 0;
		let usepr = 0;
		let pl = main._padl;
		let pr = main._padr;
		if (pl) usepl = pi(pl);
		if (pr) usepr = pi(pr);
		win._bor="";
		win._x= 0;
		if (this.noChromeMode) win._y=0;
		else win._y= "-" + (this.titlebar._h) + "px";
		main._w= winw() - usepl - usepr;
		main._h = winh(true);
	};//»
	this.fullscreen = (if_instant) => {//«
		if (this.isTransitioning) return;
		let transend = e => {
			win.style.transition = "";
			main.style.transition = "";
			this.statusBar.resize();
			this.app.onresize();
			if (this.movediv) this.movediv.update();
			win.removeEventListener('transitionend', transend);
			this.isTransitioning = null;
			delete this.isTransitioning;
		};
		if (this.isTiled || this.isMinimized) return;
		win.style.transition = `left ${WIN_TRANS_SECS},top ${WIN_TRANS_SECS}`;
		main.style.transition = `width ${WIN_TRANS_SECS},height ${WIN_TRANS_SECS}`;

		if (this.isFullscreen) {
			win._bor= this.bor_hold;
			delete this.bor_hold;
			win._x= this.fsHoldX;
			win._y= this.fsHoldY;
			main._w= this.fsHoldW;
			main._h = this.fsHoldH;
			this.isFullscreen = false;
		} else {
			this.fsHoldW = main._w;
			this.fsHoldH = main._h;
			this.fsHoldX = win._x;
			this.fsHoldY = win._y;
			this.bor_hold = win._bor;
			this.set_fullscreen_dims();
			this.isFullscreen = true;
		}

		if (if_instant) transend();
		else {
			this.isTransitioning = true;
			win.addEventListener('transitionend', transend);
		}

	}//»
	this.set_max_dims = ()=>{//«
		let usepl = 0;
		let usepr = 0;
		let pl = main._padl;
		let pr = main._padr;
		if (pl) usepl = pi(pl);
		if (pr) usepr = pi(pr);
		win._loc(1,0);
		main.style.width = winw() - usepl - usepr - 2 + "px";
		main.style.height = winh() - this.titlebar._gbcr().height - this.footer._gbcr().height + "px";
		win.style.boxShadow = "";
		max.innerText="\u{1f5d7}";
		max.title="Unmaximize";
	};//»
	this.maximize = (if_instant) => {//«
		if (this.isTiled||this.isTransitioning||this.isMinimized||this.isFullscreen) return;
		let transend = e =>{
			win.style.transition = "";
			main.style.transition = "";
			this.statusBar.resize();
			this.app.onresize();
			win.removeEventListener('transitionend', transend);
			this.isTransitioning = null;
			delete this.isTransitioning;
		};
		win.style.transition = `left ${WIN_TRANS_SECS}, top ${WIN_TRANS_SECS}`;
		main.style.transition = `width ${WIN_TRANS_SECS}, height ${WIN_TRANS_SECS}`;
		let max = this.max_button;
		if (!this.isMaxed) {
			this.maxholdw = main._w;
			this.maxholdh = main._h;
			this.maxholdx = win._x;
			this.maxholdy = win._y;
			this.isMaxed = true;
			this.set_max_dims();
		} else {
			this.isMaxed = false;
			main._w = this.maxholdw;
			main._h = this.maxholdh;
			win._x= this.maxholdx;
			win._y= this.maxholdy;
			win.style.boxShadow = window_boxshadow;
			max.innerText="\u{1f5d6}";
			max.title="Maximize";
		}
		if (if_instant) transend();
		else {
			this.isTransitioning = true;
			win.addEventListener('transitionend', transend);
//			this.isTransitioning = true;
//			win.addEventListener('transitionend', transend);
		}
	};//»
	this.minimize=()=>{this.minimize_button.click();};
	this.close=()=>{this.keyKill();}
	this.toggleLayout=(if_set)=>{//«
		let get_cursor = (e, rect) => {//«
			let lr_pad = rect.width * 0.25;
			let tb_pad = rect.height * 0.25;
			let lhit = false;
			let rhit = false;
			let thit = false;
			let bhit = false;
			let ret;
			if (e.clientX < rect.left + lr_pad) lhit = true;
			else if (e.clientX > rect.right - lr_pad) rhit = true;
			if (e.clientY < rect.top + tb_pad) thit = true;
			else if (e.clientY > rect.bottom - tb_pad) bhit = true;;
			if (rhit && bhit) ret = ["nwse-resize", "se"];
			else if (lhit && thit) ret = ["nwse-resize", "nw"];
			else if (rhit && thit) ret = ["nesw-resize", "ne"];
			else if (lhit && bhit) ret = ["nesw-resize", "sw"];
			else if (rhit) ret = ["ew-resize", "e"];
			else if (lhit) ret = ["ew-resize", "w"];
			else if (thit) ret = ["ns-resize", "n"];
			else if (bhit) ret = ["ns-resize", "s"];
			else ret = ["move"];
	//log(ret);
			if (this.isTiled) {
				if (ret[0][2]!=="-"||num_tiled_wins>MAX_TILED_WINS_FOR_RESIZING) return [""];

	//Comment this to allow the more difficult case of north and west resizing...
	//			if (ret[1]=="w"||ret[1]=="n") return [""];

	//Need to figure out if this is an interior edge.

				if ((lhit && rect.left <= 0)||
					(thit && rect.top <= 0)||
					(rhit && rect.right + 3 > winw())||
					(bhit && rect.bottom + 3 > winh())) return[""];

	//				if (bhit && rect.top > 0) return [""];

			}
			return ret;
		};//»

		let mkhandle = (wid, hgt, x, y) => {//«
			let div = make('div');
			div._bor= "1px solid black";
			div._pos= "absolute";
			div._w= wid;
			div._h = hgt;
			if (x) div._x= 0;
			else div._r= 0;
			if (y) div._y= 0;
			else div._b= 0;
			odiv._add(div);
		};//»

		if (this.isLayout) {
			desk.style.cursor = "default";
			this.movediv._del();
			delete this.movediv;
			delete this.rs_dir;
			this.isLayout = false;
			return;
		}
		let odiv;
		let dsty = document.body.style;
		let rect = win.getBoundingClientRect();
		odiv = make('div');
		let osty = odiv.style;
		odiv._pos= "absolute";
		odiv._w= rect.width;
		odiv._h = rect.height; 
		odiv._x= 0;
		odiv._y= 0;
		odiv._z= 10000000;
		odiv.class = "titlebar";
		odiv.win = this;
		odiv.onmousemove = (e) => {
			if (CDICN || CRW) return;
	//		if (this.isLayout) return;
			osty.cursor = get_cursor(e, odiv.getBoundingClientRect())[0];
		};

		odiv.oncontextmenu = nopropdef;

		odiv.onmousedown = (e) => {//«
			e.stopPropagation();
			if (this != CWIN) this.on();
			let arr = get_cursor(e, odiv.getBoundingClientRect());
			let sty = arr[0];
			osty.cursor = sty;
			if (this.isTiled) {
			if (!sty) return;

//	Once we figure out the logic of how to resize the other windows that are 
//	being overlapped, then we can comment out this.
			}
			if (sty == "move") {
				CDW = this;
				DDX = e.clientX - pi(win.offsetLeft);
				DDY = e.clientY - pi(win.offsetTop);
				return;
			}
			CRW = this;
	//log(CRW);
			CRW.startx = e.clientX;
			CRW.starty = e.clientY;
			CRW.startw = this.main._w;
			CRW.starth = this.main._h;
			CRW.rs_dir = arr[1];
			CRW.startl = win._x;
			CRW.startt = win._y;
		};//»
		odiv.onmouseup = e => {//«
			update_and_clear_resize_wins();
			CDW = null
		};//»
		odiv.update = () => {//«
			let rect = win._gbcr();
			odiv._w= rect.width;
			odiv._h = rect.height;
			statdiv.innerHTML = Math.round(rect.width) + "x" + Math.round(rect.height) + "+" + Math.round(rect.left) + "+" + Math.round(rect.top);
		};//»
		odiv.on=()=>{
			statdiv._tcol= "#ccc";
			odiv._bgcol= "rgba(224,224,224,0.4)";
		};
		odiv.off=()=>{
			statdiv._tcol= "#999";
			odiv._bgcol= "rgba(176,176,176,0.4)";
		};
		win._add(odiv);
		this.movediv = odiv;
		let statdiv = make('div');
		statdiv._bgcol= "#000";
		statdiv._fs= 21;
		statdiv.vcenter();
		statdiv._ta= "center";
		statdiv._over="hidden";
		odiv._add(statdiv);
		odiv.update();
		mkhandle("100%", "25%", 1, 1);
		mkhandle("100%", "25%", 1, 0);
		mkhandle("25%", "100%", 1, 1);
		mkhandle("25%", "100%", 0, 1);
		this.isLayout = true;
		if (CWIN == this) odiv.on();
		else odiv.off();


	};//»
	this.toggleChrome = () => {//«
		if (this.isFullscreen || this.isMaxed || this.isMinimized) return;
		this.noChromeMode = !this.noChromeMode;
		let bar = this.titlebar;
		let foot = this.footer;
		let m = main;
		if (this.noChromeMode) {
			let h = bar._gbcr().height + foot._gbcr().height;
			this.bor_hold = this._bor;
			this._bor= "";
			m.diff_h = h;
			bar._dis= "none";
			foot._dis= "none";
			m._h += h;

		} else {
			bar._dis= "block";
			foot._dis= "";
			this._bor= this.bor_hold;
			delete this.bor_hold;
			m._h -= m.diff_h;
		}
		this.statusBar.resize();
		this.app.onresize();
		return true;
	}//»
this.selectIcons = () =>{//«
//let drag_div = this.dragDiv;
let drect = this.dragDiv.getBoundingClientRect();
let dr = drect.right;
let dl = drect.left;
let dt = drect.top;
let db = drect.bottom;
let OK=[];

let icons = this.getIcons();

for (let icn of icons) {
	let wrap = icn.wrapper;
	if (!wrap) continue;
	let rect = wrap.getBoundingClientRect();
	if (rect.left > dr || rect.right < dl || rect.top > db || rect.bottom < dt) {
		icn.off();
	}
	else {
		OK.push(icn);
//		icon_on(icn);
		icn.on();
	}
	
}
ICONS = OK;
};//»
this.reload = (opts={})=>{//«
	if (this.killed){
		poperr("This window has been killed");
		return;
	}
	if (this.app.actor && this.app.actor.ondevreload) return this.app.actor.ondevreload();
	if (this.app.ondevreload) return this.app.ondevreload();
	if (app.match(/^local\./)&&!opts.dataUrl){
		return popup("'local' (development) applications cannot be independently reloaded!");
	}
	main.innerHTML=`<center><h2 style="background-color: #000; color: #aaa;">Reloading...</h2></center>`;
	statdiv.innerHTML="";
	let scr = gbid(`script_${app}`);
	if (scr) {
		scr._del();
	}
	else{
cwarn(`No script found for app: ${app}`);
	}
	delete LOTW.apps[app];

	this.app.onkill&&this.app.onkill(true);
	let arg = this.app.arg;
	arg.APPARGS = {reInit: this.app.reInit};
	arg.noShow = opts.noShow;
	arg.dataUrl = opts.dataUrl;
	return new Promise((Y,N)=>{
		arg.CB = Y;
		main.innerHTML="";
		make_app(arg);
	});
};//»

//»
//Event listeners«

	if (is_folder) {//«
		let didleave;
		const clear_drag = () => {//«
			WDIE = null;
			let dd = this.dragDiv;
			dd._loc(-1, -1);
			dd._w = 0;
			dd._h = 0;
		};//»
		const nogo=()=>{//«
			if (!CDL) return;
			CDL.nogo();
			main.style.cursor = "not-allowed";
		};//»
		const on = () => {//«
			if (!CDL) return;
			main.style.cursor = "copy";
			CDL.into(this.name);
		};//»
		const off = () => {//«
			main.style.cursor = "";
			if (CDL) CDL.reset();
		};//»
		main.onmousedown=e=>{//«
			e.stopPropagation();
			icon_array_off(20);
			if (e.clientX < win.offsetLeft + main.clientWidth + winx() && e.clientY < win.offsetTop + main.clientHeight + this.titlebar._h + winy()) {
				this.on();
				WDIE = e;
				WDIE.scrtop = main.scrollTop;
				WDIE.scrleft = main.scrollLeft;
				let gotw = main.scrollWidth - (e.clientX - win.offsetLeft + main.scrollLeft);
				WDIE._maxWidth = gotw - 1 + winw();
			}
			if (CWIN == this) return;
			CWIN&&CWIN.off();
			this.on();
		};//»
		main.onmouseover=async e=>{//«
			e.stopPropagation();
			if (CDICN){
				let thispath = this.fullpath;
				if (CDICN.path === thispath) return nogo();
				if (!await fsapi.checkDirPerm(thispath)||(newPathIsBad(CDICN.fullpath, `${thispath}/${CDICN.node.name}`))) return nogo();
				didleave = false;
				if (!CDICN) return;
				if (!didleave) on();
			}
		};//»
		main.onmouseout=e=>{//«
			e.stopPropagation();
			off();
			if (CDICN) {
				didleave = true;
			}
		};//»
		main.onmouseup=async e=>{//«
			e.stopPropagation();
			if (CDICN){
				desk.style.cursor = "";
				await move_icons(this.fullpath, {e, win: this});
				off();
				CWIN&&CWIN.off();
				CDICN = null;
				cldragimg();
			}
			else {
				CRW = null;
				CRWINS = null;
				CDW = null;
				clear_drag();
			}
		};//»
		main.ondrop=e=>{//«
			e.stopPropagation();
			e.preventDefault();
			save_dropped_files(e, this);
		};//»
		main.onmouseleave=e=>{clear_drag();};
		main.ondragover=e=>{};
		this.clear_drag = clear_drag;
		win.onmouseover=noprop;
		win.onmouseout=noprop;
	}//»
	else{//«
		main.onmouseup=e=>{
			CRW = null;
			CRWINS = null;
			CDW = null;
		};
		main.ondrop=e=>{
cwarn("No drop on main window");
		};
		win.onmouseover=()=>{
			if (!CDL) return;
			CDL.nogo();
			win.style.cursor = "not-allowed";
			main.style.cursor = "not-allowed";
		};
		win.onmouseout=()=>{
			if (!CDL) return;
			CDL.reset();
			win.style.cursor = "";
			main.style.cursor = "";
		};
	}//»
	title.ael('mouseover',()=>{body.style.cursor="default";});
	titlebar.onmouseover=e=>{//«
		if (CDL) titlebar.style.cursor = "";
		else titlebar.style.cursor = "move";
	};//»
	titlebar.oncontextmenu = nopropdef;
	titlebar.draggable=true;
	titlebar.ondragstart=e=>{//«
		e.preventDefault();
//		if (this.isMaxed) this.max_button.reset();
		if (this.isMaxed) return;
		win.style.boxShadow = "";
		CDW = thiswin;
		DDX = e.clientX - pi(win.offsetLeft);
		DDY = e.clientY - pi(win.offsetTop);
	};//»
	main.oncontextmenu = e => {//«
//		if (isMobile) return;
		e.preventDefault();
		e.stopPropagation();
//		if (have_window_cycle) return;
//		if (!cmenu_active) return;
//		if (this.contextMenuOn) this.contextMenuOn(e);
	};//»
	win.ondrop = e => {//«
		e.stopPropagation();
		e.preventDefault();
	};//»
	win.onclick=noprop;
	win.ondblclick=noprop;
	win.onmousedown=e=>{//«
		e.stopPropagation();
		icon_array_off(21);
		this.on();
	};//»
	win.ondrop = nopropdef;
	win.ondragover = nopropdef;
//{//Touch scrolling of "main" div«
//	let tch1;
//	let scrt1;
//	main.addEventListener('touchstart', e => {
//		if (tch1) return;
//		scrt1 = main.scrollTop;
//		tch1 = e.touches[0];
//	});
//	main.addEventListener('touchmove', e =>{
//		if (!tch1) return;
//		let t = e.changedTouches[0];
//		let dy = tch1.pageY - t.pageY;
//		main.scrollTop = scrt1 + dy;
//	});
//	main.addEventListener('touchend', ()=>{
//		tch1 = null;
//	});
//
//}//»
//»
//Context menu«
	this.contextMenuOn = (e) => {
		if (!this.app.get_context) return;
		let items = this.app.get_context();
		if (!items) items = [];
		items.push("Switch\xa0to\xa0workspace");
		let choices = [];
		for (let i=0; i < num_workspaces; i++){
			if (i!=current_workspace_num){
				choices.push(`${i+1}`);
				choices.push(()=>{
					if (windows.layout_mode) toggle_layout_mode();
					switch_win_to_workspace(this, i);
					this.off();
					this.winElem._dis="none";
					top_win_on();
				});
			}
		}
		items.push(choices);
		items.push(`Window ${winid.replace(/^win_/,"")} properties...`, ()=>{
			let rect = win._gbcr();
			let str = Math.round(rect.width) + "x" + Math.round(rect.height) + "+" + Math.round(rect.left) + "+" + Math.round(rect.top);
			popup(str);
		});
//		items.push(`Window id: ${winid.replace(/^win_/,"")}`, null);
		CG.on();
		let op_hold = img_div._op;
		let usex,usey;
		if (e) {
			usex = e.clientX;
			usey = e.clientY;
		}
		else{
			img_div._bgcol= "#fff";
			img_div._tcol= "#000";
			img_div._op=1;
			let rect = win._gbcr();
			usex = rect.left;
			usey = rect.top+this.titlebar._h;
		}
		set_context_menu({X:usex,Y:usey},{items: items});
		desk_menu.kill_cb = () => {
			img_div._op=op_hold;
			img_div._bgcol= "";
			img_div._tcol="#a7a7a7";
//HFYUIOTS
//			if (this.app&&this.app.onfocus) {
//				setTimeout(this.app.onfocus,50);
//			}
		};
	};//»

//Make app«

	arg.topwin = this;
//	arg.FS_URL = fs_url;
	if (arg.SAVER) {
		this.bottompad = botpad;
		this.saver = arg.SAVER;
		arg.SAVER.folderCb(this);
	}
	make_app(arg);
	windows.push(this);

	if (winargs.isMaxed){
		max.innerText="\u{1f5d7}";
		this.isMaxed = true;
		let dims = winargs.holdDims;
		this.maxholdx=dims.X;
		this.maxholdy=dims.Y;
		this.maxholdw=dims.W;
		this.maxholdh=dims.H;
	}
	if (winargs.isFullscreen){
		this.isFullscreen = true;
		let dims = winargs.holdDims;
		this.fsHoldX=dims.X;
		this.fsHoldY=dims.Y;
		this.fsHoldW=dims.W;
		this.fsHoldH=dims.H;
	}
//»

}
//»
/*1/29/24: Shouldn't Win.childWin more appropriately be Win.childWins? «
Whichever workspace the parent window goes to, its childWins should follow.
We're not allowing "ownedBy" windows to have the ability to invoke switch_to_workspace
from within its context menu (see @GSKRBSJTK).
»*/
/*1/1/24:« Just looking at the whole api.saveAs Workflow, from Initialization
@DWEUNFKL to:
1) Cancel
2) Success

Let's look into Window.onkill, and giving it options, in order to know when it is in
1) Window.reload @DEKLKSMD
2) window.onbeforeunload @SMKLDKSF

Also, when doing the saveAs workflow, we need the Folder to list the files of the
same type (e.g. .txt), **AS WELL AS** the subfolders. The question is, when it comes to one
of the icons of our same type, what do we do upon "selecting" it? 

Upon clicking it: we put the name into the textarea.
Upon double-clicking, we put the name in the textarea AND click the SAVE button.

EITHER WAY: THIS OPERATION WILL FAIL (UNLESS AN EXPLICIT NUCLEAR_OPTION IS SET).

»*/
/*12/22/24: Just doing a simple desktop icon toggling routine.«

I'm pretty sure that all icons that are being added to the desktop *MUST*
got through placeInIconSlot, so I'm cutting everything off about icon
visibility for newly created desktop icons @LCIUDHJ.

So now each workspace can define what it wants for the background color
and image just by updating the body element for color (solid or gradient)
and updating the desk_imgdiv with the image url.

The body is what has the color and desk_imgdiv has the image.

toggle_icon_display @XKNFIUHJ is my working prototype for doing the kind of
changing of desktop styles when switching to different workspaces that I have
in mind.


Need to finish up tile_windows, and allow for Workspaces to "own" their own
background color and image divs, and decide whether to have the icon_div visible or not.

OKAY: I'm not saying the algorithm @PMNTYJ is perfect, but it seems to work decently
enough, and it is trivial to put the workspace into layout mode (l_CA), such that
the user is given big, fat handles to do fine-grained adjustments to the windows.

You can call tile_windows multiple times, with the fit becoming more "snug" each time
until it finally detects window overlap, and finally refuses to do the tiling algorithm
again.


»*/
//«Notes
/*12/21/24: Now we have Workspace objects that get key events sent to them if there«
is a focused window. Otherwise, the desktop itself gets to decide what to do with
the given key event.

I mainly want to make it trivial to set flags on a given workspace, via the WorkMan
app or the command line, so as to disallow ad-hoc changes to window layout.

In a workspace, we can keep state related to "Workspace global states", such as tiled
windows or having them be "locked down", such that hotkeys and/or clicks don't work. 

What kinds of flags can we have here?

allowClose
allowMove
allowResize//including maximize, fullscreen
allowMinimize
allowNone

How about a "winman" command?

We can set these move/close/resize properties on the individual windows and/or
the workspaces.

Now there are more simplified/ more objective/ more granular methods for allowing/
blocking window management functions, now we are in a better position to enable higher 
order methods like various tiling arrangements.

Now that we are checking the key events for these window management functions, we need
to apply this to the mouse movements as well.

Now we have a new kind of tile_windows @JDURKJS. Here we just have the algorithm
to find us the closest window with a bottom edge that stops our top edge from going
all the way to the top of the browser window.

So now we just have to actually extend the edge as necessary, and then do the same
thing for the remaining edges (bottom, left, right) of all the windows.

We can save on cycles here by "remembering" all of the edges that we've already extended,
if in fact we are going to bring two edges together to meet in the middle, which 
seems the most "just" thing for a tiling algorithm to do.

We can set these as flags on our window object, or a sub-object within it, like:

win.tiledEdges = {left: false, right: false, top: false, bottom: false}.

We can also just check of the given edge to see if it is flush with the browser edge.

»*/
/*12/20/24: Just got rid of the idea that new folder windows are created whenever «
you navigate to another folder using one of the following methods (such that the
new windows perfectly "replace" the old ones by copying the dimensions of the
old ones, making it merely seem like the same window is being used):

1) Pressing the 'b' key: to navigate to the parent folder (if the fullpath of
the current folder isn't '/')
2) Pressing the 'f' key: to navigate to the implicit "next child folder" (this
is only possible when the 'b' key has previously been used)
3) When double-clicking or using the folder's icon Cursor: to navigate to an
explicit "next child folder" (this currently clears away the Folder app's prevPaths array)

That was a really embarrasing aspect of how I used to enable folder navigation.

* * * * * * *

Now, the last thing I can really think about in order to really start using this thing
is better window/application opening and layout management, particularly, I think, via
the tiling paradigm. I want a command to define the tiling of a given workspace, based
on layout modes and percentages of filling the browser window's width/height.

Starting with 2 windows, there are only two modes:

1) 2 rows:
|---------|
|---------|
|_________|

2) 2 columns
_________
|	|	|
|	|	|
|	|	|
---------

Then with 3 windows, we have 6 modes:

1) 3 columns
_____________
|	|	|	|
|	|	|	|
|	|	|	|
-------------

2) 3 rows
|---------|
|---------|
|---------|
|_________|

3) 1 column and 2 rows, such that each row's width is the browser width - the column's width

	a) With the column on the left
	____________
	|	|	   |
	|	|______|
	|	|	   |
	------------

	b) With the column on the right
	_____________
	|	   |	|
	|______|	|
	|	   |	|
	-------------

4) 1 row and 2 column, such that each column's height is the browser height - the row's height

	a) With the row on the bottom
	___________
	|    |    |
	|    |    |
	|---------|
	|_________|


	a) With the row on the top
	|---------|
	|_________|
	|    |    |
	|____|____|

As long as these are defined in terms of percentages, then we can resize all of
the windows whenever the browser's dimension's change, via either 
1) browser window magnification
2) opening/closing the developer console

So this gives us 8 distinct layout formats (2 w/ 2 windows; 6 w/ 3 windows)

We can also give a minimum height/width for certain "minor" windows that we don't want
to shrink any smaller than any absolute value (so that it will take up a larger percentage
than its given percentage indicates). I am mainly thinking here about the new "term.log"
thing that I've created.

I actually *really* want a command that opens windows in a given workspace, and
then tiles them according to a certain layout "prescription".

How about looking for an ~/.init/desk.js during the init phase???

»*/
/*12/19/24: Want the new Ctrl+Alt+[1-9] window manager stuff to bring me over to the«
desktop that its on. Where is raise_bound_win
»*/
/*12/17/24: Window Manager time! Want an app called WorkMan that gives us a graphical«
interface into what I starting working on yesterday with the bindwin command.
Need to give an option to bindwin to allow a string description.

You open it up with Ctrl+Alt+0. Then you just pick the window you want to rearrange
by pressing the associated number key (without modifiers). Then you move it around
with the arrow keys (left/right if the window are arranged horizontally, up/down if
vertically). Toggle between row-wise or column-wise alignment via "/". Escape
"deselects" the currently selected window.
»*/
/*12/16/24: DumHack @FSKEUSHFK to "fit" a little window number indicator into «
the bottom left corner without breaking all of the delicately balanced (vis-a-vis 
css display and positioning) stuff in the footer. We had to give the 'footer_wrap'
a relative positioning, and then create a 'numdiv' with abolute positioning, in
order to keep things simple (i.e. without having to get into a whole bunch of
head-scratching about how to work with the flex-display nature of the 'statdiv'
down on the footer). Putting the number indiscretely here on the bottom left
adds a sort of "balancing," fung-shui quality to the whole thing, especially
when the application shows nothing on the statdiv.

The motivation here is to make it trivial to locate the global handle to
windows, so it can be used by, i.e. the new [1-9]_CA shortcut @XKLEUIM
or by some kind of Window Manager App (WMA) that can be invoked by 0_CA.

Then we can use the CLI or the WMA to bind our windows to these keysyms. I
see the WMA version of this as being a kind of "macro", such that there can
be a two-chord sequence in order to bring up lesser used windows than the
ones in the quick/easy [1-9]_CA slots. The combination might be as simple
as 0_CA + a (pressing Ctrl+Alt+0, letting go, and then pressing "a").

This is my quick/dirty way of greatly increasing the available keystrokes that
exist for the purpose of "random-accessibly" bringing your windows into focus.

Then we can start getting to work on our own internal development of our own
Shell. Eventually, we are going to want to use this stuff in a desktop
initialization script (possibly with our shell implementation or some kind of
*VERY* simple language we can work on, for the purpose of commanding the GUI).

Just created a 'bindwin' command, e.g.:
~$ bindwin <win_id_num> <key_num[1-9]>

»*/
/*11/25/24: @WJKNMTYT: When trying to 'mv' a file like this:«
$ mv blah.txt FOOFOOFOO

... node.appName gets to be the name of the application. So this property needs
to be deleted at the appropriate point in the whole process. So we are NOT
choosing @FUIMNTYU to delete it (but rather in fs.com_mv @TUIMN). We might need
to have a '.isData' property on the nodes (as well as a '.isFile'), in order to
cover ALL of our bases (Now we are adding these in mk_dir_kid). Then we can just check
for .isFile if we want to do stuff like deleting the node.appName.
node.appName is only "dynamically" set in saveFsByPath @DHYUI and mk_dir_kid
@PYTNM.

»*/
/*11/22/24 « Want to update the logic in 'make_app' (@DIOLMTNY) to reflect modern 
standards, namely replacing the callback logic (@BGEIUOP) with Promises. Then, go 
through all of the ways that application windows are opened to use this new logic.

HAVING ALL SORTS OF PROBLEMS RENAMING ICONS TO DIFFERENT APPLICATIONS (PARTICULARLY TO
THE DEFAULT BINVIEW APPLICATION), AND THEN OPENING THEM AFTER RENAMING THEM!!!

@FKIOPIU: figured out how to point to the "real" "imgdiv". The one at
wrapper.childNodes[0] could sometimes be the little thing at the top-left
corner of the text icons. So when we updateDOMElement (via the Terminal's 'mv' command)
from a text icon to a DEF_BIN_APP icon, it still keeps the little thing at the
top-left corner (e.g. "txt" or whatever the text extension is). So we just need
to delete this dumb thing (created @YPOIKLJ) @LCUITYEP in Icon.updateDOMElement!!! Took
away the apparently superfluous logic @GJKLIUYT. This attempt to tag
*everything* with '.iconElem' might be related to the algorithmic "paranoia" of
making sure that the icon cursor can always select the icon in places like
@FBVDGHJ.

NEED TO FILTER ALL OF THIS NAMING/IMAGING/RENAMING/REIMAGING LOGIC THROUGH THE VERY 
SAME METHODS (RATHER THAN DOING THE ONE THING IN THE MAIN BODY OF THE ICON LOGIC
AND THE OTHER IN A RENAME METHOD)!!!! ALSO, IT IS CONFUSING TO HAVE AN ICON.setLabelName
method (which only changes the name in the icon's "namespan") AS WELL AS AN
ICON.updateDOMElement (which internally calls setLabelName and does other stuff besides).

We need a single method that does all of the creation of icon images (including
deleting anything that might already be there as well, and adding whatever "frills"
are necessary like those 'txt' things in the upper left corners...).

»*/
//»
