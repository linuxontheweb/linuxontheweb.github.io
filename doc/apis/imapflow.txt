
//ImapFlow«

new ImapFlow(options)//«

//Options

{
	host: "Hostname of the IMAP server",
	port: <Number: Port number for the IMAP server>
	secure: <Boolean Should the connection be established over TLS. If false 
				then connection is upgraded to TLS using STARTTLS extension 
				before authentication>,
	servername: "Servername for SNI (or when host is set to an IP address)",
	disableCompression: <Boolean if true then client does not try to use 
							COMPRESS=DEFLATE extension>,
	auth:{
		user: "username",
		pass: "password",
		accessToken: "OAuth2 Access Token, if using OAuth2 authentications"
	}
	clientInfo: <IdInfoObject>,
	disableAutoIdle: <Boolean if true then IDLE is not started automatically. Useful if you only need to perform specific tasks over the connection>,
	tls: {
		rejectUnauthorized: <Boolean if false then client accepts self-signed and expired certificates from the server>,
		minVersion: "latest Node.js defaults to 'TLSv1.2', for older mail servers 
						you might need to use something else, eg 'TLSv1'"
		minDHSize: <Number: Minimum size of the DH parameter in bits to accept 
						a TLS connection (1024)>
	},
	logger: 	<Custom logger instance with debug(obj), info(obj), warn(obj) and 
					error(obj) methods. If not provided then ImapFlow logs to 
					console using pino format>
	logRaw: 	<Boolean If true then log data read from and written to socket 
					encoded in base64>,
	emitLogs: 	<Boolean If true then in addition of sending data to logger, 
					ImapFlow emits 'log' events with the same data>,
	verifyOnly: <Boolean If true then logs out automatically after successful 
					authentication>,
	proxy: 		<Boolean Optional proxy URL. Supports HTTP CONNECT (http://, https://) and SOCKS (socks://, socks4://, socks5://) proxies>,
	qresync: 	<Boolean If true, then enables QRESYNC support. 
					EXPUNGE notifications will include uid property instead of seq>,
}

//»

Members//«

authenticated :String|Boolean//«
Currently authenticated user or false if mailbox is not open or true if connection was authenticated by PREAUTH
//»
capabilities :Map.<string, (boolean|number)>//«
Active IMAP capabilities. Value is either true for togglabe capabilities (eg. UIDPLUS) or a number for capabilities with a value (eg. APPENDLIMIT)

//»
emitLogs :Boolean//«
If true then in addition of sending data to logger, ImapFlow emits 'log' events with the same data
//»
enabled :Set.<string>//«
Enabled capabilities. Usually CONDSTORE and UTF8=ACCEPT if server supports these.
//»
id :String//«
Instance ID for logs
//»
idling :Boolean//«
Is current mailbox idling (true) or not (false)
//»
mailbox :MailboxObject|Boolean//«
Currently selected mailbox or false if mailbox is not open
//»
secureConnection :Boolean//«
Is the connection currently encrypted or not
//»
serverInfo :IdInfoObject|null//«
Server identification info. Available after successful connect(). If server does not provide identification info then this value is null.

EXAMPLE
await client.connect();
console.log(client.serverInfo.vendor);
//»
usable :Boolean//«
Is the connection currently usable or not
//»
version//«
Current module version as a static class property

PROPERTIES:
Name	Type	Description
version	String	
Module version
//»

//»
Methods//«

(async) noop() → {Promise.<void>}//«
Performs a no-op call against server
//»
close()//«
Closes TCP connection without notifying the server.

EXAMPLE
let client = new ImapFlow({...});
await client.connect();
...
client.close();
//»
(async) idle() → {Promise.<Boolean>}//«
Starts listening for new or deleted messages from the currently opened mailbox. Only required if ImapFlow#disableAutoIdle is set to true otherwise IDLE is started by default on connection inactivity. NB! If idle() is called manually then it does not return until IDLE is finished which means you would have to call some other command out of scope.

EXAMPLE
let mailbox = await client.mailboxOpen('INBOX');

await client.idle();
//»
(async) logout() → {Promise.<void>}//«
Graceful connection close by sending logout command to server. TCP connection is closed once command is finished.

EXAMPLE
let client = new ImapFlow({...});
await client.connect();
...
await client.logout();
//»
(async) connect() → {Promise.<void>}//«
Initiates a connection against IMAP server. Throws if anything goes wrong. This is something you have to call before you can run any IMAP commands

THROWS:
Will throw an error if connection or authentication fails

EXAMPLE
let client = new ImapFlow({...});
await client.connect();
//»

(async) getMailboxLock(path, optionsopt) → {Promise.<MailboxLockObject>}//«

Opens a mailbox if not already open and returns a lock. Next call to
getMailboxLock() is queued until previous lock is released. This is suggested
over mailboxOpen() as getMailboxLock() gives you a weak transaction while
mailboxOpen() has no guarantees whatsoever that another mailbox is opened while
you try to call multiple fetch or store commands.

PARAMETERS:
Name	Type	Attributes	Description
path	string | array		
Path for the mailbox to open

options	Object	<optional>
optional options

PROPERTIES
Name	Type	Attributes	Default	Description
readOnly	Boolean	<optional>
false	
If true then opens mailbox in read-only mode. You can still try to perform write operations but these would probably fail.

THROWS:
Will throw an error if mailbox does not exist or can not be opened

EXAMPLE
let lock = await client.getMailboxLock('INBOX');
try {
  // do something in the mailbox
} finally {
  // use finally{} to make sure lock is released even if exception occurs
  lock.release();
}
//»
(async) getQuota(pathopt) → {Promise.<(QuotaResponse|Boolean)>}//«
Returns current quota

PARAMETERS:
Name	Type	Attributes	Description
path	String	<optional>
Optional mailbox path if you want to check quota for specific folder

EXAMPLE
let quota = await client.getQuota();
console.log(quota.storage.used, quota.storage.available)
//»

(async, generator) fetch(range, query, optionsopt)//«
Fetch messages from currently opened mailbox

PARAMETERS:

Name	Type				Description
range	SequenceString |	Range of messages to fetch //«
		Array.<Number> | 
		SearchObject		
//»
query	FetchQueryObject				Fetch query
options	Object				<optional>	(See Table below)//«

Description Table//«
PROPERTIES
Name			Type	Attributes	Description
uid				Boolean	<optional>  If true then uses UID numbers 
									instead of sequence numbers for range

changedSince	BigInt	<optional>	If set then only messages with a higher modseq 
									value are returned. Ignored if server does 
									not support CONDSTORE extension.

//»

//»

EXAMPLE//«
let mailbox = await client.mailboxOpen('INBOX');
// fetch UID for all messages in a mailbox
for await (let msg of client.fetch('1:*', {uid: true})){
    console.log(msg.uid);
}
//»

//»
(async) fetchOne(seq, query, optionsopt) → {Promise.<FetchMessageObject>}//«

Fetch a single message from currently opened mailbox

PARAMETERS:
Name		Type			Attributes	Description
seq			SequenceString				Single UID or sequence number of 
										the message to fetch for

query		FetchQueryObject			Fetch query

options		Object			<optional>	(See table below)


Table for options
Name	Type	Attributes	Description
uid		Boolean	<optional>	If true then uses UID number instead 
							of sequence number for seq

EXAMPLE//«
let mailbox = await client.mailboxOpen('INBOX');
// fetch UID for all messages in a mailbox
let lastMsg = await client.fetchOne('*', {uid: true})
console.log(lastMsg.uid);
//»

//»
(async) list() → {Promise.<Array.<ListResponse>>}//«
Lists available mailboxes as an Array

EXAMPLE
let list = await client.list();
list.forEach(mailbox=>console.log(mailbox.path));
//»
(async) listTree() → {Promise.<ListTreeResponse>}//«
Lists available mailboxes as a tree structured object

EXAMPLE
let tree = await client.listTree();
tree.folders.forEach(mailbox=>console.log(mailbox.path));
//»
(async) search(query, optionsopt) → {Promise.<Array.<Number>>}//«
Search messages from currently opened mailbox

PARAMETERS:
Name	Type	Attributes	Description
query	SearchObject		
Query to filter the messages

options	Object	<optional>
PROPERTIES
Name	Type	Attributes	Description
uid	Boolean	<optional>
If true then returns UID numbers instead of sequence numbers

EXAMPLE
let mailbox = await client.mailboxOpen('INBOX');
// find all unseen messages
let list = await client.search({seen: false});
// use OR modifier (array of 2 or more search queries)
let list = await client.search({
  seen: false,
  or: [
    {flagged: true},
    {from: 'andris'},
    {subject: 'test'}
  ]});
//»
(async) status(path, query) → {Promise.<StatusObject>}//«
Requests the status of the indicated mailbox. Only requested status values will be returned.

PARAMETERS:
Name	Type	Description
path	String	
mailbox path to check for

query	Object	
defines requested status items

PROPERTIES
Name	Type	Description
messages	Boolean	
if true request count of messages

recent	Boolean	
if true request count of messages with \Recent tag

uidNext	Boolean	
if true request predicted next UID

uidValidity	Boolean	
if true request mailbox UIDVALIDITY value

unseen	Boolean	
if true request count of unseen messages

highestModseq	Boolean	
if true request last known modseq value

EXAMPLE
let status = await client.status('INBOX', {unseen: true});
console.log(status.unseen);
//»
(async) download(range, partopt, optionsopt) → {Promise.<DownloadObject>}//«
Download either full rfc822 formated message or a specific bodystructure part as a Stream. Bodystructure parts are decoded so the resulting stream is a binary file. Text content is automatically converted to UTF-8 charset.

PARAMETERS:
Name	Type	Attributes	Description
range	SequenceString		
UID or sequence number for the message to fetch

part	String	<optional>
If not set then downloads entire rfc822 formatted message, otherwise downloads specific bodystructure part

options	Object	<optional>
PROPERTIES
Name	Type	Attributes	Default	Description
uid	Boolean	<optional>
If true then uses UID number instead of sequence number for range

maxBytes	number	<optional>
If set then limits download size to specified bytes

chunkSize	number	<optional>
65536	
How large content parts to ask from the server

EXAMPLE
let mailbox = await client.mailboxOpen('INBOX');
// download body part nr '1.2' from latest message
let {meta, content} = await client.download('*', '1.2');
content.pipe(fs.createWriteStream(meta.filename));
//»
(async) append(path, content, flagsopt, idateopt) → {Promise.<AppendResponseObject>}//«
Appends a new message to a mailbox

PARAMETERS:
Name	Type	Attributes	Default	Description
path	String			
Mailbox path to upload the message to

content	string | Buffer			
RFC822 formatted email message

flags	Array.<string>	<optional>
an array of flags to be set for the uploaded message

idate	Date | string	<optional>
now	
internal date to be set for the message

EXAMPLE
await client.append('INBOX', rawMessageBuffer, ['\\Seen'], new Date(2000, 1, 1));
//»

(async) mailboxClose() → {Promise.<Boolean>}//«
Closes a previously opened mailbox

EXAMPLE
let mailbox = await client.mailboxOpen('INBOX');
await client.mailboxClose();
//»
(async) mailboxCreate(path) → {Promise.<MailboxCreateResponse>}//«
Creates a new mailbox folder and sets up subscription for the created mailbox. Throws on error.

PARAMETERS:
Name	Type	Description
path	string | array	
Full mailbox path. Unicode is allowed. If value is an array then it is joined using current delimiter symbols. Namespace prefix is added automatically if required.

THROWS:
Will throw an error if mailbox can not be created

EXAMPLE
let info = await client.mailboxCreate(['parent', 'child']);
console.log(info.path);
// "INBOX.parent.child" // assumes "INBOX." as namespace prefix and "." as delimiter
//»
(async) mailboxDelete(path) → {Promise.<MailboxDeleteResponse>}//«
Deletes a mailbox. Throws on error.

PARAMETERS:
Name	Type	Description
path	string | array	
Path for the mailbox to delete. Unicode is allowed. If value is an array then it is joined using current delimiter symbols. Namespace prefix is added automatically if required.

THROWS:
Will throw an error if mailbox does not exist or can not be deleted

EXAMPLE
let info = await client.mailboxDelete('Important stuff ❗️');
console.log(info.path);
// "INBOX.Important stuff ❗️" // assumes "INBOX." as namespace prefix
//»
(async) mailboxOpen(path, optionsopt) → {Promise.<MailboxObject>}//«

Opens a mailbox to access messages. You can perform message operations only
against an opened mailbox. Using getMailboxLock() instead of mailboxOpen() is
preferred. Both do the same thing but next getMailboxLock() call is not
executed until previous one is released.

PARAMETERS:
Name	Type	Attributes	Description
path	string | array		
Path for the mailbox to open

options	Object	<optional>
optional options

PROPERTIES
Name	Type	Attributes	Default	Description
readOnly	Boolean	<optional>
false	
If true then opens mailbox in read-only mode. You can still try to perform write operations but these would probably fail.

THROWS:
Will throw an error if mailbox does not exist or can not be opened

EXAMPLE
let mailbox = await client.mailboxOpen('Important stuff ❗️');
console.log(mailbox.exists);
// 125
//»
(async) mailboxRename(path, newPath) → {Promise.<MailboxRenameResponse>}//«
Renames a mailbox. Throws on error.

PARAMETERS:
Name	Type	Description
path	string | array	
Path for the mailbox to rename. Unicode is allowed. If value is an array then it is joined using current delimiter symbols. Namespace prefix is added automatically if required.

newPath	string | array	
New path for the mailbox

THROWS:
Will throw an error if mailbox does not exist or can not be renamed

EXAMPLE
let info = await client.mailboxRename('parent.child', 'Important stuff ❗️');
console.log(info.newPath);
// "INBOX.Important stuff ❗️" // assumes "INBOX." as namespace prefix
//»
(async) mailboxSubscribe(path) → {Promise.<Boolean>}//«
Subscribes to a mailbox

PARAMETERS:
Name	Type	Description
path	string | array	
Path for the mailbox to subscribe to. Unicode is allowed. If value is an array then it is joined using current delimiter symbols. Namespace prefix is added automatically if required.

EXAMPLE
await client.mailboxSubscribe('Important stuff ❗️');
//»
(async) mailboxUnsubscribe(path) → {Promise.<Boolean>}//«
Unsubscribes from a mailbox

PARAMETERS:
Name	Type	Description
path	string | array	
Path for the mailbox to unsubscribe from. Unicode is allowed. If value is an array then it is joined using current delimiter symbols. Namespace prefix is added automatically if required.

EXAMPLE
await client.mailboxUnsubscribe('Important stuff ❗️');
//»

(async) messageCopy(range, destination, optionsopt) → {Promise.<CopyResponseObject>}//«
Copies messages from current mailbox to destination mailbox

PARAMETERS:
Name	Type	Attributes	Description
range	SequenceString | Array.<Number> | SearchObject		
Range of messages to copy

destination	String		
Mailbox path to copy the messages to

options	Object	<optional>
PROPERTIES
Name	Type	Attributes	Description
uid	Boolean	<optional>
If true then uses UID SequenceString instead of sequence numbers

EXAMPLE
await client.mailboxOpen('INBOX');
// copy all messages to a mailbox called "Backup" (must exist)
let result = await client.messageCopy('1:*', 'Backup');
console.log('Copied %s messages', result.uidMap.size);
//»
(async) messageDelete(range, optionsopt) → {Promise.<Boolean>}//«

Delete messages from currently opened mailbox. Method does not indicate info
about deleted messages, instead you should be using ImapFlow#expunge event for
this

PARAMETERS:
Name	Type	Attributes	Description
range	SequenceString | Array.<Number> | SearchObject		
Range to filter the messages

options	Object	<optional>
PROPERTIES
Name	Type	Attributes	Description
uid	Boolean	<optional>
If true then uses UID SequenceString instead of sequence numbers

EXAMPLE
let mailbox = await client.mailboxOpen('INBOX');
// delete all seen messages

await client.messageDelete({seen: true});
//»
(async) messageFlagsAdd(range, Array, optionsopt) → {Promise.<Boolean>}//«
Adds flags for a message or message range

PARAMETERS:
Name	Type	Attributes	Description
range	SequenceString | Array.<Number> | SearchObject		
Range to filter the messages

Array	Array.<string>		
of flags to set. Only flags that are permitted to set are used, other flags are ignored

options	Object	<optional>
PROPERTIES
Name	Type	Attributes	Default	Description
uid	Boolean	<optional>
If true then uses UID SequenceString instead of sequence numbers

unchangedSince	BigInt	<optional>
If set then only messages with a lower or equal modseq value are updated. Ignored if server does not support CONDSTORE extension.

useLabels	Boolean	<optional>
false	
If true then update Gmail labels instead of message flags

EXAMPLE
let mailbox = await client.mailboxOpen('INBOX');
// mark all unseen messages as seen (and keep other flags as is)
await client.messageFlagsAdd({seen: false}, ['\Seen]);
//»
(async) messageFlagsRemove(range, Array, optionsopt) → {Promise.<Boolean>}//«
Remove specific flags from a message or message range

PARAMETERS:
Name	Type	Attributes	Description
range	SequenceString | Array.<Number> | SearchObject		
Range to filter the messages

Array	Array.<string>		
of flags to remove. Only flags that are permitted to set are used, other flags are ignored

options	Object	<optional>
PROPERTIES
Name	Type	Attributes	Default	Description
uid	Boolean	<optional>
If true then uses UID SequenceString instead of sequence numbers

unchangedSince	BigInt	<optional>
If set then only messages with a lower or equal modseq value are updated. Ignored if server does not support CONDSTORE extension.

useLabels	Boolean	<optional>
false	
If true then update Gmail labels instead of message flags

EXAMPLE
let mailbox = await client.mailboxOpen('INBOX');
// mark all seen messages as unseen by removing \\Seen flag
await client.messageFlagsRemove({seen: true}, ['\Seen]);
//»
(async) messageFlagsSet(range, Array, optionsopt) → {Promise.<Boolean>}//«
Sets flags for a message or message range

PARAMETERS:
Name	Type	Attributes	Description
range	SequenceString | Array.<Number> | SearchObject		
Range to filter the messages

Array	Array.<string>		
of flags to set. Only flags that are permitted to set are used, other flags are ignored

options	Object	<optional>
PROPERTIES
Name	Type	Attributes	Default	Description
uid	Boolean	<optional>
If true then uses UID SequenceString instead of sequence numbers

unchangedSince	BigInt	<optional>
If set then only messages with a lower or equal modseq value are updated. Ignored if server does not support CONDSTORE extension.

useLabels	Boolean	<optional>
false	
If true then update Gmail labels instead of message flags

EXAMPLE
let mailbox = await client.mailboxOpen('INBOX');
// mark all unseen messages as seen (and remove other flags)
await client.messageFlagsSet({seen: false}, ['\Seen]);
//»
(async) messageMove(range, destination, optionsopt) → {Promise.<CopyResponseObject>}//«
Moves messages from current mailbox to destination mailbox

PARAMETERS:
Name	Type	Attributes	Description
range	SequenceString | Array.<Number> | SearchObject		
Range of messages to move

destination	String		
Mailbox path to move the messages to

options	Object	<optional>
PROPERTIES
Name	Type	Attributes	Description
uid	Boolean	<optional>
If true then uses UID SequenceString instead of sequence numbers

EXAMPLE
await client.mailboxOpen('INBOX');
// move all messages to a mailbox called "Trash" (must exist)
let result = await client.messageMove('1:*', 'Trash');
console.log('Moved %s messages', result.uidMap.size);
//»

//»
Events//«

log :Object//«
Log event if emitLogs=true

EXAMPLE
client.on('log', entry => {
    console.log(`${log.cid} ${log.msg}`);
});
//»
close//«
Connection close event. NB! ImapFlow does not handle reconncts automatically. So whenever a 'close' event occurs you must create a new connection yourself.
//»
error :Error//«
Error event. In most cases getting an error event also means that connection is closed and pending operations should return with a failure.

EXAMPLE
client.on('error', err=>{
    console.log(`Error occurred: ${err.message}`);
});
//»

exists :Object//«
Message count in currently opened mailbox changed

PROPERTIES:
Name	Type	Description
path	String	
mailbox path this event applies to

count	Number	
updated count of messages

prevCount	Number	
message count before this update

EXAMPLE
client.on('exists', data=>{
    console.log(`Message count in "${data.path}" is ${data.count}`);
});
//»
expunge :Object//«

Deleted message sequence number in currently opened mailbox. One event is fired
for every deleted email.

PROPERTIES:
Name	Type	Description
path	String	
mailbox path this event applies to

seq	Number	
sequence number of deleted message

EXAMPLE
client.on('expunge', data=>{
    console.log(`Message #${data.seq} was deleted from "${data.path}"`);
});
//»
flags :Object//«

Flags were updated for a message. Not all servers fire this event.

PROPERTIES:
Name	Type	Attributes	Description
path	String		
mailbox path this event applies to

seq	Number		
sequence number of updated message

uid	Number	<optional>
UID number of updated message (if server provided this value)

modseq	BigInt	<optional>
Updated modseq number for the mailbox (if server provided this value)

flags	Set.<string>		
A set of all flags for the updated message

EXAMPLE
client.on('flags', data=>{
    console.log(`Flag set for #${data.seq} is now "${Array.from(data.flags).join(', ')}"`);
});
//»

mailboxClose :MailboxObject//«
Mailbox was closed

EXAMPLE
client.on('mailboxClose', mailbox => {
    console.log(`Mailbox ${mailbox.path} was closed`);
});
//»
mailboxOpen :MailboxObject//«
Mailbox was opened

EXAMPLE
client.on('mailboxOpen', mailbox => {
    console.log(`Mailbox ${mailbox.path} was opened`);
});
//»

//»

//»

//Global«
 
SearchObject :Object//«

IMAP search query options. By default all conditions must match. In case of or
query term at least one condition must match.

PROPERTIES:
Name		Type			Description
seq			SequenceString	message ordering sequence range
answered	Boolean			Messages with (value is true) or without (value 
								is false) \Answered flag
deleted		Boolean			Messages with (value is true) or without (value 
								is false) \Deleted flag
draft		Boolean			Messages with (value is true) or without (value 
								is false) \Draft flag
flagged		Boolean			Messages with (value is true) or without (value is 
								false) \Flagged flag
seen	Boolean				Messages with (value is true) or without (value 
								is false) \Seen flag
all		Boolean				If true matches all messages
new		Boolean				If true matches messages that have the \Recent flag 
								set but not the \Seen flag
old		Boolean				If true matches messages that do not have the 
								\Recent flag set
recent	Boolean				If true matches messages that have the \Recent 
								flag set
from	String				Matches From: address field
to		String				Matches To: address field
cc		String				Matches Cc: address field
bcc		String				Matches Bcc: address field
body	String				Matches message body
subject	String				Matches message subject
larger	Number				Matches messages larger than value
smaller	Number				Matches messages smaller than value
uid		SequenceString		UID sequence range
modseq	BigInt				Matches messages with modseq higher than value
emailId	String				unique email ID. Only used if server supports 
								OBJECTID or X-GM-EXT-1 extensions
threadId String				unique thread ID. Only used if server supports OBJECTID or X-GM-EXT-1 extensions
before	Date | string		Matches messages received before date
on		Date | string		Matches messages received on date (ignores time)
since	Date | string		Matches messages received after date
sentBefore	Date | string	Matches messages sent before date
sentOn	Date | string		Matches messages sent on date (ignores time)
sentSince	Date | string	Matches messages sent after date
keyword		String			Matches messages that have the custom flag set
unKeyword	String			Matches messages that do not have the custom flag set
header	Object.<string,		Matches messages with header key set if value is true  
			(Boolean|		(NB! not supported by all servers) or messages where 
			String)>		header partially matches a string value
or	Array.<SearchObject>	An array of 2 or more SearchObject objects. At least 
								on of these must match

//»
DownloadObject :Object//«

PROPERTIES:
Name		Type			Description
meta		Object			(See table below)
content		ReadableStream	Streamed content

Table for content metadata
Name		Type		Description
contentType	String		Content-Type of the streamed file. If part was not 
							set then this value is "message/rfc822"
charset		String		Charset of the body part. Text parts are automaticaly 
							converted to UTF-8, attachments are kept as is
disposition	String		Content-Disposition of the streamed file
filename	String		Filename of the streamed body part

//»
FetchMessageObject :Object//«

Fetched message data

Name		Type		Description
seq			Number		message sequence number. Always included in the response
uid			Number		message UID number. Always included in the response
source		Buffer		message source for the requested byte range
modseq		BigInt		message Modseq number. Always included if the server 
							supports CONDSTORE extension
emailId		String		unique email ID. Always included if server supports 
							OBJECTID or X-GM-EXT-1 extensions
threadid	String		unique thread ID. Only present if server supports 
							OBJECTID or X-GM-EXT-1 extension
labels		Set.<string> a Set of labels. Only present if server supports 
							X-GM-EXT-1 extension
size		Number		message size
flags		Set.<string> a set of message flags
bodyParts	Map.		a Map of message body parts where key is requested part 
			 <string, 		identifier and value is a Buffer
				Buffer>	
headers		Buffer		Requested header lines as Buffer
internalDate Date		message internal date
envelope		MessageEnvelopeObject		message envelope
bodyStructure 	MessageStructureObject	message body structure


//»
FetchQueryObject :Object//«
Name		Type		Description
uid			Boolean		if true then include UID in the response
flags		Boolean		if true then include flags Set in the response
bodyStructure Boolean	if true then include parsed BODYSTRUCTURE object 
							in the response
envelope	Boolean		if true then include parsed ENVELOPE object in the response
internalDate Boolean	if true then include internal date value in the response
size		Boolean		if true then include message size in the response
source		boolean 	if true then include full message in the response
			 | Object	
			  (see table 
				  below)
Name		Type		Description
start		Number		include full message in the response starting from 
							start byte
maxLength	Number		include full message in the response, up to maxLength bytes
threadId	String		if true then include thread ID in the response (only if 
							server supports either OBJECTID or X-GM-EXT-1 extensions)
labels		Boolean		if true then include GMail labels in the response (only 
							if server supports X-GM-EXT-1 extension)
headers		boolean | 	if true then includes full headers of the message 
			Array.			in the response. If the value is an array of header 
			<string>		keys then includes only headers listed in the array
bodyParts	Array.		An array of BODYPART identifiers to include in the response
			 <string>	
//»

AppendResponseObject :Object//«
PROPERTIES:
Name	Type		Description
path	String		full mailbox path where the message was uploaded to

uidValidity	BigInt	mailbox UIDVALIDITY if server has UIDPLUS extension enabled

uid		Number		UID of the uploaded message if server has UIDPLUS extension 
						enabled

seq		Number		sequence number of the uploaded message if path is currently 
						selected mailbox

//»
CopyResponseObject :Object//«
PROPERTIES:
Name	Type		Description
path	String		path of source mailbox

destination	String	path of destination mailbox

uidValidity	BigInt	destination mailbox UIDVALIDITY if server has UIDPLUS extension enabled

uidMap	Map.<number, Map of UID values (if server has UIDPLUS extension enabled) 
			number>	 where key is UID in source mailbox and value is the UID for 
					 the same message in destination mailbox

//»
ListResponse :Object//«
Name		Type	Description
path		String	mailbox path
name		String	mailbox name (last part of path after delimiter)
delimiter	String	mailbox path delimiter, usually "." or "/"
flags		Set.	a set of flags for this mailbox
			 <string>	
specialUse	String	one of special-use flags (if applicable): 
					"\All", "\Archive", "\Drafts", "\Flagged", "\Junk", 
					"\Sent", "\Trash". Additionally INBOX has non-standard 
					"\Inbox" flag set
listed		Boolean	true if mailbox was found from the output of LIST command
subscribed	Boolean	true if mailbox was found from the output of LSUB command
//»
ListTreeResponse :Object//«

Name	Type		Description
root	Boolean		If true then this is root node without any additional properties 
					besides folders
path	String		mailbox path
name	String		mailbox name (last part of path after delimiter)
delimiter String	mailbox path delimiter, usually "." or "/"
flags	array		list of flags for this mailbox
specialUse String	one of special-use flags (if applicable): "\All", "\Archive", 
					"\Drafts", "\Flagged", "\Junk", "\Sent", "\Trash". 
					Additionally INBOX has non-standard "\Inbox" flag set
listed	Boolean		true if mailbox was found from the output of LIST command
subscribed Boolean	true if mailbox was found from the output of LSUB command
disabled   Boolean	If true then this mailbox can not be selected in the UI
folders	Array.		An array of subfolders
		 <ListTreeResponse>	

//»
QuotaResponse :Object//«
PROPERTIES:
Name	Type	Attributes	Default	Description
path	String		INBOX	
mailbox path this quota applies to

storage	Object	<optional>
Storage quota if provided by server

PROPERTIES
Name	Type	Attributes	Description
used	Number	<optional>
used storage in bytes

limit	Number	<optional>
total storage available

messages	Object	<optional>
Message count quota if provided by server

PROPERTIES
Name	Type	Attributes	Description
used	Number	<optional>
stored messages

limit	Number	<optional>
maximum messages allowed

//»
StatusObject :Object//«

PROPERTIES:
Name		Type		Description
path		String		full mailbox path that was checked
messages 	Number		Count of messages
recent		Number		Count of messages with \Recent tag
uidNext		Number		Predicted next UID
uidValidity	BigInt		Mailbox UIDVALIDITY value
unseen		Number		Count of unseen messages
highestModseq BigInt	Last known modseq value (if CONDSTORE extension is enabled)


//»

IdInfoObject :Object//«
Client and server identification object, where key is one of RFC2971 defined data fields (but not limited to).

PROPERTIES:
Name	Type	Attributes	Description
name	String	<optional>
Name of the program

version	String	<optional>
Version number of the program

os	String	<optional>
Name of the operating system

vendor	String	<optional>
Vendor of the client/server

'support-url'	String	<optional>
URL to contact for support

date	Date	<optional>
Date program was released
//»
SequenceString :String//«

Sequence range string. Separate different values with commas, number ranges
with colons and use '*' as the placeholder for the newest message in mailbox

EXAMPLE
"1:*" // for all messages
"1,2,3" // for messages 1, 2 and 3
"1,2,4:6" // for messages 1,2,4,5,6
"*" // for the newest message
//»

MailboxObject :Object//«

Name			Type		Description

path			String		mailbox path
delimiter		String		mailbox 	path delimiter, usually "." or "/"
flags			Set.<string> list of flags for this mailbox
specialUse		String		one of special-use flags (if applicable): "\All", "\Archive", "\Drafts", "\Flagged", "\Junk", "\Sent", "\Trash". Additionally INBOX has non-standard "\Inbox" flag set
listed			Boolean		true if mailbox was found from the output of LIST 
								command
subscribed		Boolean		true if mailbox was found from the output of LSUB 
								command
permanentFlags	Set.<string> A Set of flags available to use in this mailbox. 
								If it is not set or includes special flag "\*" 
								then any flag can be used.
mailboxId		String		unique mailbox ID if server has OBJECTID extension 
								enabled
highestModseq	BigInt		latest known modseq value if server has CONDSTORE or 
								XYMHIGHESTMODSEQ enabled
noModseq		String		if true then the server doesn't support the 
								persistent storage of mod-sequences for the mailbox
uidValidity		BigInt		Mailbox UIDVALIDITY value
uidNext			Number		Next predicted UID
exists			Number		Messages in this folder

//»
MailboxCreateResponse :Object//«
PROPERTIES:
Name	Type	Attributes	Description
path	String		
full mailbox path

mailboxId	String	<optional>
unique mailbox ID if server supports OBJECTID extension (currently Yahoo and some others)

created	Boolean		
If true then mailbox was created otherwise it already existed

//»
MailboxDeleteResponse :Object//«
PROPERTIES:
Name	Type	Description
path	String	
full mailbox path that was deleted

//»
MailboxLockObject :Object//«
PROPERTIES:
Name	Type	Description
path	String	
mailbox path

release	function	
Release current lock

EXAMPLE
let lock = await client.getMailboxLock('INBOX');
try {
  // do something in the mailbox
} finally {
  // use finally{} to make sure lock is released even if exception occurs
  lock.release();
}
//»
MailboxRenameResponse :Object//«
PROPERTIES:
Name	Type	Description
path	String	
full mailbox path that was renamed

newPath	String	
new full mailbox path
//»

MessageAddressObject :Object//«
Parsed email address entry

PROPERTIES:
Name	Type	Attributes	Description
name	String	<optional>
name of the address object (unicode)

address	String	<optional>
email address
//»
MessageEnvelopeObject :Object//«
Parsed IMAP ENVELOPE object

PROPERTIES:
Name		Type		Description
date		Date		header date

subject		String		message subject (unicode)
messageId	String		Message ID of the message
inReplyTo	String		Message ID from In-Reply-To header
from	Array.			Array of addresses from the From: header
		<MessageAddressObject>	
sender	Array.			Array of addresses from the Sender: header
		<MessageAddressObject>	
replyTo	Array.			Array of addresses from the Reply-To: header
		<MessageAddressObject>	
to		Array.			Array of addresses from the To: header
	<MessageAddressObject>	
cc		Array.			Array of addresses from the Cc: header
	<MessageAddressObject>	
bcc		Array.			Array of addresses from the Bcc: header
		<MessageAddressObject>	
//»
MessageStructureObject :Object//«
Parsed IMAP BODYSTRUCTURE object

PROPERTIES:
Name		Type		Description
part		String		Body part number. This value can be used to later fetch the 
						contents of this part of the message
type		String		Content-Type of this node
parameters	Object		Additional parameters for Content-Type, eg "charset"
id			String		Content-ID
encoding	String		Transfer encoding
size		Number		Expected size of the node
envelope	Message		message envelope of embedded RFC822 message
			 Envelope
			 Object	
disposition	String		Content disposition
disposition Object		Additional parameters for Content-Disposition
 Parameters	
childNodes	Array.		An array of child nodes if this is a multipart node. Not present for normal nodes
			<MessageStructureObject>		
//»

//»

//Home«

Managing IMAP connections is cool, but if you are only looking for an easy way
to integrate email accounts, then ImapFlow was built for EmailEngine Email API.
It's a self-hosted software that converts all IMAP accounts to easy-to-use REST
interfaces.

The focus for ImapFlow is to provide easy to use API over IMAP. Using ImapFlow
does not expect knowledge about specific IMAP details. A general understanding
is good enough.

IMAP extensions are handled in the background, so for example, you can always
request labels value from a fetch() call, but if the IMAP server does not
support X-GM-EXT1 extension, then labels value is not included in the response.

Source
Source code is available from Github.

Usage
First install the module from npm:

$ npm install imapflow
next import the ImapFlow class into your script:

const { ImapFlow } = require('imapflow');
PROMISES

All ImapFlow methods use Promises, so you need to wait using await or wait for
the then() method to fire until you get the response.

//Example«
const { ImapFlow } = require('imapflow');
const client = new ImapFlow({
    host: 'ethereal.email',
    port: 993,
    secure: true,
    auth: {
        user: 'garland.mcclure71@ethereal.email',
        pass: 'mW6e4wWWnEd3H4hT5B'
    }
});

const main = async () => {
    // Wait until client connects and authorizes
    await client.connect();

    // Select and lock a mailbox. Throws if mailbox does not exist
    let lock = await client.getMailboxLock('INBOX');
    try {
        // fetch latest message source
        // client.mailbox includes information about currently selected mailbox
        // "exists" value is also the largest sequence number available in the mailbox
        let message = await client.fetchOne(client.mailbox.exists, { source: true });
        console.log(message.source.toString());

        // list subjects for all messages
        // uid value is always included in FETCH response, envelope strings are in unicode.
        for await (let message of client.fetch('1:*', { envelope: true })) {
            console.log(`${message.uid}: ${message.envelope.subject}`);
        }
    } finally {
        // Make sure lock is released, otherwise next `getMailboxLock()` never returns
        lock.release();
    }

    // log out and close connection
    await client.logout();
};

main().catch(err => console.error(err));
//»

//»


